[{"title":"test","url":"/2025/03/12/test.html","content":"\n# 构建Boot项目\n\n## 传统方式生成","tags":["spring"],"categories":["原理探究"]},{"title":"一文详解Optional","url":"/2023/05/06/一文详解Optional.html","content":"\n# 简介\n\n当我们需要使用某个对象的属性或方法时，如果该对象为 null，则会抛出空指针异常。为了避免这种异常的发生，我们通常需要在代码中添加大量的 if-else 判断来检查对象是否为 null。这样的代码不仅繁琐，而且不易于阅读和维护。\n\nOptional 类提供了一种更好的方式来处理 null 值。使用 Optional 类，可以将对象的可能存在或不存在的状态封装成一个容器对象，可以避免直接操作对象时出现空指针异常，同时还能让代码更加简洁和易于阅读。\n\nBrian Goetz （Java语言设计架构师）对Optional设计意图的原话如下：\n\n> Optional is intended to provide a limited mechanism for library method return types where there needed to be a clear way to represent “no result,\" and using null for such was overwhelmingly likely to cause errors.\n\n这句话突出了三个点：\n\n1. Optional 是用来作为方法返回值的\n2. Optional 是为了清晰地表达返回值中没有结果的可能性\n3. 且如果直接返回 null 很可能导致调用端产生错误（尤其是NullPointerException）\n\nOptional的机制类似于 Java 的受检异常，强迫API调用者面对没有返回值的现实。\n\n因此，不要滥用Optional，关于Optional使用规范可以参考[Java 8 Optional 最佳实践](https://www.bing.com/ck/a?!&&p=5dae3150e35ecf07JmltdHM9MTY4MzMzMTIwMCZpZ3VpZD0xMWVlYWMyZS1mODgzLTZlYmQtMjA2OC1iZDJlZjlhZDZmY2EmaW5zaWQ9NTE3OA&ptn=3&hsh=3&fclid=11eeac2e-f883-6ebd-2068-bd2ef9ad6fca&psq=optional&u=a1aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMjg0ODE0MzQ&ntb=1)。\n\n# 示例\n\n## Optional\n\nOptional可能包含或不包含非空值的容器对象。 如果一个值存在，isPresent()将返回true并且get()将返回值。提供依赖于存在或不存在包含值的其他方法，例如orElse()，如果值不存在则返回默认值；ifPresent()，如果值存在则执行代码块。\n\nOptional提供以下方法：\n\n| **方法类型及返回值**    | **方法名称**                                         | **描述**                                                     |\n| ----------------------- | ---------------------------------------------------- | ------------------------------------------------------------ |\n| static <T> Optional<T>  | empty()                                              | 返回一个空的Optional实例。                                   |\n| boolean                 | equals(Object obj)                                   | 指示某个其他对象是否等于此可选项。                           |\n| Optional<T>             | filter(Predicate<? super T> predicate)               | 如果一个值存在，并且该值给定的谓词相匹配时，返回一个 Optional描述的值，否则返回一个空的Optional 。 |\n| <U> Optional<U>         | flatMap(Function<? super T,Optional<U>> mapper)      | 如果一个值存在，应用提供的Optional映射函数给它，返回该结果，否则返回一个空的Optional 。 |\n| T                       | get()                                                | 如果Optional中有一个值，返回值，否则抛出 NoSuchElementException 。 |\n| int                     | hashCode()                                           | 返回当前值的哈希码值（如果有的话），如果没有值，则返回0（零）。 |\n| void                    | ifPresent(Consumer<? super T> consumer)              | 如果存在值，则使用该值调用指定的消费者，否则不执行任何操作。 |\n| boolean                 | isPresent()                                          | 返回true如果存在值，否则为 false 。                          |\n| <U> Optional<U>         | map(Function<? super T,? extends U> mapper)          | 如果存在一个值，则应用提供的映射函数，如果结果不为空，则返回一个Optional结果的Optional 。 |\n| static <T> Optional<T>  | of(T value)                                          | 返回具有Optional的当前非空值的Optional。                     |\n| static <T> Optional<T>  | ofNullable(T value)                                  | 返回一个Optional指定值的Optional，如果非空，则返回一个空的Optional 。 |\n| T                       | orElse(T other)                                      | 返回值如果存在，否则返回other 。                             |\n| T                       | orElseGet(Supplier<? extends T> other)               | 返回值（如果存在），否则调用other并返回该调用的结果。        |\n| <X extends Throwable> T | orElseThrow(Supplier<? extends X> exceptionSupplier) | 返回包含的值（如果存在），否则抛出由提供的供应商创建的异常。 |\n| String                  | toString()                                           | 返回此可选的非空字符串表示，适用于调试。                     |\n\n测试方法：\n\n```Java\nprivate static void test1() {\n    // 测试empty方法\n    Optional<User> empty = Optional.<User>empty();\n    System.out.println(\"测试empty方法：\");\n    System.out.println(empty);\n    System.out.println(\"-----------------------\");\n\n    // 测试equals方法\n    Optional<User> optional1 = Optional.of(User.builder().username(\"lisi\").build());\n    Optional<User> optional2 = Optional.of(User.builder().username(\"zhangsan\").build());\n    System.out.println(\"测试equals方法：\");\n    System.out.println(optional1.equals(optional2));\n    System.out.println(\"-----------------------\");\n\n    // 测试filter方法\n    Optional<User> optional3 = Optional.of(User.builder().username(\"zhangsan\").build());\n    Optional<User> optional4 = optional3.filter(new Predicate<User>() {\n        @Override\n        public boolean test(User user) {\n            return Objects.equals(\"zhangsan\", user.getUsername());\n        }\n    });\n    System.out.println(\"测试filter方法：\");\n    System.out.println(optional4);\n    System.out.println(\"-----------------------\");\n\n    // 测试flatMap方法\n    Optional<User> optional5 = Optional.of(User.builder().username(\"zhangsan\").build());\n    Optional<User> optional6 = optional5.flatMap(new Function<User, Optional<User>>() {\n        @Override\n        public Optional<User> apply(User user) {\n            if (Objects.equals(\"zhangsan\", user.getUsername())) {\n                return Optional.of(user);\n            }\n            return Optional.empty();\n        }\n    });\n    System.out.println(\"测试flatMap方法：\");\n    System.out.println(optional6);\n    System.out.println(\"-----------------------\");\n\n    // 测试get方法\n    Optional<User> optional7 = Optional.of(User.builder().username(\"zhangsan\").build());\n    System.out.println(\"测试get方法：\");\n    System.out.println(optional7.get());\n    System.out.println(\"-----------------------\");\n\n    // 测试hashCode方法\n    Optional<User> optional8 = Optional.of(User.builder().username(\"zhangsan\").build());\n    System.out.println(\"测试hashCode方法：\");\n    System.out.println(optional8.hashCode());\n    System.out.println(\"-----------------------\");\n\n    // 测试ifPresent方法\n    Optional<User> optional9 = Optional.of(User.builder().username(\"zhangsan\").build());\n    System.out.println(\"测试ifPresent方法：\");\n    optional9.ifPresent(new Consumer<User>() {\n        @Override\n        public void accept(User user) {\n            System.out.println(user);\n        }\n    });\n    System.out.println(\"-----------------------\");\n\n    // 测试isPresent方法\n    Optional<User> optional10 = Optional.of(User.builder().username(\"zhangsan\").build());\n    System.out.println(\"测试isPresent方法：\");\n    System.out.println(optional10.isPresent());\n    System.out.println(\"-----------------------\");\n\n    // 测试map方法\n    Optional<User> optional11 = Optional.of(User.builder().username(\"zhangsan\").build());\n    System.out.println(\"测试map方法：\");\n    Optional<User> optional12 = optional11.map(new Function<User, User>() {\n        @Override\n        public User apply(User user) {\n            if (Objects.equals(\"zhangsan\", user.getUsername())) {\n                return user;\n            }\n            return null;\n        }\n    });\n    System.out.println(optional12);\n    System.out.println(\"-----------------------\");\n\n    // 测试of方法\n    Optional<User> optional13 = Optional.of(User.builder().username(\"zhangsan\").build());\n    System.out.println(\"测试of方法：\");\n    System.out.println(optional13);\n    System.out.println(\"-----------------------\");\n\n    // 测试ofNullable方法\n    Optional<User> optional14 = Optional.ofNullable(User.builder().username(\"zhangsan\").build());\n    System.out.println(\"测试ofNullable方法：\");\n    System.out.println(optional14);\n    System.out.println(\"-----------------------\");\n\n    // 测试orElse方法\n    Optional<User> optional15 = Optional.empty();\n    System.out.println(\"测试orElse方法：\");\n    System.out.println(optional15.orElse(User.builder().username(\"zhangsan\").build()));\n    System.out.println(\"-----------------------\");\n\n    // 测试orElseGet方法\n    Optional<User> optional16 = Optional.empty();\n    System.out.println(\"测试orElse方法：\");\n    System.out.println(optional16.orElseGet(new Supplier<User>() {\n        @Override\n        public User get() {\n            return User.builder().username(\"zhangsan\").build();\n        }\n    }));\n    System.out.println(\"-----------------------\");\n\n    // 测试toString方法\n    System.out.println(\"测试toString方法：\");\n    Optional<User> optional17 = Optional.of(User.builder().username(\"zhangsan\").build());\n    String s = optional17.toString();\n    System.out.println(s);\n    System.out.println(\"-----------------------\");\n}\n```\n\n控制台输出：\n\n```Plain\n测试empty方法：\nOptional.empty\n-----------------------\n测试equals方法：\nfalse\n-----------------------\n测试filter方法：\nOptional[User(age=null, height=null, weight=null, username=zhangsan)]\n-----------------------\n测试flatMap方法：\nOptional[User(age=null, height=null, weight=null, username=zhangsan)]\n-----------------------\n测试get方法：\nUser(age=null, height=null, weight=null, username=zhangsan)\n-----------------------\n测试hashCode方法：\n-1431681035\n-----------------------\n测试ifPresent方法：\nUser(age=null, height=null, weight=null, username=zhangsan)\n-----------------------\n测试isPresent方法：\ntrue\n-----------------------\n测试map方法：\nOptional[User(age=null, height=null, weight=null, username=zhangsan)]\n-----------------------\n测试of方法：\nOptional[User(age=null, height=null, weight=null, username=zhangsan)]\n-----------------------\n测试ofNullable方法：\nOptional[User(age=null, height=null, weight=null, username=zhangsan)]\n-----------------------\n测试orElse方法：\nUser(age=null, height=null, weight=null, username=zhangsan)\n-----------------------\n测试orElse方法：\nUser(age=null, height=null, weight=null, username=zhangsan)\n-----------------------\n测试toString方法：\nOptional[User(age=null, height=null, weight=null, username=zhangsan)]\n-----------------------\n```\n\n## OptionalInt\n\nOptionalInt可能含有也可能不包含int值的容器对象。 如果值存在，  isPresent()将返回true并且getAsInt()将返回值。\n\n提供依赖于包含值的存在或不存在的附加方法，例如orElse()，如果值不存在则返回默认值；ifPresent()，如果值存在则执行代码块。\n\nOptionalInt提供以下方法：\n\n| **方法类型及返回值**      | **方法名称**                               | **描述**                                                     |\n| ------------------------- | ------------------------------------------ | ------------------------------------------------------------ |\n| static OptionalInt        | empty()                                    | 返回一个空的 OptionalInt实例。                               |\n| boolean                   | equals(Object obj)                         | 指示某个其他对象是否等于此OptionalInt。                      |\n| int                       | getAsInt()                                 | 如果 OptionalInt中存在值，则返回值，否则抛出 NoSuchElementException 。 |\n| int                       | hashCode()                                 | 返回当前值的哈希码值（如果有的话），如果没有值，则返回0（零）。 |\n| void                      | ifPresent(IntConsumer consumer)            | 让指定的消费者接受该值，如果一个值存在，否则什么也不做。     |\n| boolean                   | isPresent()                                | 如果有值存在，返回 true ，否则 false 。                      |\n| static OptionalInt        | of(int value)                              | 返回一个 OptionalInt具有指定值存在。                         |\n| int                       | orElse(int other)                          | 返回值如果存在，否则返回 other 。                            |\n| int                       | orElseGet(IntSupplier other)               | 返回值（如果存在），否则调用 other并返回该调用的结果。       |\n| <X extends Throwable> int | orElseThrow(Supplier<X> exceptionSupplier) | 返回包含的值（如果存在），否则抛出由提供的供应商创建的异常。 |\n| String                    | toString()                                 | 返回对象的字符串表示形式。                                   |\n\n测试方法：\n\n```Java\n@SneakyThrows\nprivate static void test2(){\n    // 测试empty方法\n    System.out.println(\"测试empty方法：\");\n    OptionalInt empty = OptionalInt.empty();\n    System.out.println(empty);\n    System.out.println(\"-----------------------\");\n\n    // 测试equals方法\n    System.out.println(\"测试equals方法：\");\n    OptionalInt optionalInt = OptionalInt.of(3);\n    OptionalInt optionalInt1 = OptionalInt.of(4);\n    System.out.println(optionalInt.equals(optionalInt1));\n    System.out.println(\"-----------------------\");\n\n    // 测试getAsInt方法\n    System.out.println(\"测试getAsInt方法：\");\n    OptionalInt optionalInt2 = OptionalInt.of(1);\n    System.out.println(optionalInt2.getAsInt());\n    System.out.println(\"-----------------------\");\n\n    // 测试hashCode方法\n    System.out.println(\"测试hashCode方法：\");\n    OptionalInt optionalInt3 = OptionalInt.of(1);\n    System.out.println(optionalInt3.hashCode());\n    System.out.println(\"-----------------------\");\n\n    // 测试ifPresent方法\n    System.out.println(\"测试ifPresent方法：\");\n    OptionalInt optionalInt4 = OptionalInt.of(1);\n    optionalInt4.ifPresent(new IntConsumer() {\n        @Override\n        public void accept(int value) {\n            System.out.println(\"打印值：\" + value);\n        }\n    });\n    System.out.println(\"-----------------------\");\n\n    // 测试of方法\n    System.out.println(\"测试of方法：\");\n    OptionalInt optionalInt5 = OptionalInt.of(1);\n    System.out.println(optionalInt5);\n    System.out.println(\"-----------------------\");\n\n    // 测试orElse方法\n    System.out.println(\"测试orElse方法：\");\n    OptionalInt optionalInt6 = OptionalInt.of(1);\n    System.out.println(optionalInt6.orElse(-1));\n    System.out.println(\"-----------------------\");\n\n    // 测试orElseGet方法\n    System.out.println(\"测试orElseGet方法：\");\n    OptionalInt optionalInt7 = OptionalInt.of(1);\n    System.out.println(optionalInt7.orElseGet(new IntSupplier() {\n        @Override\n        public int getAsInt() {\n            return -1;\n        }\n    }));\n    System.out.println(\"-----------------------\");\n\n    // 测试orElseGet方法\n    System.out.println(\"测试orElseGet方法：\");\n    OptionalInt optionalInt8 = OptionalInt.of(1);\n    optionalInt8.orElseThrow(new Supplier<Throwable>() {\n        @Override\n        public Throwable get() {\n            return new Throwable(\"没有值\");\n        }\n    });\n    System.out.println(\"-----------------------\");\n\n    // 测试toString方法\n    System.out.println(\"测试toString方法：\");\n    OptionalInt optionalInt9 = OptionalInt.of(1);\n    String s = optionalInt9.toString();\n    System.out.println(s);\n    System.out.println(\"-----------------------\");\n}\n```\n\n控制台输出：\n\n```Plain\n测试empty方法：\nOptionalInt.empty\n-----------------------\n测试equals方法：\nfalse\n-----------------------\n测试getAsInt方法：\n1\n-----------------------\n测试hashCode方法：\n1\n-----------------------\n测试ifPresent方法：\n打印值：1\n-----------------------\n测试of方法：\nOptionalInt[1]\n-----------------------\n测试orElse方法：\n1\n-----------------------\n测试orElseGet方法：\n1\n-----------------------\n测试orElseGet方法：\n-----------------------\n测试toString方法：\nOptionalInt[1]\n-----------------------\n```\n\n## OptionalLong\n\nOptionalLong可能含有也可能不包含int值的容器对象。 如果值存在，  isPresent()将返回true并且getAsLong()将返回值。\n\n提供依赖于包含值的存在或不存在的附加方法，例如orElse()，如果值不存在则返回默认值；ifPresent()，如果值存在则执行代码块。\n\nOptionalLong提供以下方法：\n\n| **方法类型及返回值**       | **方法名称**                               | **描述**                                                     |\n| -------------------------- | ------------------------------------------ | ------------------------------------------------------------ |\n| static OptionalLong        | empty()                                    | 返回一个空的OptionalLong实例。                               |\n| boolean                    | equals(Object obj)                         | 指示一些其他对象是否等于此OptionalLong。                     |\n| long                       | getAsLong()                                | 如果 OptionalLong中存在值，则返回值，否则抛出 NoSuchElementException 。 |\n| int                        | hashCode()                                 | 返回当前值的哈希码值（如果有的话），如果没有值，则返回0（零）。 |\n| void                       | ifPresent(LongConsumer consumer)           | 让指定的消费者接受该值，如果一个值存在，否则什么也不做。     |\n| boolean                    | isPresent()                                | 如果存在值，则返回true ，否则为 false 。                     |\n| static OptionalLong        | of(long value)                             | 返回一个OptionalLong具有指定值存在。                         |\n| long                       | orElse(long other)                         | 返回值如果存在，否则返回other 。                             |\n| long                       | orElseGet(LongSupplier other)              | 返回值（如果存在），否则调用other并返回该调用的结果。        |\n| <X extends Throwable> long | orElseThrow(Supplier<X> exceptionSupplier) | 返回包含的值（如果存在），否则抛出由提供的供应商创建的异常。 |\n| String                     | toString()                                 | 返回对象的字符串表示形式。                                   |\n\n测试方法：\n\n```Java\n@SneakyThrows\nprivate static void test3(){\n    // 测试empty方法\n    System.out.println(\"测试empty方法：\");\n    OptionalLong empty = OptionalLong.empty();\n    System.out.println(empty);\n    System.out.println(\"-----------------------\");\n\n    // 测试equals方法\n    System.out.println(\"测试equals方法：\");\n    OptionalLong optionalInt = OptionalLong.of(3);\n    OptionalLong optionalInt1 = OptionalLong.of(4);\n    System.out.println(optionalInt.equals(optionalInt1));\n    System.out.println(\"-----------------------\");\n\n    // 测试getAsLong方法\n    System.out.println(\"测试getAsLong方法：\");\n    OptionalLong optionalInt2 = OptionalLong.of(1);\n    System.out.println(optionalInt2.getAsLong());\n    System.out.println(\"-----------------------\");\n\n    // 测试hashCode方法\n    System.out.println(\"测试hashCode方法：\");\n    OptionalLong optionalInt3 = OptionalLong.of(1);\n    System.out.println(optionalInt3.hashCode());\n    System.out.println(\"-----------------------\");\n\n    // 测试ifPresent方法\n    System.out.println(\"测试ifPresent方法：\");\n    OptionalLong optionalInt4 = OptionalLong.of(1);\n    optionalInt4.ifPresent(new LongConsumer() {\n        @Override\n        public void accept(long value) {\n            System.out.println(\"打印值：\" + value);\n        }\n    });\n    System.out.println(\"-----------------------\");\n\n    // 测试of方法\n    System.out.println(\"测试of方法：\");\n    OptionalLong optionalInt5 = OptionalLong.of(1);\n    System.out.println(optionalInt5);\n    System.out.println(\"-----------------------\");\n\n    // 测试orElse方法\n    System.out.println(\"测试orElse方法：\");\n    OptionalLong optionalInt6 = OptionalLong.of(1);\n    System.out.println(optionalInt6.orElse(-1));\n    System.out.println(\"-----------------------\");\n\n    // 测试orElseGet方法\n    System.out.println(\"测试orElseGet方法：\");\n    OptionalLong optionalInt7 = OptionalLong.of(1);\n    System.out.println(optionalInt7.orElseGet(new LongSupplier() {\n        @Override\n        public long getAsLong() {\n            return -1;\n        }\n    }));\n    System.out.println(\"-----------------------\");\n\n    // 测试orElseGet方法\n    System.out.println(\"测试orElseGet方法：\");\n    OptionalLong optionalInt8 = OptionalLong.of(1);\n    optionalInt8.orElseThrow(new Supplier<Throwable>() {\n        @Override\n        public Throwable get() {\n            return new Throwable(\"没有值\");\n        }\n    });\n    System.out.println(\"-----------------------\");\n\n    // 测试toString方法\n    System.out.println(\"测试toString方法：\");\n    OptionalLong optionalInt9 = OptionalLong.of(1);\n    String s = optionalInt9.toString();\n    System.out.println(s);\n    System.out.println(\"-----------------------\");\n}\n```\n\n控制台输出：\n\n```Plain\n测试empty方法：\nOptionalLong.empty\n-----------------------\n测试equals方法：\nfalse\n-----------------------\n测试getAsLong方法：\n1\n-----------------------\n测试hashCode方法：\n1\n-----------------------\n测试ifPresent方法：\n打印值：1\n-----------------------\n测试of方法：\nOptionalLong[1]\n-----------------------\n测试orElse方法：\n1\n-----------------------\n测试orElseGet方法：\n1\n-----------------------\n测试orElseGet方法：\n-----------------------\n测试toString方法：\nOptionalLong[1]\n-----------------------\n```\n\n## OptionalDouble\n\nOptionalDouble可能含有也可能不包含int值的容器对象。 如果值存在，  isPresent()将返回true并且getAsDouble()将返回值。\n\n提供依赖于包含值的存在或不存在的附加方法，例如orElse()，如果值不存在则返回默认值；ifPresent()，如果值存在则执行代码块。\n\nOptionalDouble提供以下方法：\n\n| **方法类型及返回值**         | **方法名称**                               | **描述**                                                     |\n| ---------------------------- | ------------------------------------------ | ------------------------------------------------------------ |\n| static OptionalDouble        | empty()                                    | 返回一个空的 OptionalDouble实例。                            |\n| boolean                      | equals(Object obj)                         | 指示某个其他对象是否等于此OptionalDouble。                   |\n| double                       | getAsDouble()                              | 如果 OptionalDouble中有值，则返回值，否则抛出 NoSuchElementException 。 |\n| int                          | hashCode()                                 | 返回当前值的哈希码值（如果有的话），如果没有值，则返回0（零）。 |\n| void                         | ifPresent(DoubleConsumer consumer)         | 让指定的消费者接受该值，如果一个值存在，否则什么也不做。     |\n| boolean                      | isPresent()                                | 返回 true如果存在值，否则为 false 。                         |\n| static OptionalDouble        | of(double value)                           | 返回一个 OptionalDouble具有指定值存在。                      |\n| double                       | orElse(double other)                       | 返回值如果存在，否则返回 other 。                            |\n| double                       | orElseGet(DoubleSupplier other)            | 返回值（如果存在），否则调用 other并返回该调用的结果。       |\n| <X extends Throwable> double | orElseThrow(Supplier<X> exceptionSupplier) | 返回包含的值（如果存在），否则抛出由提供的供应商创建的异常。 |\n| String                       | toString()                                 | 返回对象的字符串表示形式。                                   |\n\n测试方法：\n\n```Java\n@SneakyThrows\nprivate static void test4(){\n    // 测试empty方法\n    System.out.println(\"测试empty方法：\");\n    OptionalDouble empty = OptionalDouble.empty();\n    System.out.println(empty);\n    System.out.println(\"-----------------------\");\n\n    // 测试equals方法\n    System.out.println(\"测试equals方法：\");\n    OptionalDouble optionalInt = OptionalDouble.of(3);\n    OptionalDouble optionalInt1 = OptionalDouble.of(4);\n    System.out.println(optionalInt.equals(optionalInt1));\n    System.out.println(\"-----------------------\");\n\n    // 测试getAsDouble方法\n    System.out.println(\"测试getAsDouble方法：\");\n    OptionalDouble optionalInt2 = OptionalDouble.of(1);\n    System.out.println(optionalInt2.getAsDouble());\n    System.out.println(\"-----------------------\");\n\n    // 测试hashCode方法\n    System.out.println(\"测试hashCode方法：\");\n    OptionalDouble optionalInt3 = OptionalDouble.of(1);\n    System.out.println(optionalInt3.hashCode());\n    System.out.println(\"-----------------------\");\n\n    // 测试ifPresent方法\n    System.out.println(\"测试ifPresent方法：\");\n    OptionalDouble optionalInt4 = OptionalDouble.of(1);\n    optionalInt4.ifPresent(new DoubleConsumer() {\n        @Override\n        public void accept(double value) {\n            System.out.println(\"打印值：\" + value);\n        }\n    });\n    System.out.println(\"-----------------------\");\n\n    // 测试of方法\n    System.out.println(\"测试of方法：\");\n    OptionalDouble optionalInt5 = OptionalDouble.of(1);\n    System.out.println(optionalInt5);\n    System.out.println(\"-----------------------\");\n\n    // 测试orElse方法\n    System.out.println(\"测试orElse方法：\");\n    OptionalDouble optionalInt6 = OptionalDouble.of(1);\n    System.out.println(optionalInt6.orElse(-1));\n    System.out.println(\"-----------------------\");\n\n    // 测试orElseGet方法\n    System.out.println(\"测试orElseGet方法：\");\n    OptionalDouble optionalInt7 = OptionalDouble.of(1);\n    System.out.println(optionalInt7.orElseGet(new DoubleSupplier() {\n        @Override\n        public double getAsDouble() {\n            return -1;\n        }\n    }));\n    System.out.println(\"-----------------------\");\n\n    // 测试orElseGet方法\n    System.out.println(\"测试orElseGet方法：\");\n    OptionalDouble optionalInt8 = OptionalDouble.of(1);\n    optionalInt8.orElseThrow(new Supplier<Throwable>() {\n        @Override\n        public Throwable get() {\n            return new Throwable(\"没有值\");\n        }\n    });\n    System.out.println(\"-----------------------\");\n\n    // 测试toString方法\n    System.out.println(\"测试toString方法：\");\n    OptionalDouble optionalInt9 = OptionalDouble.of(1);\n    String s = optionalInt9.toString();\n    System.out.println(s);\n    System.out.println(\"-----------------------\");\n}\n```\n\n控制台输出：\n\n```Plain\n测试empty方法：\nOptionalDouble.empty\n-----------------------\n测试equals方法：\nfalse\n-----------------------\n测试getAsDouble方法：\n1.0\n-----------------------\n测试hashCode方法：\n1072693248\n-----------------------\n测试ifPresent方法：\n打印值：1.0\n-----------------------\n测试of方法：\nOptionalDouble[1.0]\n-----------------------\n测试orElse方法：\n1.0\n-----------------------\n测试orElseGet方法：\n1.0\n-----------------------\n测试orElseGet方法：\n-----------------------\n测试toString方法：\nOptionalDouble[1.0]\n-----------------------\n```\n","tags":["java基础"],"categories":["java"]},{"title":"一文详解Stream流","url":"/2023/05/02/一文详解Stream流.html","content":"\n# 简介\n\nStream支持元素流功能性操作的类，例如集合上的`map-reduce`转换。 例如：\n\n```Java\nint sum = widgets.stream().filter(b -> b.getColor() == RED).mapToInt(b -> b.getWeight()).sum();  \n```\n\n这里我们使用`widgets Collection<Widget>`作为流的源，然后在流上执行filter-map-reduce以获得红色小部件的权重之和。（求和是一个的例子reduction操作）。\n\n这个包中引入的关键抽象是流。流与集合有以下几种不同：\n\n- 没有存储。 流不是存储元素的数据结构;  相反，它通过计算操作的流水线传送诸如数据结构，数组，生成器功能或I/O通道的源的元件。\n- 功能性质。 流上的操作产生结果，但不会修改其来源。  例如，过滤从Stream获得的Stream会生成旧的Stream不需要的元素，而不是从源集合中删除元素。\n- 懒惰执行。 许多流操作（如过滤，映射或重复删除）可以懒惰地实现，从而暴露优化的机会。  例如，\"找到具有三个连续元音的第一个String\"，不需要检查所有的输入字符串。  流操作分为中间（Stream生产）操作和终端（价值或副作用生成）操作。  中间操作总是懒惰执行的。\n- 可能无限。 虽然集合的大小有限，但流不需要。  诸如limit(n)或findFirst()之类的方法可以允许无限流上的计算在有限的时间内完成。\n- 消耗性质。流的元素只能在流的一生中访问一次。 像Iterator一样 ，必须生成一个新流来重新访问源的相同元素。\n\n流可以通过多种方式获得。 一些例子包括：\n\n- 通过Collection的stream()或parallelStream()方法；\n- 对于数组类可以通过Arrays.stream(Object[])获取流；\n- 通过高级流类的静态方法，如Stream.of(Object[])、IntStream.range(int,  int)、Stream.iterate(Object,  UnaryOperator); ；\n- 文件的行可以从BufferedReader.lines()获取;\n- 文件路径的流可以从Files中的方法获得，如newDirectoryStream()、newInputStream()、newOutputStream()；\n- 随机数流可以从Random.ints()获得;\n- 许多其它的数据流的方法的轴承在JDK中，包括BitSet.stream()、Pattern.splitAsStream(java.lang.CharSequence)、JarFile.stream()；\n\n流操作分为**中间操作和终端操作**，并且组合以形成pipelines。pipelines由源（例如Collection，数组，发生器功能或I/O通道）组成；其次是零个或多个中间操作，如Stream.filter或Stream.map；以及诸如Stream.forEach或Stream.reduce的终端操作。\n\n中间操作返回一个新的流。 他们总是**懒惰**执行诸如filter()操作实际上不执行任何过滤，而是创建一个新的流，当被遍历时，它包含与给定谓词匹配的初始流的元素。在管道的终端操作被执行之前，管道源的遍历不会开始。\n\n诸如Stream.forEach或IntStream.sum终端操作可以遍历流以产生结果或副作用。在执行终端操作之后，流管道被认为被消耗，并且不能再使用；如果再次遍历相同的数据源，则必须返回到数据源以获取新的流。 在几乎所有情况下，终端操作都是迫切的，在返回之前完成对数据源的遍历和处理。只有终端操作iterator()和spliterator()不是；在现有操作不足以满足任务的情况下，这些提供为”逃生舱“，以允许任意客户端控制的管道遍历。\n\n处理流**懒惰实现有着**显著的效率提升; 在诸如上述的filter-map-reduce的流水线中，过滤、映射和求和可以融合到数据的单次传递中，具有最小的中间状态。懒惰也允许避免在没有必要时检查所有数据；对于诸如“找到长度超过1000个字符的第一个字符串”等操作，只需检查足够的字符串即可找到具有所需特性的字符串，而无需检查源中可用的所有字符串。（当输入流是无限大而不仅仅是大的时候，这种行为变得更加重要）\n\n中间操作进一步分为无状态操作和有状态操作。无状态操作（例如filter和map）在处理新元素时不保留先前看到的元素的状态——每个元素可以独立于其他元素的操作进行处理。  诸如distinct和sorted有状态操作可以在处理新元件时结合先前看到的元素的状态。\n\n在产生结果之前，有状态操作可能需要处理整个输入。例如，在流已经看到流的所有元素之前，不能产生排序流的任何结果。**因此，在并行计算下，包含有状态中间操作的一些流水线可能需要对数据进行多遍，或者可能需要缓冲重要的数据。  包含无状态中间操作的流水线可以在一次通过中处理，无论是顺序还是并行，具有最少的数据缓冲。**\n\n此外，一些操作被认为是**短路操作**。如果在无限输入的情况下，中间运算可能会产生有限的流，这种情况就叫做短路。如果当无限输入呈现时，终端操作可能会在有限时间内终止。在流水线中进行短路操作是处理无限流在有限时间内正常终止的必要但不足够的条件。\n\n# 特性\n\n## 并行性\n\n具有显式for循环的处理元素方式是串行的。流通过将计算重构为聚合操作的管道来促进并行执行，而不是作为每个单独元素的必要操作。**所有流操作可以串行或并行执行。**JDK中的流实现创建串行流，除非显式请求并行。 例如，  Collection具有方法Collection.stream()和Collection.parallelStream()，其分别产生顺序和并行流；虽然IntStream.range(int,  int)等其他流承载方法产生顺序流，但是可以通过调用它们的BaseStream.parallel()方法来有效地并行化这些流。要并行执行先前的“小部件权重总和”查询，我们可以这样做：\n\n```Java\nint sumOfWeights = widgets.parallelStream().filter(b -> b.getColor() == RED) .mapToInt(b -> b.getWeight()).sum();  \n```\n\n此示例的串行和并行版本之间的唯一区别是创建初始流，使用parallelStream()而不是stream()。当终端操作被启动时，根据被调用的流的方向，顺序或并行地执行流管道。流是否以串行或并行方式执行可以使用isParallel()方法确定，并且可以使用BaseStream.sequential()和BaseStream.parallel()操作修改流的方向。当终端操作被启动时，根据其被调用的流的模式，顺序地或并行地执行pipelines。\n\n除了确定为非确定性的操作，如findAny()，流是顺序还是并行执行，不应该改变计算结果。\n\n大多数流操作接受描述用户指定行为的参数，这些行为通常是lambda表达式。为了保持正确的行为，这些行为参数必须是非干扰的，在大多数情况下必须是无状态的。这样的参数总是functional interface的例子 ，如Function，并且通常是lambda表达式或方法引用。\n\n## 非干扰\n\nStreams能够对各种数据源执行可能并行的聚合操作，包括甚至非线程安全的集合，如ArrayList。只有当我们能够在流管道的执行过程中防止对数据源的干扰时，这才有可能。除了逃生舱操作iterator()和spliterator()，当调用终端操作时开始执行，终端操作完成时结束。对于大多数数据源，防止干扰意味着确保在pipelines的执行期间完全**不修改**数据源。其中值得注意的例外是其源是并发集合的流，它们专门用于处理并发修改。并发流源是指Spliterator报告CONCURRENT特征的流源。。\n\n因此，源可能不是并发的流管道中的行为参数永远不应该修改流的数据源。如果行为参数修改或导致修改流的数据源，则它会干扰非并发数据源。不干涉的必要性适用于所有管道，而不仅仅是平行管道。除非流源是并发的，否则在流管道的执行过程中修改流的数据源可能会导致异常、错误回答或不一致行为。对于性能良好的流源，可以在终端操作开始之前修改源，并且这些修改将反映在所覆盖的元素中。例如，考虑以下代码：\n\n```Java\nList<String> l = new ArrayList(Arrays.asList(\"one\", \"two\"));\nStream<String> sl = l.stream(); \nl.add(\"three\"); \nString s = sl.collect(joining(\" \"));  \n```\n\n首先创建一个由两个字符串组成的列表：“one”、“two”。 然后从该列表创建流。接下来，通过添加第三个字符串“three”修改列表。最后，流的元素被收集并连接在一起。由于列表在终端collect操作开始之前被修改，所以结果将是一个“one two three”的字符串。从JDK集合返回的所有流和大多数其他JDK类都以这种方式表现良好；对于其他库生成的流，请参阅Low-level stream construction，了解构建良好流的要求。\n\n## 有状态\n\n如果流操作的行为参数是**有状态**的，流管道结果可能不确定或不正确。有状态的lambda（或实现适当的功能接口的其他对象）是结果取决于在流管道的执行期间可能改变的任何状态。有状态的lambda的一个例子是map()的`map()` ：\n\n```Java\nSet<Integer> seen = Collections.synchronizedSet(new HashSet<>());\nstream.parallel().map(e -> {\n    if (seen.add(e)) {\n        return 0;\n    } \n    return e;\n});\n```\n\n这里，如果并行执行映射操作，由于线程调度的差异，相同输入的结果可能因运行而异，而使用无状态的lambda表达式，结果总是相同的。\n\n还要注意，尝试从行为参数访问可变状态会带来安全和性能方面的不良选择；如果不同步对该状态的访问，则会有数据竞争，因此代码已损坏，但是如果同步访问该状态，则冒有争议的风险有可能破坏您正在寻求的并行性。最好的方法是避免有状态的行为参数完全流式传输；通常有一种重组流管道以避免状态的方法。\n\n## 副作用\n\n一般而言，流行为的行为参数的副作用是不鼓励的，因为它们经常会导致无意识地违反无状态要求以及其他线程安全危害。\n\n如果行为参数确实有副作用，除非明确说明，有没有保证，而在visibility的那些副作用给其他线程，也没有任何保证相同的流管道内的“相同”的元素在不同的操作在同一个线程中执行。此外，这些效果的排序可能是令人惊讶的。 即使当管道被限制以产生与流源的遇到顺序一致的结果（例如，`IntStream.range(0,5).parallel().map(x ->  x*2).toArray()`必须产生`[0, 2, 4, 6, 8]`）时，不保证将映射器功能应用于各个元件的顺序，或者在什么线程中为给定元素执行任何行为参数。\n\n许多可能诱惑使用副作用的计算可以更安全有效地表达而无副作用，例如使用reduction代替可变累加器。但是，对于调试目的使用println()等副作用通常是无害的。少量流操作，如forEach()和peek() ，只能通过副作用进行操作；这些应谨慎使用。\n\n作为如何将不正确地使用副作用的流管道转换为不适用的流管道的示例，以下代码搜索与给定正则表达式匹配的字符串，并将匹配放在列表中。\n\n```Java\nArrayList<String> results = new ArrayList<>();\nstream.filter(s -> pattern.matcher(s).matches()).forEach(s -> results.add(s)); // Unnecessary use of side-effects!  \n```\n\n此代码不必要地使用副作用。如果并行执行，ArrayList的非线程安全性将导致不正确的结果，并且添加所需的同步将导致争用，从而破坏并行性的好处。此外，这里使用副作用是完全不必要的；forEach()可以简单地替换为更安全、更高效、更适合并行化的collect操作：\n\n```Java\nList<String> results = stream.filter(s -> pattern.matcher(s).matches()).collect(Collectors.toList()); // No side-effects!  \n```\n\n## 有序性\n\n流可能有也可能没有定义的**遇到顺序** 。流是否有遇到顺序取决于源和中间操作。某些流源（如List或数组）本质上是有序的，而其他数据源（如HashSet ）不是。一些中间操作（例如sorted()）可以在其他无序流上施加遇到命令，而其他中间操作可以使有序流无序，例如BaseStream.unordered()。此外，一些终端操作可能会忽略遇到的顺序，如forEach() 。\n\n如果一个流被操作，大多数操作被限制为在遇到的顺序中对元素进行操作; 如果流的源是List含有`[1, 2, 3]` ，然后执行的结果`map(x ->  x*2)`必须是`[2, 4, 6]`。然而，如果源没有定义遇到顺序，则值`[2,  4, 6]`任何`[2, 4, 6]`将是有效结果。\n\n**对于顺序流，遇到顺序的存在或不存在不影响性能，仅影响确定性。**如果流被排序，在相同的源上重复执行相同的流管线将产生相同的结果;  如果没有顺序，重复执行可能会产生不同的结果。\n\n**对于并行流，放宽排序约束有时可以实现更有效的执行。**某些聚合操作，例如过滤重复（distinct()）或组合减少（Collectors.groupingBy()）可以更有效地实现，如果元素的排序不相关。类似地，本质上与遇到顺序相关的操作，如limit()可能需要缓冲以确保正确排序，从而破坏并行性的好处。在流具有相遇顺序，但用户并不特别关心该相遇顺序的情况下，使用unordered()方法显式地取消流的排序可以提高一些有状态或终端操作的并行性能。然而，大多数pipelines，如上面的“块的权重之和”示例，即使在排序约束下，仍然可以有效地并行化。\n\n## 归约操作\n\n归约操作（也称为折叠）采用一系列输入元素，并通过重复应用组合运算将它们组合成一个汇总结果，例如找到一组数字的和或最大值，或将元素累积到列表中。流类具有多种形式的通用归约运算，称为reduce()和collect()，以及多种专门的归约形式，如sum()、max()或count()。\n\n当然，这样的操作可以容易使用简单的顺序循环实现，如：\n\n```Java\nint sum = 0; \nfor (int x : numbers) { \n    sum += x;\n}  \n```\n\n然而，有一个很好的理由使用归约操作超过如上所述的突变积累。不仅减少“更抽象”——它在整个流上运行，而不是单个元素，但正确构造的归约操作本质上是可并行的，只要用于处理元素的功能是associative和stateless。例如，给定一个我们要找到的数字的数据流，我们可以写：\n\n```Java\nint sum = numbers.stream().reduce(0, (x,y) -> x+y);  \n```\n\n要么：\n\n```Java\nint sum = numbers.stream().reduce(0, Integer::sum);  \n```\n\n这些还原操作可以安全地并行运行，几乎没有修改：\n\n```Java\nint sum = numbers.parallelStream().reduce(0, Integer::sum);  \n```\n\n归约可以很好地并行化，因为实现可以并行地对数据子集进行操作，然后将中间结果组合起来以获得最终的正确答案。（即使该语言有一个“每个并行”的构造，可变累积方法仍然需要开发人员为共享的累积变量sum提供线程安全的更新，然后所需的同步可能会消除并行带来的任何性能增益。）使用reduce()来消除并行化reduce操作的所有负担，并且该库可以提供高效的并行实现，而不需要额外的同步。\n\n前面显示的“widgets”示例显示了如何将reduce与其他操作结合来替代大量操作的循环。如果widgets是Widget对象的集合，它们具有getWeight方法，我们可以找到最重的小部件：\n\n```Java\nOptionalInt heaviest = widgets.parallelStream().mapToInt(Widget::getWeight).max();  \n```\n\n在其更一般的形式中，reduce上类型的元素的操作<T>得到类型的结果```<U>```需要三个参数：\n\n```Java\n<U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner);  \n```\n\n这里，identity既是减少的初始种子值，也是没有输入元素的默认结果。accumulator函数获得部分结果和下一个元素，并产生新的部分结果。combiner组合两个部分结果以产生新的部分结果。（组合器在并行归约中是必需的，其中输入被分割，为每个分区计算的部分累加，然后组合部分结果以产生最终结果。）\n\n更正式地， identity值必须是组合器功能的标识。这意味着，对于所有u，combiner.apply(identity,  u)等于u 。此外，combiner功能必须是associative，并必须兼容accumulator功能：对所有u和t，combiner.apply(u, accumulator.apply(identity,  t))与accumulator.apply(u, t)的equals()结果必须为true。\n\n三参数形式是双参数形式的泛化，将映射步骤纳入积累步骤。我们可以使用更一般的形式重写简单的权重示例，如下所示：\n\n```Java\nint sumOfWeights = widgets.stream().reduce(0, (sum, b) -> sum + b.getWeight()), Integer::sum);\n```\n\n显式的`map-reduce`形式更具有可读性，因此通常应该是首选。为可以通过将映射和归约组合成单个函数来优化大量工作的情况提供了通用形式。。\n\n## 可变归约\n\n**可变归约操作**将输入元素累加到可变结果容器中，例如Collection或StringBuilder，因为它处理流中的元素。\n\n如果我们想采取一串字符串并将它们连接成一个长的字符串，我们可以通过普通的reduction实现这一点：\n\n```Java\nString concatenated = strings.reduce(\"\", String::concat)  \n```\n\n我们会得到所需的结果，甚至可以并行工作。但是，我们可能不会对示例感到高兴！这样的实现将执行大量的字符串复制，并且运行时间将是字符数为O(n^2) 。更有效的方法是将结果累积到一个StringBuilder，它是一个用于累积字符串的可变容器。我们可以使用相同的技术并行化可变减少，就像我们用普通的减少一样。\n\n可变归约操作称为collect() ，因为它将所需结果汇总到结果容器（如Collection。一个collect操作需要三个功能：供应商功能构造结果容器的新实例，将输入元素合并到结果容器中的累加器函数，以及将一个结果容器的内容合并到另一个中的组合函数。 这种形式与普通缩减的一般形式非常相似：\n\n```Java\n<R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner);  \n```\n\n与reduce()以抽象的方式表达collect的好处是可以直接适应并行化：只要积累和组合函数满足适当的要求，我们可以并行累积部分结果，然后将它们组合起来。例如，要将流中的元素的String表示形式收集到一个ArrayList，我们可以为每个形式写出明显的顺序：\n\n```Java\nArrayList<String> strings = new ArrayList<>();\nfor (T element : stream) { \n    strings.add(element.toString()); \n}  \n```\n\n或者我们可以使用可并行化的收集表单：\n\n```Java\nArrayList<String> strings = stream.collect(() -> new ArrayList<>(), (c, e) -> c.add(e.toString()), (c1, c2) -> c1.addAll(c2));  \n```\n\n或者将绘图操作拉出累加器函数，我们可以更简洁地表达：\n\n```Java\nList<String> strings = stream.map(Object::toString).collect(ArrayList::new, ArrayList::add, ArrayList::addAll);  \n```\n\n在这里，我们的供应商只是ArrayList constructor，累加器将一个字符串元素添加到一个ArrayList，组合器只需使用addAll将字符串从一个容器复制到另一个容器中。\n\ncollect- supplier、accumulator和combiner的三个方面紧密耦合。 我们可以使用Collector的抽象来捕获所有三个方面。 将字符串收集到List中的上述示例可以使用标准Collector：\n\n```Java\nList<String> strings = stream.map(Object::toString).collect(Collectors.toList());  \n```\n\n将可变减少包装到收集器中有另一个优点：可组合性。 `Collectors`类包含了一些收集器的预定义工厂，包括将一个收集器转换成另一个收集器的组合器。例如，假设我们有一个收集器来计算员工流量的总和，如下所示：\n\n```Java\nCollector<Employee, ?, Integer> summingSalaries = Collectors.summingInt(Employee::getSalary);  \n```\n\n（该? 。对于第二类参数仅仅表明我们不关心这个收集器所使用的中间表示）如果我们想创造一个收藏家制表工资由部门的总和，我们可以重用summingSalaries使用groupingBy：\n\n```Java\nMap<Department, Integer> salariesByDept = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment, summingSalaries));  \n```\n\n与正常的归约操作一样，collect()操作只能在符合条件的情况下进行并行化。对于任何部分累积的结果，将其与空结果容器组合必须产生等效结果。也就是说，部分累加结果p即任何系列累加器和组合器的调用的结果，p必须等同于combiner.apply(p, supplier.get())。\n\n此外，然而，计算是分裂的，它必须产生等效的结果。对于任何输入元素t1和t2 ，下面的计算中的结果r1和r2必须是等效的：\n\n```Java\nA a1 = supplier.get(); \naccumulator.accept(a1, t1); \naccumulator.accept(a1, t2); \nR r1 = finisher.apply(a1); \n// result without splitting \nA a2 = supplier.get(); \naccumulator.accept(a2, t1); \nA a3 = supplier.get(); \naccumulator.accept(a3, t2); \nR r2 = finisher.apply(combiner.apply(a2, a3)); \n// result with splitting  \n```\n\n这里，等效通常意味着根据Object.equals(Object) 。 但是在某些情况下，可以放松等价以解决顺序上的差异。\n\n对于一些复杂的减少操作，例如一个collect() ，其产生Map，如：\n\n```Java\nMap<Buyer, List<Transaction>> salesByBuyer = txns.parallelStream().collect(Collectors.groupingBy(Transaction::getBuyer));  \n```\n\n实际上并行执行操作可能会适得其反。这是因为组合步骤（将一个Map合并成另一个按键）对于一些Map实现可能是昂贵的。\n\n然而，假设在此减少中使用的结果容器是可同时修改的集合，例如ConcurrentHashMap。在这种情况下，累加器的并行调用实际上可以将它们的结果同时存入相同的共享结果容器中，从而无需组合器来合并不同的结果容器。 这可能会提高并行执行性能。 我们称之为**并发减少**。\n\nCollector支持并发还原标有Collector.Characteristics.CONCURRENT特性。然而，并发收集也有缺点。如果多个线程将结果并入到共享容器中，则结果存入的顺序是非确定性的。 因此，只有对于正在处理的流的顺序不重要，并发减少才是可能的。在以下情况该Stream.collect(Collector)实施将只执行并发减少：\n\n- 并发流;\n- Collector具有Collector.Characteristics.CONCURRENT特征，\n- 流是无序的，或者收集器具有Collector.Characteristics.UNORDERED的特征。\n\n可以使用BaseStream.unordered()方法确保流无序 。例如：\n\n```Java\nMap<Buyer, List<Transaction>> salesByBuyer = txns.parallelStream().unordered().collect(groupingByConcurrent(Transaction::getBuyer));  \n```\n\n其中Collectors.groupingByConcurrent(java.util.function.Function<? super T, ? extends K>)等同于groupingBy。\n\n请注意，如果给定键的元素以它们在源中显示的顺序显示很重要，那么我们不能使用并发缩减，因为排序是并发插入的一种伤害。然后，我们将被限制为执行顺序减少或基于并行的并行还原。\n\n## 低级流构造器\n\n到目前为止，所有的流示例都使用了Collection.stream()或Arrays.stream的方法（Object[]）来获取流。这些承载流的方法是如何实现的？\n\nStreamSupport类有许多用于创建流的低级方法，所有这些方法都使用某种形式的Spliterator。一个分离器是一个迭代器的并行模拟；它描述了一个（可能是无限的）元素集合，支持顺序推进、批量遍历，并将输入的一部分拆分到另一个可以并行处理的拆分器中。在最低级别，所有流都由分离器驱动。\n\n在实现拆分器时有许多实现选择，几乎所有这些都是在实现的简单性和使用该拆分器的流的运行时性能之间进行权衡。创建拆分器最简单但性能最低的方法是使用Spliterators.spliteratorUnknownSize（java.util.iterator，int）从迭代器创建一个。虽然这样的拆分器可以工作，但它可能会提供较差的并行性能，因为我们已经丢失了大小信息（底层数据集有多大），并且受制于简单的拆分算法。\n\n更高质量的拆分器将提供均衡且已知的大小拆分、准确的大小信息以及拆分器的许多其他特性或数据，这些特性或数据可由实现用于优化执行。\n\n用于可变数据源的分裂器还有一个额外的挑战；绑定到数据的时间，因为数据可能在创建分离器和执行流管道之间发生变化。理想情况下，流的分离器将报告IMUTABLE或CONCURRENT的特性；如果没有，那应该是后期绑定。如果源无法直接提供推荐的分离器，则可以使用供应商间接提供分离器，并通过接受stream()版本的供应商构建流。只有在流管道的终端操作开始后，才能从供应商处获得分离器。\n\n这些要求显著减少了流源的突变和流管道的执行之间的潜在干扰范围。基于具有所需特性的分离器的流，或使用基于供应商的工厂形式的流，在终端操作开始前不受数据源修改的影响（前提是流操作的行为参数满足不干扰和无状态的要求标准）。有关详细信息，请参见无干扰。\n\n# 实现\n\n## 枚举\n\n| **Enum**                  | **描述**                                                  |\n| ------------------------- | --------------------------------------------------------- |\n| Collector.Characteristics | 指示Collector的属性的 Collector ，可用于优化collect实现。 |\n\n### 枚举常量\n\n- IDENTITY_FINISH：表示整理器功能是身份功能，可以被删除。\n- UNORDERED：表示收集操作不承诺保留输入元素的遇到顺序。\n- CONCURRENT：表示此收集器是**并发的**，这意味着结果容器可以支持与多个线程相同的结果容器同时调用的累加器函数。\n\n### 所有方法\n\n| **方法类型及返回值**               | **方法名称**         | **描述**                                             |\n| ---------------------------------- | -------------------- | ---------------------------------------------------- |\n| static Collector.Characteristics   | valueOf(String name) | 以指定的名称返回此类型的枚举常量。                   |\n| static Collector.Characteristics[] | values()             | 按照它们声明的顺序返回一个包含此枚举类型常量的数组。 |\n\n## 接口\n\n| **接口**                                | **描述**                                                     |\n| --------------------------------------- | ------------------------------------------------------------ |\n| BaseStream<T,S extends BaseStream<T,S>> | 流的基本界面，它们是支持顺序和并行聚合操作的元素序列。       |\n| Collector<T,A,R>                        | A mutable reduction operation将输入元素累加到可变结果容器中，可选地在所有输入元素被处理之后将累积结果转换成最终表示。 |\n| DoubleStream                            | 支持顺序和并行聚合操作的原始双值元素序列。                   |\n| DoubleStream.Builder                    | DoubleStream可变构建器。                                     |\n| IntStream                               | 支持顺序和并行聚合操作的原始int值元素序列。                  |\n| IntStream.Builder                       | IntStream可变构建器。                                        |\n| LongStream                              | 支持顺序和并行聚合操作的原始长值元素序列。                   |\n| LongStream.Builder                      | LongStream可变构建器。                                       |\n| Stream<T>                               | 支持顺序和并行聚合操作的一系列元素。                         |\n| Stream.Builder<T>                       | Stream可变构建器。                                           |\n\n## 实现类\n\n| **类**        | **描述**                                                     |\n| ------------- | ------------------------------------------------------------ |\n| Collectors    | Collector的实现 ，实现各种有用的collect操作，例如将元素累积到集合中，根据各种标准汇总元素等。 |\n| StreamSupport | 用于创建和操纵流的低级实用程序方法。                         |\n\n# 示例\n\n## 接口\n\n### BaseStream\n\n查看Stream的类图：\n\n![img](https://ws9w6gsz7m.feishu.cn/space/api/box/stream/download/asynccode/?code=OTI3OWM1MGYwMjAxOGU2ODRiMWNjMTQ1MWE2N2U0OTFfaEx2T012d0hpM1YyVzFTRHJIaU1EWWQ2U0ZFVXdtTVhfVG9rZW46SWJWVmJ3WjNyb3FyOHh4SGF2UGNDVzZ0bjRkXzE2ODMwNDIwMTc6MTY4MzA0NTYxN19WNA)\n\nBaseStream是Stream的父类，提供了一些基础功能，包括：\n\n| **方法类型及返回值** | **方法名称**                   | **描述**                                         |\n| -------------------- | ------------------------------ | ------------------------------------------------ |\n| void                 | close()                        | 关闭此流，导致此流管道的所有关闭处理程序被调用。 |\n| boolean              | isParallel()                   | 返回此流是否要执行终端操作，将并行执行。         |\n| Iterator<T>          | iterator()                     | 返回此流的元素的迭代器。                         |\n| S                    | onClose(Runnable closeHandler) | 返回带有附加关闭处理程序的等效流。               |\n| S                    | parallel()                     | 返回并行的等效流。                               |\n| S                    | sequential()                   | 返回顺序的等效流。                               |\n| Spliterator<T>       | spliterator()                  | 返回此流的元素的拼接器。                         |\n| S                    | unordered()                    | 返回等效的流，即 unordered 。                    |\n\nAutoCloseable是BaseStream的父类，它只有一个方法：\n\n| **方法类型及返回值** | **方法名称** | **描述**                       |\n| -------------------- | ------------ | ------------------------------ |\n| void                 | close()      | 关闭此资源，放弃任何潜在资源。 |\n\nAutoCloseable对象的close()方法在退出已在资源规范头中声明对象的try-with-resources块时自动调用。这种结构确保迅速释放，避免资源耗尽异常和可能发生的错误。\n\n实际上，基类实现自动关闭是可能的，实际上是可行的，尽管不是所有的子类或实例都将保存可释放的资源。对于必须以完全一般性操作的代码，或者当知道AutoCloseable实例需要资源释放时，建议使用try资源结构。然而，使用设施，例如当Stream同时支持I/O基和非I/O基的形式，try-with-resources块是一般不必要使用非I/O形式。\n\n测试使用：\n\n```Java\nprivate static void test1(List<User> userList) {\n    // 测试isParallel()方法\n    boolean p1 = userList.stream().isParallel();\n    System.out.println(\"是否为并行流：\" + p1);\n    System.out.println(\"-----------------------\");\n\n    // 测试parallel()方法\n    boolean p2 = userList.stream().parallel().isParallel();\n    System.out.println(\"是否为并行流：\" + p2);\n    System.out.println(\"-----------------------\");\n\n    // 测试sequential()方法\n    boolean p3 = userList.parallelStream().sequential().isParallel();\n    System.out.println(\"是否为并行流：\" + p3);\n    System.out.println(\"-----------------------\");\n\n    // 测试iterator()方法\n    Iterator<User> iterator = userList.stream().iterator();\n    while (iterator.hasNext()){\n        System.out.println(iterator.next());\n    }\n    System.out.println(\"-----------------------\");\n\n\n    // 测试onClose()方法\n    userList.stream().onClose(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"我被关闭了\");\n        }\n    }).close();\n    System.out.println(\"-----------------------\");\n\n\n    // 测试spliterator()方法，更多Spliterator用法请参考jdk文档\n    System.out.println(\"使用Spliterator遍历对象：\");\n    Spliterator<User> spliterator = userList.stream().spliterator();\n    spliterator.forEachRemaining(new Consumer<User>() {\n        @Override\n        public void accept(User user) {\n            System.out.println(user);\n        }\n    });\n    System.out.println(\"-----------------------\");\n\n}\n```\n\n控制台输出：\n\n```Plain\n是否为并行流：false\n-----------------------\n是否为并行流：true\n-----------------------\n是否为并行流：false\n-----------------------\nUser(age=18, height=160.0, weight=50.0, username=zhangsan)\nUser(age=28, height=172.0, weight=56.0, username=lisi)\nUser(age=32, height=180.0, weight=79.0, username=wangwu)\nUser(age=21, height=162.0, weight=70.0, username=zhangsan)\n-----------------------\n我被关闭了\n-----------------------\n使用Spliterator遍历对象：\nUser(age=18, height=160.0, weight=50.0, username=zhangsan)\nUser(age=28, height=172.0, weight=56.0, username=lisi)\nUser(age=32, height=180.0, weight=79.0, username=wangwu)\nUser(age=21, height=162.0, weight=70.0, username=zhangsan)\n```\n\n查看unordered()源码，这里实现为ReferencePipeline类：\n\n```Java\n@Override\npublic Stream<P_OUT> unordered() {\n    // 如果本身是无序的直接返回\n    if (!isOrdered())\n        return this;\n    // 添加一个无状态的操作，将流状态更改为StreamOpFlag.NOT_ORDERED\n    return new StatelessOp<P_OUT, P_OUT>(this, StreamShape.REFERENCE, StreamOpFlag.NOT_ORDERED) {\n        @Override\n        Sink<P_OUT> opWrapSink(int flags, Sink<P_OUT> sink) {\n            return sink;\n        }\n    };\n}\n```\n\n### Collector\n\nA mutable reduction operation将输入元素累加到可变结果容器中，可选地在所有输入元素被处理之后将累加结果转换成最终表示。还原操作可以顺序还是并行执行。\n\nA mutable reduction operation的示例包括：将元素累加到一个Collection;  使用连接字符串StringBuilder；计算诸如sum，min，max或average之类的元素的摘要信息；计算“枢纽表”摘要，如“卖方最大价值交易”等。Collectors类提供了许多常见的可变减少的实现。\n\n- 一个Collector由四个函数来指定，这四个函数一起工作以将条目累加到可变结果容器中，并且可选地对结果进行最终转换。他们是：\n    - 创建新的结果容器（`supplier()`）\n    - 将新的数据元素并入结果容器（`accumulator()`）\n    - 将两个结果容器组合成一个（`combiner()`）\n    - 在容器上执行可选的最终变换（`finisher()`）\n- 收集者还具有一系列特征，如`Collector.Characteristics.CONCURRENT`，它提供了可以通过减少实现来提供更好性能的提示。\n\nCollector有以下方法：\n\n| **方法类型及返回值**            | **方法名称**                                                 | **描述**                                                     |\n| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| BiConsumer<A,T>                 | accumulator()                                                | 将值折叠成可变结果容器的函数。                               |\n| Set<Collector.Characteristics>  | characteristics()                                            | 返回一个Set的Collector.Characteristics表示该Collector的特征  |\n| BinaryOperator<A>               | combiner()                                                   | 一个接受两个部分结果并将其合并的函数。                       |\n| Function<A,R>                   | finisher()                                                   | 执行从中间累积类型 A到最终结果类型 R的最终 R 。              |\n| static <T,A,R> Collector<T,A,R> | of(Supplier<A> supplier, BiConsumer<A,T> accumulator, BinaryOperator<A> combiner, Function<A,R> finisher, Collector.Characteristics... characteristics) | 返回一个新Collector由给定的描述 supplier ， accumulator ， combiner和 finisher功能。 |\n| static <T,R> Collector<T,R,R>   | of(Supplier<R> supplier, BiConsumer<R,T> accumulator, BinaryOperator<R> combiner, Collector.Characteristics... characteristics) | 返回一个新 Collector由给定的描述 supplier ， accumulator和 combiner功能。 |\n| Supplier<A>                     | supplier()                                                   | 一个创建并返回一个新的可变结果容器的函数。                   |\n\nCollector接口只有一个实现java.util.stream.Collectors.CollectorImpl，CollectorImpl是Collectors的静态内部类：\n\n```Java\nstatic class CollectorImpl<T, A, R> implements Collector<T, A, R> {\n    private final Supplier<A> supplier;\n    private final BiConsumer<A, T> accumulator;\n    private final BinaryOperator<A> combiner;\n    private final Function<A, R> finisher;\n    private final Set<Characteristics> characteristics;\n\n    CollectorImpl(Supplier<A> supplier,\n                  BiConsumer<A, T> accumulator,\n                  BinaryOperator<A> combiner,\n                  Function<A,R> finisher,\n                  Set<Characteristics> characteristics) {\n        this.supplier = supplier;\n        this.accumulator = accumulator;\n        this.combiner = combiner;\n        this.finisher = finisher;\n        this.characteristics = characteristics;\n    }\n\n    CollectorImpl(Supplier<A> supplier,\n                  BiConsumer<A, T> accumulator,\n                  BinaryOperator<A> combiner,\n                  Set<Characteristics> characteristics) {\n        this(supplier, accumulator, combiner, castingIdentity(), characteristics);\n    }\n\n    @Override\n    public BiConsumer<A, T> accumulator() {\n        return accumulator;\n    }\n\n    @Override\n    public Supplier<A> supplier() {\n        return supplier;\n    }\n\n    @Override\n    public BinaryOperator<A> combiner() {\n        return combiner;\n    }\n\n    @Override\n    public Function<A, R> finisher() {\n        return finisher;\n    }\n\n    @Override\n    public Set<Characteristics> characteristics() {\n        return characteristics;\n    }\n}\n```\n\nCollectors的大部分方法都是依赖CollectorImpl实现的，例如：\n\n```Java\nprivate static void test2(List<User> userList) {\n    // 将所有姓名拼接在一起\n    String collect = userList.stream().map(User::getUsername).collect(Collectors.joining());\n    System.out.println(collect);\n}\n```\n\n控制台输出：\n\n```Plain\nzhangsanlisiwangwuzhangsan\n```\n\n查看Collectors的joining()方法：\n\n```Java\npublic static Collector<CharSequence, ?, String> joining() {\n    return new CollectorImpl<CharSequence, StringBuilder, String>(\n            StringBuilder::new, StringBuilder::append,\n            (r1, r2) -> { r1.append(r2); return r1; },\n            StringBuilder::toString, CH_NOID);\n}\n```\n\n实际上就是创建了一个CollectorImpl示例，实现了\n\n1. supplier\n2. accumulator\n3. combiner\n4. finisher\n\n等方法，并传入了characteristics。\n\nStream类提供另一个重载的collect方法：\n\n```Java\n<R> R collect(Supplier<R> supplier,\n              BiConsumer<R, ? super T> accumulator,\n              BiConsumer<R, R> combiner);\n```\n\n我们可以自己实现一个将姓名放在一个集合中的功能：\n\n```Java\nprivate static void test2(List<User> userList) {\n    Supplier<List<String>> supplier = new Supplier<List<String>>() {\n        @Override\n        public List<String> get() {\n            return new ArrayList<>();\n        }\n    };\n    BiConsumer<List<String>, User> accumulator = new BiConsumer<List<String>, User>() {\n        @Override\n        public void accept(List<String> list, User user) {\n            list.add(user.getUsername());\n        }\n    };\n    BiConsumer<List<String>, List<String>> combiner = new BiConsumer<List<String>, List<String>>() {\n        @Override\n        public void accept(List<String> list1, List<String> list2) {\n            list1.addAll(list2);\n        }\n    };\n    List<String> collect1 = userList.stream().collect(supplier, accumulator, combiner);\n    System.out.println(collect1);\n}\n```\n\n控制台输出：\n\n```Plain\n[zhangsan, lisi, wangwu, zhangsan]\n```\n\nCollector还提供两个of函数，根据不同入参返回新Collector，最终返回的实现也是CollectorImpl。\n\n```Java\npublic static<T, R> Collector<T, R, R> of(Supplier<R> supplier,\n                                          BiConsumer<R, T> accumulator,\n                                          BinaryOperator<R> combiner,\n                                          Characteristics... characteristics) {\n    Objects.requireNonNull(supplier);\n    Objects.requireNonNull(accumulator);\n    Objects.requireNonNull(combiner);\n    Objects.requireNonNull(characteristics);\n    Set<Characteristics> cs = (characteristics.length == 0)\n                              ? Collectors.CH_ID\n                              : Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH,\n                                                                       characteristics));\n    return new Collectors.CollectorImpl<>(supplier, accumulator, combiner, cs);\n}\n\n\npublic static<T, A, R> Collector<T, A, R> of(Supplier<A> supplier,\n                                             BiConsumer<A, T> accumulator,\n                                             BinaryOperator<A> combiner,\n                                             Function<A, R> finisher,\n                                             Characteristics... characteristics) {\n    Objects.requireNonNull(supplier);\n    Objects.requireNonNull(accumulator);\n    Objects.requireNonNull(combiner);\n    Objects.requireNonNull(finisher);\n    Objects.requireNonNull(characteristics);\n    Set<Characteristics> cs = Collectors.CH_NOID;\n    if (characteristics.length > 0) {\n        cs = EnumSet.noneOf(Characteristics.class);\n        Collections.addAll(cs, characteristics);\n        cs = Collections.unmodifiableSet(cs);\n    }\n    return new Collectors.CollectorImpl<>(supplier, accumulator, combiner, finisher, cs);\n}\n```\n\n### DoubleStream\n\nDoubleStream支持顺序和并行聚合操作的原始双值元素序列，是double原始专长Stream。\n\nDoubleStream有以下方法：\n\n| **方法类型及返回值**        | **方法名称**                                                 | **描述**                                                     |\n| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| boolean                     | allMatch(DoublePredicate predicate)                          | 返回此流的所有元素是否与提供的谓词匹配。                     |\n| boolean                     | anyMatch(DoublePredicate predicate)                          | 返回此流的任何元素是否与提供的谓词匹配。                     |\n| OptionalDouble              | average()                                                    | 返回 OptionalDouble此流的元素的算术平均值的OptionalDouble，如果此流为空，则返回一个空的可选项。 |\n| Stream<Double>              | boxed()                                                      | 返回一个 Stream组成的这个流的元素，装箱到 Double 。          |\n| static DoubleStream.Builder | builder()                                                    | 返回一个 DoubleStream的生成器。                              |\n| <R> R                       | collect(Supplier<R> supplier, ObjDoubleConsumer<R> accumulator, BiConsumer<R,R> combiner) | 对此流的元素执行 mutable reduction操作。                     |\n| static DoubleStream         | concat(DoubleStream a, DoubleStream b)                       | 创建一个懒惰连接的流，其元素是第一个流的所有元素，后跟第二个流的所有元素。 |\n| long                        | count()                                                      | 返回此流中的元素数。                                         |\n| DoubleStream                | distinct()                                                   | 返回由该流的不同元素组成的流。                               |\n| static DoubleStream         | empty()                                                      | 返回一个空的顺序 DoubleStream 。                             |\n| DoubleStream                | filter(DoublePredicate predicate)                            | 返回由与此给定谓词匹配的此流的元素组成的流。                 |\n| OptionalDouble              | findAny()                                                    | 返回描述流的一些元素的OptionalDouble如果流为空，则返回一个空的OptionalDouble 。 |\n| OptionalDouble              | findFirst()                                                  | 返回描述此流的第一个元素的OptionalDouble如果流为空，则返回一个空的OptionalDouble 。 |\n| DoubleStream                | flatMap(DoubleFunction<? extends DoubleStream> mapper)       | 返回由通过将提供的映射函数应用于每个元素而产生的映射流的内容来替换该流的每个元素的结果的流。 |\n| void                        | forEach(DoubleConsumer action)                               | 对此流的每个元素执行操作。                                   |\n| void                        | forEachOrdered(DoubleConsumer action)                        | 对此流的每个元素执行一个操作，保证每个元素按遇到顺序处理，以便具有定义的遇到顺序的流。 |\n| static DoubleStream         | generate(DoubleSupplier s)                                   | 返回无限顺序无序流，其中每个元素由提供的 DoubleSupplier 。   |\n| static DoubleStream         | iterate(double seed, DoubleUnaryOperator f)                  | 返回有序无限连续 DoubleStream由函数的迭代应用产生 f至初始元素 seed ，产生 Stream包括 seed ， f(seed) ， f(f(seed)) ，等 |\n| PrimitiveIterator.OfDouble  | iterator()                                                   | 返回此流的元素的迭代器。                                     |\n| DoubleStream                | limit(long maxSize)                                          | 返回由此流的元素组成的流，截断长度不能超过 maxSize。         |\n| DoubleStream                | map(DoubleUnaryOperator mapper)                              | 返回由给定函数应用于此流的元素的结果组成的流。               |\n| IntStream                   | mapToInt(DoubleToIntFunction mapper)                         | 返回一个 IntStream ，其中包含将给定函数应用于此流的元素的结果。 |\n| LongStream                  | mapToLong(DoubleToLongFunction mapper)                       | 返回一个 LongStream ，其中包含将给定函数应用于此流的元素的结果。 |\n| <U> Stream<U>               | mapToObj(DoubleFunction<? extends U> mapper)                 | 返回一个对象值 Stream ，其中包含将给定函数应用于此流的元素的结果。 |\n| OptionalDouble              | max()                                                        | 返回 OptionalDouble此流的最大元素的OptionalDouble，如果此流为空，则返回空的OptionalDouble。 |\n| OptionalDouble              | min()                                                        | 返回 OptionalDouble此流的最小元素的OptionalDouble，如果此流为空，则返回空的OptionalDouble。 |\n| boolean                     | noneMatch(DoublePredicate predicate)                         | 返回此流的元素是否与提供的谓词匹配。                         |\n| static DoubleStream         | of(double... values)                                         | 返回其元素是指定值的顺序排序流。                             |\n| static DoubleStream         | of(double t)                                                 | 返回包含单个元素的顺序 DoubleStream 。                       |\n| DoubleStream                | parallel()                                                   | 返回平行的等效流。                                           |\n| DoubleStream                | peek(DoubleConsumer action)                                  | 返回由该流的元素组成的流，另外在从生成的流中消耗元素时对每个元素执行提供的操作。 |\n| OptionalDouble              | reduce(DoubleBinaryOperator op)                              | 使用 associative累积函数对此流的元素执行 reduction ，并返回描述减小值（如果有的话）的 OptionalDouble 。 |\n| double                      | reduce(double identity, DoubleBinaryOperator op)             | 使用提供的身份值和 associative累积功能对此流的元素执行 reduction ，并返回减小的值。 |\n| DoubleStream                | sequential()                                                 | 返回顺序的等效流。                                           |\n| DoubleStream                | skip(long n)                                                 | 在丢弃流的第一个 n元素之后，返回由该流的 n元素组成的流。     |\n| DoubleStream                | sorted()                                                     | 以排序顺序返回由该流的元素组成的流。                         |\n| Spliterator.OfDouble        | spliterator()                                                | 返回此流的元素的拼接器。                                     |\n| double                      | sum()                                                        | 返回此流中元素的总和。                                       |\n| DoubleSummaryStatistics     | summaryStatistics()                                          | 返回一个 DoubleSummaryStatistics描述有关此流的元素的各种摘要数据。 |\n| double[]                    | toArray()                                                    | 返回一个包含此流的元素的数组。                               |\n\n我们可以生成一个DoubleStream：\n\n```Java\nDoubleStream doubleStream = userList.stream().mapToDouble(User::getHeight);\n```\n\n查看mapToDouble()方法：\n\n```Java\n@Override\npublic final DoubleStream mapToDouble(ToDoubleFunction<? super P_OUT> mapper) {\n    Objects.requireNonNull(mapper);\n    return new DoublePipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,\n                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {\n        @Override\n        Sink<P_OUT> opWrapSink(int flags, Sink<Double> sink) {\n            return new Sink.ChainedReference<P_OUT, Double>(sink) {\n                @Override\n                public void accept(P_OUT u) {\n                    downstream.accept(mapper.applyAsDouble(u));\n                }\n            };\n        }\n    };\n}\n```\n\n实际返回的是一个StatelessOp类型，查看其类图：\n\n![img](https://ws9w6gsz7m.feishu.cn/space/api/box/stream/download/asynccode/?code=MDMyOWJlZTNmN2I4ZmUyNGQwMWEwYzUzNWQwNzU2OWVfallIeWh1eDNwQ3kzeThta3BRT2NyRVJmUHJLWEw2bHBfVG9rZW46RW5VRWIzZWJ1b3lOT1N4bUFCNmNHZHpNblpkXzE2ODMwNDIwMTc6MTY4MzA0NTYxN19WNA)\n\nStatelessOp继承了DoubleStream，DoubleStream又继承了AbstractPipeline，其实AbstractPipeline有很多常用的实现，比如:\n\n1. Stream对应的实现ReferencePipeline\n2. IntStream对应的实现IntPipeline\n3. LongStream对应的实现IntPipeline\n\n![img](https://ws9w6gsz7m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTg1NjRmMTk4NWNiYTgxMjZhNTQxMjNjYjdlZDdiYjZfV0tEZXN6eTExYmZ5TGx0V3luVk4wVU5aMFl3am42U1pfVG9rZW46QW5vVmIwMUtMb0hhUE54eGROZWNDSTZqblVkXzE2ODMwNDIwMTc6MTY4MzA0NTYxN19WNA)\n\n也可以通过DoubleStream的静态方法of()来创建DoubleStream：\n\n```Java\nDoubleStream doubleStream = DoubleStream.of(1, 2, 3, 4, 5);\n```\n\n进入of()方法：\n\n```Java\npublic static DoubleStream of(double... values) {\n    return Arrays.stream(values);\n}\n```\n\n进入Arrays.stream()方法：\n\n```Java\npublic static DoubleStream stream(double[] array) {\n    return stream(array, 0, array.length);\n}\n```\n\n进入重载的stream()方法：\n\n```Java\npublic static DoubleStream stream(double[] array, int startInclusive, int endExclusive) {\n    return StreamSupport.doubleStream(spliterator(array, startInclusive, endExclusive), false);\n}\n```\n\n最终使用的是StreamSupport的doubleStream()创建DoubleStream，进入doubleStream()方法：\n\n```Java\npublic static DoubleStream doubleStream(Spliterator.OfDouble spliterator,\n                                        boolean parallel) {\n    return new DoublePipeline.Head<>(spliterator,\n                                     StreamOpFlag.fromCharacteristics(spliterator),\n                                     parallel);\n}\n```\n\n新建了一个Head类，而Head又是DoublePipeline子类。\n\n测试方法：\n\n```Java\nprivate static void test3(List<User> userList) {\n    // 测试allMatch()方法\n    boolean allMatch = userList.stream().mapToDouble(User::getAge).allMatch(new DoublePredicate() {\n        @Override\n        public boolean test(double age) {\n            return age < 50;\n        }\n    });\n    System.out.println(\"是否所有用户都小于50岁：\" + allMatch);\n    System.out.println(\"-----------------------\");\n\n    // 测试anyMatch()方法\n    boolean anyMatch = userList.stream().mapToDouble(User::getAge).anyMatch(new DoublePredicate() {\n        @Override\n        public boolean test(double age) {\n            return age < 10;\n        }\n    });\n    System.out.println(\"是否存在年龄小于10岁的用户：\" + anyMatch);\n    System.out.println(\"-----------------------\");\n\n    // 测试average()方法\n    OptionalDouble average = userList.stream().mapToDouble(User::getAge).average();\n    System.out.println(\"用户评价年龄为：\" + average.orElse(-1));\n    System.out.println(\"-----------------------\");\n\n    // 测试boxed()方法\n    Stream<Double> boxed = userList.stream().mapToDouble(User::getAge).boxed();\n    System.out.println(\"通过装箱的Stream统计数量：\" + boxed.count());\n    System.out.println(\"-----------------------\");\n\n    // 测试builder()方法\n    DoubleStream build1 = DoubleStream.builder().add(1).add(2).add(3).build();\n    System.out.println(\"遍历通过builder()方法创建的DoubleStream元素：\");\n    build1.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试collect()方法\n    Supplier<List<Double>> supplier = new Supplier<List<Double>>() {\n        @Override\n        public List<Double> get() {\n            return new ArrayList<>();\n        }\n    };\n    ObjDoubleConsumer<List<Double>> accumulator = new ObjDoubleConsumer<List<Double>>() {\n        @Override\n        public void accept(List<Double> list, double value) {\n            if (value > 20) {\n                list.add(value);\n            }\n        }\n    };\n    BiConsumer<List<Double>, List<Double>> combiner = new BiConsumer<List<Double>, List<Double>>() {\n        @Override\n        public void accept(List<Double> list1, List<Double> list2) {\n            list1.addAll(list2);\n        }\n    };\n    List<Double> collect = userList.stream()\n            .mapToDouble(User::getAge)\n            .collect(supplier, accumulator, combiner);\n    System.out.println(\"列举所有大于20的年龄：\");\n    System.out.println(collect);\n    System.out.println(\"-----------------------\");\n\n    // 测试concat()方法\n    System.out.println(\"打印两个连接起来的DoubleStream元素：\");\n    DoubleStream.concat(userList.stream().mapToDouble(User::getAge), DoubleStream.of(1, 2, 3, 4, 5)).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试count()方法\n    long count = userList.stream().mapToDouble(User::getAge).count();\n    System.out.println(\"流中元素的总数：\");\n    System.out.println(count);\n    System.out.println(\"-----------------------\");\n\n    // 测试distinct()方法\n    System.out.println(\"打印去重后的年龄：\");\n    userList.stream().mapToDouble(User::getAge).distinct().forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试empty()方法\n    System.out.println(\"获取一个空的DoubleStream：\");\n    DoubleStream empty = DoubleStream.empty();\n    System.out.println(empty);\n    System.out.println(\"-----------------------\");\n\n    // 测试filter()方法\n    System.out.println(\"过滤调年龄大于30的用户：\");\n    userList.stream().mapToDouble(User::getAge).filter(age -> age <= 30).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试findAny()方法，返回流中任意的一个元素并包装成OptionalDouble，结果不稳定\n    double asDouble1 = userList.stream().mapToDouble(User::getAge).findAny().orElse(-1);\n    System.out.println(\"返回流中任意元素并包装成OptionalDouble：\");\n    System.out.println(asDouble1);\n    System.out.println(\"-----------------------\");\n\n    // 测试findFirst()方法，返回流中第一个元素并包装成OptionalDouble，结果稳定\n    double asDouble2 = userList.stream().mapToDouble(User::getAge).findFirst().orElse(-1);\n    System.out.println(\"返回流中首个元素并包装成OptionalDouble：\");\n    System.out.println(asDouble2);\n    System.out.println(\"-----------------------\");\n\n    // 测试flatMap()方法\n    System.out.println(\"测试flatMap()方法，每人年龄+10岁：\");\n    userList.stream().mapToDouble(User::getAge).flatMap(new DoubleFunction<DoubleStream>() {\n        @Override\n        public DoubleStream apply(double value) {\n            return DoubleStream.of(value + 10);\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试forEach()方法，不保证顺序\n    System.out.println(\"打印每个年龄：\");\n    userList.parallelStream().mapToDouble(User::getAge).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试forEachOrdered()方法，保证顺序\n    System.out.println(\"打印每个年龄：\");\n    userList.parallelStream().mapToDouble(User::getAge).forEachOrdered(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试generate()方法\n    System.out.println(\"随机生成10个数字：\");\n    double[] doubles = DoubleStream.generate(new DoubleSupplier() {\n        @Override\n        public double getAsDouble() {\n            return Math.random();\n        }\n    }).limit(10).toArray();\n    System.out.println(Arrays.toString(doubles));\n    System.out.println(\"-----------------------\");\n\n    // 测试iterate()方法\n    System.out.println(\"生成10个等差数：\");\n    double[] doubles1 = DoubleStream.iterate(2, new DoubleUnaryOperator() {\n        @Override\n        public double applyAsDouble(double operand) {\n            return operand + 2;\n        }\n    }).limit(10).toArray();\n    System.out.println(Arrays.toString(doubles1));\n\n    // 测试iterate()方法\n    PrimitiveIterator.OfDouble iterator = userList.stream().mapToDouble(User::getAge).iterator();\n    System.out.println(\"通过iterate打印元素：\");\n    while (iterator.hasNext()) {\n        System.out.println(iterator.next());\n    }\n    System.out.println(\"-----------------------\");\n\n    // 测试limit()方法\n    OptionalDouble average1 = userList.stream().mapToDouble(User::getAge).limit(3).average();\n    System.out.println(\"求前三个用户的平均年龄：\");\n    System.out.println(average1.orElse(-1));\n    System.out.println(\"-----------------------\");\n\n    // 测试map()方法\n    System.out.println(\"将所有年龄+20岁：\");\n    userList.stream().mapToDouble(User::getAge).map(new DoubleUnaryOperator() {\n        @Override\n        public double applyAsDouble(double operand) {\n            return operand + 20;\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapToInt()方法\n    System.out.println(\"将所有年龄映射为整型：\");\n    userList.stream().mapToDouble(User::getAge).mapToInt(new DoubleToIntFunction() {\n        @Override\n        public int applyAsInt(double value) {\n            return (int) value;\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapToLong()方法\n    System.out.println(\"将所有年龄映射为长整型：\");\n    userList.stream().mapToDouble(User::getAge).mapToLong(new DoubleToLongFunction() {\n        @Override\n        public long applyAsLong(double value) {\n            return (long) value;\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapToObj()方法\n    System.out.println(\"将所有年龄映射为用户：\");\n    userList.stream().mapToDouble(User::getAge).mapToObj(new DoubleFunction<User>() {\n        @Override\n        public User apply(double value) {\n            return User.builder().age((int) value).build();\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试max()方法\n    double maxAge = userList.stream().mapToDouble(User::getAge).max().orElse(-1);\n    System.out.println(\"获取最大的年龄：\");\n    System.out.println(maxAge);\n    System.out.println(\"-----------------------\");\n\n    // 测试min()方法\n    double minAge = userList.stream().mapToDouble(User::getAge).min().orElse(-1);\n    System.out.println(\"获取最小的年龄：\");\n    System.out.println(minAge);\n    System.out.println(\"-----------------------\");\n\n    // 测试noneMatch()方法\n    System.out.println(\"返回是否没有年龄大于100的用户：\");\n    boolean noneMatch = userList.stream().mapToDouble(User::getAge).noneMatch(new DoublePredicate() {\n        @Override\n        public boolean test(double value) {\n            return value > 100;\n        }\n    });\n    System.out.println(noneMatch);\n    System.out.println(\"-----------------------\");\n\n\n    // 测试of()方法\n    System.out.println(\"打印生成的多个元素序列：\");\n    DoubleStream.of(1, 2, 3, 4, 5).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试of()方法\n    System.out.println(\"打印生成的单个元素序列：\");\n    DoubleStream.of(1).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试parallel()方法\n    System.out.println(\"返回并发流：\");\n    System.out.println(userList.stream().mapToDouble(User::getAge).parallel());\n    System.out.println(\"-----------------------\");\n\n    // 测试peek()方法，是一个中间操作，主要用于调试\n    System.out.println(\"打印流中的每个元素：\");\n    userList.stream().mapToDouble(User::getAge).peek(new DoubleConsumer() {\n        @Override\n        public void accept(double value) {\n            System.out.println(value);\n        }\n    }).sum();\n    System.out.println(\"-----------------------\");\n\n    // 测试reduce()方法，首个元素为流的第一个元素\n    System.out.println(\"求年龄和：\");\n    double v = userList.stream().mapToDouble(User::getAge).reduce(new DoubleBinaryOperator() {\n        @Override\n        public double applyAsDouble(double left, double right) {\n            return left + right;\n        }\n    }).orElse(-1);\n    System.out.println(v);\n    System.out.println(\"-----------------------\");\n\n    // 测试reduce()方法，首个元素为identity（即第一个参数）\n    System.out.println(\"求年龄和：\");\n    double sum = userList.stream().mapToDouble(User::getAge).reduce(0, new DoubleBinaryOperator() {\n        @Override\n        public double applyAsDouble(double left, double right) {\n            return left + right;\n        }\n    });\n    System.out.println(sum);\n    System.out.println(\"-----------------------\");\n\n    // 测试sequential()方法\n    System.out.println(\"返回顺序流：\");\n    System.out.println(userList.parallelStream().mapToDouble(User::getAge).sequential());\n    System.out.println(\"-----------------------\");\n\n    // 测试skip()方法\n    System.out.println(\"跳过前三个元素：\");\n    userList.stream().mapToDouble(User::getAge).skip(3).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试sorted()方法\n    System.out.println(\"按年龄大小排序：\");\n    userList.stream().mapToDouble(User::getAge).sorted().forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试sum()方法\n    double sum1 = userList.stream().mapToDouble(User::getAge).sum();\n    System.out.println(\"求年龄总和：\");\n    System.out.println(sum1);\n    System.out.println(\"-----------------------\");\n\n\n    // 测试summaryStatistics()方法，返回各种摘要信息\n    DoubleSummaryStatistics statistics = userList.stream().mapToDouble(User::getAge).summaryStatistics();\n    System.out.println(\"和：\" + statistics.getSum());\n    System.out.println(\"数量：\" + statistics.getCount());\n    System.out.println(\"最大值：\" + statistics.getMax());\n    System.out.println(\"最小值：\" + statistics.getMin());\n    System.out.println(\"平均值：\" + statistics.getAverage());\n    System.out.println(\"-----------------------\");\n\n    // 测试toArray()方法\n    System.out.println(\"转换为double数组：\");\n    double[] doubles2 = userList.stream().mapToDouble(User::getAge).toArray();\n    System.out.println(Arrays.toString(doubles2));\n    System.out.println(\"-----------------------\");\n}\n```\n\n控制台输出：\n\n```Plain\n是否所有用户都小于50岁：true\n-----------------------\n是否存在年龄小于10岁的用户：false\n-----------------------\n用户评价年龄为：24.0\n-----------------------\n通过装箱的Stream统计数量：5\n-----------------------\n遍历通过builder()方法创建的DoubleStream元素：\n1.0\n2.0\n3.0\n-----------------------\n列举所有大于20的年龄：\n[28.0, 32.0, 21.0, 21.0]\n-----------------------\n打印两个连接起来的DoubleStream元素：\n18.0\n28.0\n32.0\n21.0\n21.0\n1.0\n2.0\n3.0\n4.0\n5.0\n-----------------------\n流中元素的总数：\n5\n-----------------------\n打印去重后的年龄：\n18.0\n28.0\n32.0\n21.0\n-----------------------\n获取一个空的DoubleStream：\njava.util.stream.DoublePipeline$Head@70177ecd\n-----------------------\n过滤调年龄大于30的用户：\n18.0\n28.0\n21.0\n21.0\n-----------------------\n返回流中任意元素并包装成OptionalDouble：\n18.0\n-----------------------\n返回流中首个元素并包装成OptionalDouble：\n18.0\n-----------------------\n测试flatMap()方法，每人年龄+10岁：\n28.0\n38.0\n42.0\n31.0\n31.0\n-----------------------\n打印每个年龄：\n32.0\n21.0\n21.0\n28.0\n18.0\n-----------------------\n打印每个年龄：\n18.0\n28.0\n32.0\n21.0\n21.0\n-----------------------\n随机生成10个数字：\n[0.18121932440868183, 0.904518798550446, 0.011759406143421747, 0.06724315355410238, 0.313646526209993, 0.2979765562818961, 0.3532403626941105, 0.7891910846750343, 0.8739355801002622, 0.030225708400019924]\n-----------------------\n生成10个等差数：\n[2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 18.0, 20.0]\n通过iterate打印元素：\n18.0\n28.0\n32.0\n21.0\n21.0\n-----------------------\n求前三个用户的平均年龄：\n26.0\n-----------------------\n将所有年龄+20岁：\n38.0\n48.0\n52.0\n41.0\n41.0\n-----------------------\n将所有年龄映射为整型：\n18\n28\n32\n21\n21\n-----------------------\n将所有年龄映射为长整型：\n18\n28\n32\n21\n21\n-----------------------\n将所有年龄映射为用户：\nUser(age=18, height=null, weight=null, username=null)\nUser(age=28, height=null, weight=null, username=null)\nUser(age=32, height=null, weight=null, username=null)\nUser(age=21, height=null, weight=null, username=null)\nUser(age=21, height=null, weight=null, username=null)\n-----------------------\n获取最大的年龄：\n32.0\n-----------------------\n获取最小的年龄：\n18.0\n-----------------------\n返回是否没有年龄大于100的用户：\ntrue\n-----------------------\n打印生成的多个元素序列：\n1.0\n2.0\n3.0\n4.0\n5.0\n-----------------------\n打印生成的单个元素序列：\n1.0\n-----------------------\n返回并发流：\njava.util.stream.ReferencePipeline$6@69d0a921\n-----------------------\n打印流中的每个元素：\n18.0\n28.0\n32.0\n21.0\n21.0\n-----------------------\n求年龄和：\n120.0\n-----------------------\n求年龄和：\n120.0\n-----------------------\n返回顺序流：\njava.util.stream.ReferencePipeline$6@42110406\n-----------------------\n跳过前三个元素：\n21.0\n21.0\n-----------------------\n按年龄大小排序：\n18.0\n21.0\n21.0\n28.0\n32.0\n-----------------------\n求年龄总和：\n120.0\n-----------------------\n和：120.0\n数量：5\n最大值：32.0\n最小值：18.0\n平均值：24.0\n-----------------------\n转换为double数组：\n[18.0, 28.0, 32.0, 21.0, 21.0]\n-----------------------\n```\n\n### DoubleStream.Builder\n\nDoubleStream.Builder是DoubleStream是构建器，DoubleStream.Builder具有生命周期，其从构建阶段开始，在该阶段期间可以添加元素，然后转换到内置阶段，之后可能不添加元素。构建阶段从调用build()方法开始，它创建一个有序流，其元素是添加到流构建器的元素，按照它们被添加的顺序。\n\nDoubleStream.Builder提供以下方法：\n\n| **方法类型及返回值**         | **方法名称**     | **描述**                           |\n| ---------------------------- | ---------------- | ---------------------------------- |\n| void                         | accept(double t) | 向要构建的流添加元素。             |\n| default DoubleStream.Builder | add(double t)    | 向要构建的流添加元素。             |\n| DoubleStream                 | build()          | 构建流，将此构建器转换为内置状态。 |\n\n测试方法：\n\n```Java\nprivate static void test4(List<User> userList) {\n    // 测试builder()方法\n    DoubleStream build1 = DoubleStream.builder().add(1).add(2).add(3).build();\n    System.out.println(\"遍历通过builder()方法创建的DoubleStream元素：\");\n    build1.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n}\n```\n\n控制台输出：\n\n```Plain\n遍历通过builder()方法创建的DoubleStream元素：\n1.0\n2.0\n3.0\n-----------------------\n```\n\nDoubleStream.Builderd的accept(double t)方法只在DoubleStreamBuilderImpl中有实现，DoubleStreamBuilderImpl在两个地方有用法：\n\n1. DoubleStream的builder()方法：\n\n```Java\n/**\n* 返回DoubleStreamBuilderImpl实例\n*/\npublic static Builder builder() {\n    return new Streams.DoubleStreamBuilderImpl();\n}\n```\n\n2. DoubleStream的of()方法：\n\n```Java\n/**\n* 返回具有单个元素的DoubleStream \n*/\npublic static DoubleStream of(double t) {\n    return StreamSupport.doubleStream(new Streams.DoubleStreamBuilderImpl(t), false);\n}\n```\n\n### IntStream\n\nIntStream支持顺序和并行聚合操作的原始int值元素序列，是int原始专长Stream。\n\nIntStream有以下方法：\n\n| **方法类型及返回值**     | **方法名称**                                                 | **描述**                                                     |\n| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| boolean                  | allMatch(IntPredicate predicate)                             | 返回此流的所有元素是否与提供的谓词匹配。                     |\n| boolean                  | anyMatch(IntPredicate predicate)                             | 返回此流的任何元素是否与提供的谓词匹配。                     |\n| DoubleStream             | asDoubleStream()                                             | 返回一个DoubleStream由该流中的元素，转换为double 。          |\n| LongStream               | asLongStream()                                               | 返回一个LongStream由该流的元素组成，转换为long 。            |\n| OptionalDouble           | average()                                                    | 返回OptionalDouble此流的元素的算术平均值的OptionalDouble，如果此流为空，则返回空的可选项。 |\n| Stream<Integer>          | boxed()                                                      | 返回一个Stream组成的这个流的元素，每个盒装到一个Integer 。   |\n| static IntStream.Builder | builder()                                                    | 返回一个IntStream的生成器。                                  |\n| <R> R                    | collect(Supplier<R> supplier, ObjIntConsumer<R> accumulator, BiConsumer<R,R> combiner) | 对此流的元素执行mutable reduction操作。                      |\n| static IntStream         | concat(IntStream a, IntStream b)                             | 创建一个懒惰连接的流，其元素是第一个流的所有元素，后跟第二个流的所有元素。 |\n| long                     | count()                                                      | 返回此流中的元素数。                                         |\n| IntStream                | distinct()                                                   | 返回由该流的不同元素组成的流。                               |\n| static IntStream         | empty()                                                      | 返回一个空的顺序IntStream 。                                 |\n| IntStream                | filter(IntPredicate predicate)                               | 返回由与此给定谓词匹配的此流的元素组成的流。                 |\n| OptionalInt              | findAny()                                                    | 返回一个描述流的一些元素的OptionalInt如果流为空，则返回一个空的OptionalInt 。 |\n| OptionalInt              | findFirst()                                                  | 返回描述此流的第一个元素的OptionalInt如果流为空，则返回一个空的OptionalInt 。 |\n| IntStream                | flatMap(IntFunction<? extends IntStream> mapper)             | 返回由通过将提供的映射函数应用于每个元素而产生的映射流的内容来替换该流的每个元素的结果的流。 |\n| void                     | forEach(IntConsumer action)                                  | 对此流的每个元素执行操作。                                   |\n| void                     | forEachOrdered(IntConsumer action)                           | 对此流的每个元素执行一个操作，保证每个元素按遇到顺序处理，以便具有定义的遇到顺序的流。 |\n| static IntStream         | generate(IntSupplier s)                                      | 返回无限顺序无序流，其中每个元素由提供的IntSupplier。        |\n| static IntStream         | iterate(int seed, IntUnaryOperator f)                        | 返回有序无限连续IntStream由函数的迭代应用产生f至初始元素seed ，产生 Stream包括 seed ， f(seed) ， f(f(seed)) ，等 |\n| PrimitiveIterator.OfInt  | iterator()                                                   | 返回此流的元素的迭代器。                                     |\n| IntStream                | limit(long maxSize)                                          | 返回由此流的元素组成的流，截断长度不能超过 maxSize 。        |\n| IntStream                | map(IntUnaryOperator mapper)                                 | 返回由给定函数应用于此流的元素的结果组成的流。               |\n| DoubleStream             | mapToDouble(IntToDoubleFunction mapper)                      | 返回一个 DoubleStream ，其中包含将给定函数应用于此流的元素的结果。 |\n| LongStream               | mapToLong(IntToLongFunction mapper)                          | 返回一个 LongStream ，其中包含将给定函数应用于此流的元素的结果。 |\n| <U> Stream<U>            | mapToObj(IntFunction<? extends U> mapper)                    | 返回一个对象值 Stream ，其中包含将给定函数应用于此流的元素的结果。 |\n| OptionalInt              | max()                                                        | 返回 OptionalInt此流的最大元素的OptionalInt，如果此流为空，则返回一个空的可选项。 |\n| OptionalInt              | min()                                                        | 返回 OptionalInt此流的最小元素的OptionalInt，如果此流为空，则返回一个空的可选项。 |\n| boolean                  | noneMatch(IntPredicate predicate)                            | 返回此流的元素是否与提供的谓词匹配。                         |\n| static IntStream         | of(int... values)                                            | 返回其元素是指定值的顺序排序流。                             |\n| static IntStream         | of(int t)                                                    | 返回一个包含单个元素的顺序IntStream。                        |\n| IntStream                | parallel()                                                   | 返回平行的等效流。                                           |\n| IntStream                | peek(IntConsumer action)                                     | 返回由该流的元素组成的流，另外在从生成的流中消耗元素时对每个元素执行提供的操作。 |\n| static IntStream         | range(int startInclusive, int endExclusive)                  | 返回有序的顺序IntStream从startInclusive（含）至 endExclusive通过增量步骤（独家） 1 。 |\n| static IntStream         | rangeClosed(int startInclusive, int endInclusive)            | 从 startInclusive （含）的顺序排列 IntStream到 endInclusive（含），增量步长为 1 。 |\n| OptionalInt              | reduce(IntBinaryOperator op)                                 | 使用associative累积函数对此流的元素执行reduction ，并返回描述减小值的 OptionalInt （如果有）。 |\n| int                      | reduce(int identity, IntBinaryOperator op)                   | 使用提供的身份值和associative累积功能对此流的元素执行reduction ，并返回减小的值。 |\n| IntStream                | sequential()                                                 | 返回顺序的等效流。                                           |\n| IntStream                | skip(long n)                                                 | 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。       |\n| IntStream                | sorted()                                                     | 以排序顺序返回由该流的元素组成的流。                         |\n| Spliterator.OfInt        | spliterator()                                                | 返回此流的元素的拼接器。                                     |\n| int                      | sum()                                                        | 返回此流中元素的总和。                                       |\n| IntSummaryStatistics     | summaryStatistics()                                          | 返回一个 IntSummaryStatistics描述有关此流的元素的各种摘要数据。 |\n| int[]                    | toArray()                                                    | 返回一个包含此流的元素的数组。                               |\n\n测试方法：\n\n```Java\nprivate static void test5(List<User> userList) {\n    // 测试allMatch()方法\n    boolean allMatch = userList.stream().mapToInt(User::getAge).allMatch(new IntPredicate() {\n        @Override\n        public boolean test(int age) {\n            return age < 50;\n        }\n    });\n    System.out.println(\"是否所有用户都小于50岁：\" + allMatch);\n    System.out.println(\"-----------------------\");\n\n    // 测试anyMatch()方法\n    boolean anyMatch = userList.stream().mapToInt(User::getAge).anyMatch(new IntPredicate() {\n        @Override\n        public boolean test(int age) {\n            return age < 10;\n        }\n    });\n    System.out.println(\"是否存在年龄小于10岁的用户：\" + anyMatch);\n    System.out.println(\"-----------------------\");\n\n    // 测试asDoubleStream()方法\n    DoubleStream doubleStream = userList.stream().mapToInt(User::getAge).asDoubleStream();\n    doubleStream.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试asLongStream()方法\n    LongStream longStream = userList.stream().mapToInt(User::getAge).asLongStream();\n    longStream.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试average()方法\n    OptionalDouble average = userList.stream().mapToInt(User::getAge).average();\n    System.out.println(\"用户评价年龄为：\" + average.orElse(-1));\n    System.out.println(\"-----------------------\");\n\n    // 测试boxed()方法\n    Stream<Integer> boxed = userList.stream().mapToInt(User::getAge).boxed();\n    System.out.println(\"通过装箱的Stream统计数量：\" + boxed.count());\n    System.out.println(\"-----------------------\");\n\n    // 测试builder()方法\n    IntStream build1 = IntStream.builder().add(1).add(2).add(3).build();\n    System.out.println(\"遍历通过builder()方法创建的IntStream元素：\");\n    build1.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试collect()方法\n    Supplier<List<Integer>> supplier = new Supplier<List<Integer>>() {\n        @Override\n        public List<Integer> get() {\n            return new ArrayList<>();\n        }\n    };\n    ObjIntConsumer<List<Integer>> accumulator = new ObjIntConsumer<List<Integer>>() {\n        @Override\n        public void accept(List<Integer> list, int value) {\n            if (value > 20) {\n                list.add(value);\n            }\n        }\n    };\n    BiConsumer<List<Integer>, List<Integer>> combiner = new BiConsumer<List<Integer>, List<Integer>>() {\n        @Override\n        public void accept(List<Integer> list1, List<Integer> list2) {\n            list1.addAll(list2);\n        }\n    };\n    List<Integer> collect = userList.stream()\n            .mapToInt(User::getAge)\n            .collect(supplier, accumulator, combiner);\n    System.out.println(\"列举所有大于20的年龄：\");\n    System.out.println(collect);\n    System.out.println(\"-----------------------\");\n\n    // 测试concat()方法\n    System.out.println(\"打印两个连接起来的IntStream元素：\");\n    IntStream.concat(userList.stream().mapToInt(User::getAge), IntStream.of(1, 2, 3, 4, 5)).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试count()方法\n    long count = userList.stream().mapToInt(User::getAge).count();\n    System.out.println(\"流中元素的总数：\");\n    System.out.println(count);\n    System.out.println(\"-----------------------\");\n\n    // 测试distinct()方法\n    System.out.println(\"打印去重后的年龄：\");\n    userList.stream().mapToInt(User::getAge).distinct().forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试empty()方法\n    System.out.println(\"获取一个空的IntStream：\");\n    IntStream empty = IntStream.empty();\n    System.out.println(empty);\n    System.out.println(\"-----------------------\");\n\n    // 测试filter()方法\n    System.out.println(\"过滤调年龄大于30的用户：\");\n    userList.stream().mapToInt(User::getAge).filter(age -> age <= 30).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试findAny()方法，返回流中任意的一个元素并包装成OptionalInt，结果不稳定\n    int asInteger1 = userList.stream().mapToInt(User::getAge).findAny().orElse(-1);\n    System.out.println(\"返回流中任意元素并包装成OptionalInt：\");\n    System.out.println(asInteger1);\n    System.out.println(\"-----------------------\");\n\n    // 测试findFirst()方法，返回流中第一个元素并包装成OptionalInt，结果稳定\n    double asInteger2 = userList.stream().mapToInt(User::getAge).findFirst().orElse(-1);\n    System.out.println(\"返回流中首个元素并包装成OptionalInt：\");\n    System.out.println(asInteger2);\n    System.out.println(\"-----------------------\");\n\n    // 测试flatMap()方法\n    System.out.println(\"测试flatMap()方法，每人年龄+10岁：\");\n    userList.stream().mapToInt(User::getAge).flatMap(new IntFunction<IntStream>() {\n        @Override\n        public IntStream apply(int value) {\n            return IntStream.of(value + 10);\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试forEach()方法，不保证顺序\n    System.out.println(\"打印每个年龄：\");\n    userList.parallelStream().mapToInt(User::getAge).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试forEachOrdered()方法，保证顺序\n    System.out.println(\"打印每个年龄：\");\n    userList.parallelStream().mapToInt(User::getAge).forEachOrdered(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试generate()方法\n    System.out.println(\"随机生成10个数字：\");\n    Random random = new Random();\n    int[] ints = IntStream.generate(new IntSupplier() {\n        @Override\n        public int getAsInt() {\n            return random.nextInt();\n        }\n    }).limit(10).toArray();\n    System.out.println(Arrays.toString(ints));\n    System.out.println(\"-----------------------\");\n\n    // 测试iterate()方法\n    System.out.println(\"生成10个等差数：\");\n    int[] ints1 = IntStream.iterate(2, new IntUnaryOperator() {\n        @Override\n        public int applyAsInt(int operand) {\n            return operand + 2;\n        }\n    }).limit(10).toArray();\n    System.out.println(Arrays.toString(ints1));\n\n    // 测试iterate()方法\n    PrimitiveIterator.OfInt iterator = userList.stream().mapToInt(User::getAge).iterator();\n    System.out.println(\"通过iterate打印元素：\");\n    while (iterator.hasNext()) {\n        System.out.println(iterator.next());\n    }\n    System.out.println(\"-----------------------\");\n\n    // 测试limit()方法\n    OptionalDouble average1 = userList.stream().mapToInt(User::getAge).limit(3).average();\n    System.out.println(\"求前三个用户的平均年龄：\");\n    System.out.println(average1.orElse(-1));\n    System.out.println(\"-----------------------\");\n\n    // 测试map()方法\n    System.out.println(\"将所有年龄+20岁：\");\n    userList.stream().mapToInt(User::getAge).map(new IntUnaryOperator() {\n        @Override\n        public int applyAsInt(int operand) {\n            return operand + 20;\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapToInt()方法\n    System.out.println(\"将所有年龄映射为整型：\");\n    userList.stream().mapToInt(User::getAge).mapToDouble(new IntToDoubleFunction() {\n        @Override\n        public double applyAsDouble(int value) {\n            return value;\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapToLong()方法\n    System.out.println(\"将所有年龄映射为长整型：\");\n    userList.stream().mapToInt(User::getAge).mapToLong(new IntToLongFunction() {\n        @Override\n        public long applyAsLong(int value) {\n            return value;\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapToObj()方法\n    System.out.println(\"将所有年龄映射为用户：\");\n    userList.stream().mapToInt(User::getAge).mapToObj(new IntFunction<User>() {\n        @Override\n        public User apply(int value) {\n            return User.builder().age((int) value).build();\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试max()方法\n    double maxAge = userList.stream().mapToInt(User::getAge).max().orElse(-1);\n    System.out.println(\"获取最大的年龄：\");\n    System.out.println(maxAge);\n    System.out.println(\"-----------------------\");\n\n    // 测试min()方法\n    double minAge = userList.stream().mapToInt(User::getAge).min().orElse(-1);\n    System.out.println(\"获取最小的年龄：\");\n    System.out.println(minAge);\n    System.out.println(\"-----------------------\");\n\n    // 测试noneMatch()方法\n    System.out.println(\"返回是否没有年龄大于100的用户：\");\n    boolean noneMatch = userList.stream().mapToInt(User::getAge).noneMatch(new IntPredicate() {\n        @Override\n        public boolean test(int value) {\n            return value > 100;\n        }\n    });\n    System.out.println(noneMatch);\n    System.out.println(\"-----------------------\");\n\n\n    // 测试of()方法\n    System.out.println(\"打印生成的多个元素序列：\");\n    IntStream.of(1, 2, 3, 4, 5).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试of()方法\n    System.out.println(\"打印生成的单个元素序列：\");\n    IntStream.of(1).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试parallel()方法\n    System.out.println(\"返回并发流：\");\n    System.out.println(userList.stream().mapToInt(User::getAge).parallel());\n    System.out.println(\"-----------------------\");\n\n    // 测试peek()方法，是一个中间操作，主要用于调试\n    System.out.println(\"打印流中的每个元素：\");\n    userList.stream().mapToInt(User::getAge).peek(new IntConsumer() {\n        @Override\n        public void accept(int value) {\n            System.out.println(value);\n        }\n    }).sum();\n    System.out.println(\"-----------------------\");\n\n    // 测试range()方法，不包含最后一个值\n    System.out.println(\"生成1~10的序列：\");\n    IntStream range = IntStream.range(1, 11);\n    range.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试rangeClosed()方法，包含最后一个值\n    System.out.println(\"生成1~10的序列：\");\n    IntStream rangeClosed = IntStream.rangeClosed(1, 10);\n    rangeClosed.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试reduce()方法，首个元素为流的第一个元素\n    System.out.println(\"求年龄和：\");\n    int v = userList.stream().mapToInt(User::getAge).reduce(new IntBinaryOperator() {\n        @Override\n        public int applyAsInt(int left, int right) {\n            return left + right;\n        }\n    }).orElse(-1);\n    System.out.println(v);\n    System.out.println(\"-----------------------\");\n\n    // 测试reduce()方法，首个元素为identity（即第一个参数）\n    System.out.println(\"求年龄和：\");\n    int sum = userList.stream().mapToInt(User::getAge).reduce(0, new IntBinaryOperator() {\n        @Override\n        public int applyAsInt(int left, int right) {\n            return left + right;\n        }\n    });\n    System.out.println(sum);\n    System.out.println(\"-----------------------\");\n\n    // 测试sequential()方法\n    System.out.println(\"返回顺序流：\");\n    System.out.println(userList.parallelStream().mapToInt(User::getAge).sequential());\n    System.out.println(\"-----------------------\");\n\n    // 测试skip()方法\n    System.out.println(\"跳过前三个元素：\");\n    userList.stream().mapToInt(User::getAge).skip(3).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试sorted()方法\n    System.out.println(\"按年龄大小排序：\");\n    userList.stream().mapToInt(User::getAge).sorted().forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试sum()方法\n    double sum1 = userList.stream().mapToInt(User::getAge).sum();\n    System.out.println(\"求年龄总和：\");\n    System.out.println(sum1);\n    System.out.println(\"-----------------------\");\n\n\n    // 测试summaryStatistics()方法，返回各种摘要信息\n    IntSummaryStatistics statistics = userList.stream().mapToInt(User::getAge).summaryStatistics();\n    System.out.println(\"和：\" + statistics.getSum());\n    System.out.println(\"数量：\" + statistics.getCount());\n    System.out.println(\"最大值：\" + statistics.getMax());\n    System.out.println(\"最小值：\" + statistics.getMin());\n    System.out.println(\"平均值：\" + statistics.getAverage());\n    System.out.println(\"-----------------------\");\n\n    // 测试toArray()方法\n    System.out.println(\"转换为double数组：\");\n    int[] doubles2 = userList.stream().mapToInt(User::getAge).toArray();\n    System.out.println(Arrays.toString(doubles2));\n    System.out.println(\"-----------------------\");\n}\n```\n\n控制台输出：\n\n```Plain\n是否所有用户都小于50岁：true\n-----------------------\n是否存在年龄小于10岁的用户：false\n-----------------------\n18.0\n28.0\n32.0\n21.0\n21.0\n-----------------------\n18\n28\n32\n21\n21\n-----------------------\n用户评价年龄为：24.0\n-----------------------\n通过装箱的Stream统计数量：5\n-----------------------\n遍历通过builder()方法创建的IntStream元素：\n1\n2\n3\n-----------------------\n列举所有大于20的年龄：\n[28, 32, 21, 21]\n-----------------------\n打印两个连接起来的IntStream元素：\n18\n28\n32\n21\n21\n1\n2\n3\n4\n5\n-----------------------\n流中元素的总数：\n5\n-----------------------\n打印去重后的年龄：\n18\n28\n32\n21\n-----------------------\n获取一个空的IntStream：\njava.util.stream.IntPipeline$Head@17a7cec2\n-----------------------\n过滤调年龄大于30的用户：\n18\n28\n21\n21\n-----------------------\n返回流中任意元素并包装成OptionalInt：\n18\n-----------------------\n返回流中首个元素并包装成OptionalInt：\n18.0\n-----------------------\n测试flatMap()方法，每人年龄+10岁：\n28\n38\n42\n31\n31\n-----------------------\n打印每个年龄：\n32\n21\n21\n28\n18\n-----------------------\n打印每个年龄：\n18\n28\n32\n21\n21\n-----------------------\n随机生成10个数字：\n[-225057879, 13099014, 1942130014, -1649359025, -831199561, 1727527066, -1937714752, -1356532121, -507030166, 457144123]\n-----------------------\n生成10个等差数：\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n通过iterate打印元素：\n18\n28\n32\n21\n21\n-----------------------\n求前三个用户的平均年龄：\n26.0\n-----------------------\n将所有年龄+20岁：\n38\n48\n52\n41\n41\n-----------------------\n将所有年龄映射为整型：\n18.0\n28.0\n32.0\n21.0\n21.0\n-----------------------\n将所有年龄映射为长整型：\n18\n28\n32\n21\n21\n-----------------------\n将所有年龄映射为用户：\nUser(age=18, height=null, weight=null, username=null)\nUser(age=28, height=null, weight=null, username=null)\nUser(age=32, height=null, weight=null, username=null)\nUser(age=21, height=null, weight=null, username=null)\nUser(age=21, height=null, weight=null, username=null)\n-----------------------\n获取最大的年龄：\n32.0\n-----------------------\n获取最小的年龄：\n18.0\n-----------------------\n返回是否没有年龄大于100的用户：\ntrue\n-----------------------\n打印生成的多个元素序列：\n1\n2\n3\n4\n5\n-----------------------\n打印生成的单个元素序列：\n1\n-----------------------\n返回并发流：\njava.util.stream.ReferencePipeline$4@506c589e\n-----------------------\n打印流中的每个元素：\n18\n28\n32\n21\n21\n-----------------------\n生成1~10的序列：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n-----------------------\n生成1~10的序列：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n-----------------------\n求年龄和：\n120\n-----------------------\n求年龄和：\n120\n-----------------------\n返回顺序流：\njava.util.stream.ReferencePipeline$4@67424e82\n-----------------------\n跳过前三个元素：\n21\n21\n-----------------------\n按年龄大小排序：\n18\n21\n21\n28\n32\n-----------------------\n求年龄总和：\n120.0\n-----------------------\n和：120\n数量：5\n最大值：32\n最小值：18\n平均值：24.0\n-----------------------\n转换为double数组：\n[18, 28, 32, 21, 21]\n-----------------------\n```\n\n### IntStream.Builder\n\nIntStream.Builder是IntStream是构建器，IntStream.Builder具有生命周期，其从构建阶段开始，在该阶段期间可以添加元素，然后转换到内置阶段，之后可能不添加元素。构建阶段从调用build()方法开始，它创建一个有序流，其元素是添加到流构建器的元素，按照它们被添加的顺序。\n\nIntStream.Builder提供以下方法：\n\n| **方法类型及返回值**      | **方法名称**  | **描述**                           |\n| ------------------------- | ------------- | ---------------------------------- |\n| void                      | accept(int t) | 向要构建的流添加元素。             |\n| default IntStream.Builder | add(int t)    | 向要构建的流添加元素。             |\n| IntStream                 | build()       | 构建流，将此构建器转换为内置状态。 |\n\n测试方法：\n\n```Java\nprivate static void test6(List<User> userList) {\n    // 测试builder()方法\n    IntStream build1 = IntStream.builder().add(1).add(2).add(3).build();\n    System.out.println(\"遍历通过builder()方法创建的IntStream元素：\");\n    build1.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n}\n```\n\n控制台输出：\n\n```Plain\n遍历通过builder()方法创建的IntStream元素：\n1\n2\n3\n-----------------------\n```\n\nIntStream.Builderd的accept(double t)方法只在IntStreamBuilderImpl中有实现，IntStreamBuilderImpl在两个地方有用法：\n\n1. IntStream的builder()方法：\n\n```Java\n/**\n* 返回IntStreamBuilderImpl实例\n*/\npublic static Builder builder() {\n    return new Streams.IntStreamBuilderImpl();\n}\n```\n\n2. IntStream的of()方法：\n\n```Java\n/**\n* 返回具有单个元素的IntStream \n*/\npublic static IntStream of(int t) {\n    return StreamSupport.intStream(new Streams.IntStreamBuilderImpl(t), false);\n}\n```\n\n### LongStream\n\nLongStream支持顺序和并行聚合操作的原始long值元素序列，是long原始专长Stream。\n\nLongStream有以下方法：\n\n| **方法类型及返回值**      | **方法名称**                                                 | **描述**                                                     |\n| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| boolean                   | allMatch(LongPredicate predicate)                            | 返回此流的所有元素是否与提供的谓词匹配。                     |\n| boolean                   | anyMatch(LongPredicate predicate)                            | 返回此流的任何元素是否与提供的谓词匹配。                     |\n| DoubleStream              | asDoubleStream()                                             | 返回一个 DoubleStream由该流中的元素，转换为 double 。        |\n| OptionalDouble            | average()                                                    | 返回 OptionalDouble此流的元素的算术平均值的OptionalDouble，如果此流为空，则返回一个空的可选项。 |\n| Stream<Long>              | boxed()                                                      | 返回一个 Stream由该流的盒装到所述的元件，每个的 Long 。      |\n| static LongStream.Builder | builder()                                                    | 返回一个 LongStream的生成器。                                |\n| <R> R                     | collect(Supplier<R> supplier, ObjLongConsumer<R> accumulator, BiConsumer<R,R> combiner) | 对此流的元素执行mutable reduction操作。                      |\n| static LongStream         | concat(LongStream a, LongStream b)                           | 创建一个懒惰连接的流，其元素是第一个流的所有元素，后跟第二个流的所有元素。 |\n| long                      | count()                                                      | 返回此流中的元素数。                                         |\n| LongStream                | distinct()                                                   | 返回由该流的不同元素组成的流。                               |\n| static LongStream         | empty()                                                      | 返回一个空的顺序 LongStream 。                               |\n| LongStream                | filter(LongPredicate predicate)                              | 返回由与此给定谓词匹配的此流的元素组成的流。                 |\n| OptionalLong              | findAny()                                                    | 返回描述流的一些元素的OptionalLong如果流为空，则返回一个空的OptionalLong 。 |\n| OptionalLong              | findFirst()                                                  | 返回描述此流的第一个元素的OptionalLong如果流为空，则返回空的OptionalLong 。 |\n| LongStream                | flatMap(LongFunction<? extends LongStream> mapper)           | 返回由通过将提供的映射函数应用于每个元素而产生的映射流的内容来替换该流的每个元素的结果的流。 |\n| void                      | forEach(LongConsumer action)                                 | 对此流的每个元素执行操作。                                   |\n| void                      | forEachOrdered(LongConsumer action)                          | 对此流的每个元素执行一个操作，保证每个元素按遇到顺序处理，以便具有定义的遇到顺序的流。 |\n| static LongStream         | generate(LongSupplier s)                                     | 返回无限顺序无序流，其中每个元素由提供的 LongSupplier 。     |\n| static LongStream         | iterate(long seed, LongUnaryOperator f)                      | 返回有序无限连续 LongStream由函数的迭代应用产生 f至初始元素 seed ，产生 Stream包括 seed ， f(seed) ， f(f(seed)) ，等 |\n| PrimitiveIterator.OfLong  | iterator()                                                   | 返回此流的元素的迭代器。                                     |\n| LongStream                | limit(long maxSize)                                          | 返回由此流的元素组成的流，截断长度不能超过 maxSize 。        |\n| LongStream                | map(LongUnaryOperator mapper)                                | 返回由给定函数应用于此流的元素的结果组成的流。               |\n| DoubleStream              | mapToDouble(LongToDoubleFunction mapper)                     | 返回一个 DoubleStream ，其中包含将给定函数应用于此流的元素的结果。 |\n| IntStream                 | mapToInt(LongToIntFunction mapper)                           | 返回一个 IntStream ，其中包含将给定函数应用于此流的元素的结果。 |\n| <U> Stream<U>             | mapToObj(LongFunction<? extends U> mapper)                   | 返回一个对象值 Stream ，其中包含将给定函数应用于此流的元素的结果。 |\n| OptionalLong              | max()                                                        | 返回 OptionalLong此流的最大元素的OptionalLong，如果此流为空，则返回一个空的可选项。 |\n| OptionalLong              | min()                                                        | 返回 OptionalLong此流的最小元素的OptionalLong，如果此流为空，则返回一个空的可选项。 |\n| boolean                   | noneMatch(LongPredicate predicate)                           | 返回此流的元素是否与提供的谓词匹配。                         |\n| static LongStream         | of(long... values)                                           | 返回其元素是指定值的顺序排序流。                             |\n| static LongStream         | of(long t)                                                   | 返回包含单个元素的顺序 LongStream 。                         |\n| LongStream                | parallel()                                                   | 返回平行的等效流。                                           |\n| LongStream                | peek(LongConsumer action)                                    | 返回由该流的元素组成的流，另外在从生成的流中消耗元素时对每个元素执行提供的操作。 |\n| static LongStream         | range(long startInclusive, long endExclusive) 。             | 返回有序的顺序 LongStream从 startInclusive （含）至 endExclusive通过增量步骤（独家） 1 |\n| static LongStream         | rangeClosed(long startInclusive, long endInclusive)          | 返回有序顺序 LongStream从 startInclusive （含）至 endInclusive通过的递增步长（含） 1 。 |\n| OptionalLong              | reduce(LongBinaryOperator op)                                | 使用 associative累积功能对此流的元素执行reduction ，并返回描述减小值的 OptionalLong （如果有）。 |\n| long                      | reduce(long identity, LongBinaryOperator op)                 | 使用提供的身份值和associative累积功能对此流的元素执行reduction ，并返回减小的值。 |\n| LongStream                | sequential()                                                 | 返回顺序的等效流。                                           |\n| LongStream                | skip(long n)                                                 | 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。       |\n| LongStream                | sorted()                                                     | 以排序顺序返回由该流的元素组成的流。                         |\n| Spliterator.OfLong        | spliterator()                                                | 返回此流的元素的拼接器。                                     |\n| long                      | sum()                                                        | 返回此流中元素的总和。                                       |\n| LongSummaryStatistics     | summaryStatistics()                                          | 返回一个 LongSummaryStatistics描述有关此流的元素的各种摘要数据。 |\n| long[]                    | toArray()                                                    | 返回一个包含此流的元素的数组。                               |\n\n测试方法：\n\n```Java\nprivate static void test7(List<User> userList) {\n    // 测试allMatch()方法\n    boolean allMatch = userList.stream().mapToLong(User::getAge).allMatch(new LongPredicate() {\n        @Override\n        public boolean test(long age) {\n            return age < 50;\n        }\n    });\n    System.out.println(\"是否所有用户都小于50岁：\" + allMatch);\n    System.out.println(\"-----------------------\");\n\n    // 测试anyMatch()方法\n    boolean anyMatch = userList.stream().mapToLong(User::getAge).anyMatch(new LongPredicate() {\n        @Override\n        public boolean test(long age) {\n            return age < 10;\n        }\n    });\n    System.out.println(\"是否存在年龄小于10岁的用户：\" + anyMatch);\n    System.out.println(\"-----------------------\");\n\n    // 测试asDoubleStream()方法\n    DoubleStream doubleStream = userList.stream().mapToLong(User::getAge).asDoubleStream();\n    doubleStream.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n\n    // 测试average()方法\n    OptionalDouble average = userList.stream().mapToLong(User::getAge).average();\n    System.out.println(\"用户评价年龄为：\" + average.orElse(-1));\n    System.out.println(\"-----------------------\");\n\n    // 测试boxed()方法\n    Stream<Long> boxed = userList.stream().mapToLong(User::getAge).boxed();\n    System.out.println(\"通过装箱的Stream统计数量：\" + boxed.count());\n    System.out.println(\"-----------------------\");\n\n    // 测试builder()方法\n    LongStream build1 = LongStream.builder().add(1).add(2).add(3).build();\n    System.out.println(\"遍历通过builder()方法创建的LongStream元素：\");\n    build1.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试collect()方法\n    Supplier<List<Long>> supplier = new Supplier<List<Long>>() {\n        @Override\n        public List<Long> get() {\n            return new ArrayList<>();\n        }\n    };\n    ObjLongConsumer<List<Long>> accumulator = new ObjLongConsumer<List<Long>>() {\n        @Override\n        public void accept(List<Long> list, long value) {\n            if (value > 20) {\n                list.add(value);\n            }\n        }\n    };\n    BiConsumer<List<Long>, List<Long>> combiner = new BiConsumer<List<Long>, List<Long>>() {\n        @Override\n        public void accept(List<Long> list1, List<Long> list2) {\n            list1.addAll(list2);\n        }\n    };\n    List<Long> collect = userList.stream()\n            .mapToLong(User::getAge)\n            .collect(supplier, accumulator, combiner);\n    System.out.println(\"列举所有大于20的年龄：\");\n    System.out.println(collect);\n    System.out.println(\"-----------------------\");\n\n    // 测试concat()方法\n    System.out.println(\"打印两个连接起来的LongStream元素：\");\n    LongStream.concat(userList.stream().mapToLong(User::getAge), LongStream.of(1, 2, 3, 4, 5)).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试count()方法\n    long count = userList.stream().mapToLong(User::getAge).count();\n    System.out.println(\"流中元素的总数：\");\n    System.out.println(count);\n    System.out.println(\"-----------------------\");\n\n    // 测试distinct()方法\n    System.out.println(\"打印去重后的年龄：\");\n    userList.stream().mapToLong(User::getAge).distinct().forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试empty()方法\n    System.out.println(\"获取一个空的LongStream：\");\n    LongStream empty = LongStream.empty();\n    System.out.println(empty);\n    System.out.println(\"-----------------------\");\n\n    // 测试filter()方法\n    System.out.println(\"过滤调年龄大于30的用户：\");\n    userList.stream().mapToLong(User::getAge).filter(age -> age <= 30).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试findAny()方法，返回流中任意的一个元素并包装成OptionalLong，结果不稳定\n    long asInteger1 = userList.stream().mapToLong(User::getAge).findAny().orElse(-1);\n    System.out.println(\"返回流中任意元素并包装成OptionalLong：\");\n    System.out.println(asInteger1);\n    System.out.println(\"-----------------------\");\n\n    // 测试findFirst()方法，返回流中第一个元素并包装成OptionalInt，结果稳定\n    long asInteger2 = userList.stream().mapToLong(User::getAge).findFirst().orElse(-1);\n    System.out.println(\"返回流中首个元素并包装成OptionalLong：\");\n    System.out.println(asInteger2);\n    System.out.println(\"-----------------------\");\n\n    // 测试flatMap()方法\n    System.out.println(\"测试flatMap()方法，每人年龄+10岁：\");\n    userList.stream().mapToLong(User::getAge).flatMap(new LongFunction<LongStream>() {\n        @Override\n        public LongStream apply(long value) {\n            return LongStream.of(value + 10);\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试forEach()方法，不保证顺序\n    System.out.println(\"打印每个年龄：\");\n    userList.parallelStream().mapToLong(User::getAge).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试forEachOrdered()方法，保证顺序\n    System.out.println(\"打印每个年龄：\");\n    userList.parallelStream().mapToLong(User::getAge).forEachOrdered(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试generate()方法\n    System.out.println(\"随机生成10个数字：\");\n    Random random = new Random();\n    long[] longs = LongStream.generate(new LongSupplier() {\n        @Override\n        public long getAsLong() {\n            return random.nextInt();\n        }\n    }).limit(10).toArray();\n    System.out.println(Arrays.toString(longs));\n    System.out.println(\"-----------------------\");\n\n    // 测试iterate()方法\n    System.out.println(\"生成10个等差数：\");\n    long[] longs1 = LongStream.iterate(2, new LongUnaryOperator() {\n        @Override\n        public long applyAsLong(long operand) {\n            return operand + 2;\n\n        }\n    }).limit(10).toArray();\n    System.out.println(Arrays.toString(longs1));\n\n    // 测试iterate()方法\n    PrimitiveIterator.OfLong iterator = userList.stream().mapToLong(User::getAge).iterator();\n    System.out.println(\"通过iterate打印元素：\");\n    while (iterator.hasNext()) {\n        System.out.println(iterator.next());\n    }\n    System.out.println(\"-----------------------\");\n\n    // 测试limit()方法\n    OptionalDouble average1 = userList.stream().mapToLong(User::getAge).limit(3).average();\n    System.out.println(\"求前三个用户的平均年龄：\");\n    System.out.println(average1.orElse(-1));\n    System.out.println(\"-----------------------\");\n\n    // 测试map()方法\n    System.out.println(\"将所有年龄+20岁：\");\n    userList.stream().mapToLong(User::getAge).map(new LongUnaryOperator() {\n        @Override\n        public long applyAsLong(long operand) {\n            return operand + 20;\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapToInt()方法\n    System.out.println(\"将所有年龄映射为整型：\");\n    userList.stream().mapToLong(User::getAge).mapToInt(new LongToIntFunction() {\n        @Override\n        public int applyAsInt(long value) {\n            return (int)value;\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapToDouble()方法\n    System.out.println(\"将所有年龄映射为浮点型：\");\n    userList.stream().mapToLong(User::getAge).mapToDouble(new LongToDoubleFunction() {\n        @Override\n        public double applyAsDouble(long value) {\n            return value;\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapToObj()方法\n    System.out.println(\"将所有年龄映射为用户：\");\n    userList.stream().mapToLong(User::getAge).mapToObj(new LongFunction<User>() {\n        @Override\n        public User apply(long value) {\n            return User.builder().age((int) value).build();\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试max()方法\n    double maxAge = userList.stream().mapToLong(User::getAge).max().orElse(-1);\n    System.out.println(\"获取最大的年龄：\");\n    System.out.println(maxAge);\n    System.out.println(\"-----------------------\");\n\n    // 测试min()方法\n    double minAge = userList.stream().mapToLong(User::getAge).min().orElse(-1);\n    System.out.println(\"获取最小的年龄：\");\n    System.out.println(minAge);\n    System.out.println(\"-----------------------\");\n\n    // 测试noneMatch()方法\n    System.out.println(\"返回是否没有年龄大于100的用户：\");\n    boolean noneMatch = userList.stream().mapToLong(User::getAge).noneMatch(new LongPredicate() {\n        @Override\n        public boolean test(long value) {\n            return value > 100;\n        }\n    });\n    System.out.println(noneMatch);\n    System.out.println(\"-----------------------\");\n\n\n    // 测试of()方法\n    System.out.println(\"打印生成的多个元素序列：\");\n    LongStream.of(1, 2, 3, 4, 5).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试of()方法\n    System.out.println(\"打印生成的单个元素序列：\");\n    LongStream.of(1).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试parallel()方法\n    System.out.println(\"返回并发流：\");\n    System.out.println(userList.stream().mapToLong(User::getAge).parallel());\n    System.out.println(\"-----------------------\");\n\n    // 测试peek()方法，是一个中间操作，主要用于调试\n    System.out.println(\"打印流中的每个元素：\");\n    userList.stream().mapToLong(User::getAge).peek(new LongConsumer() {\n        @Override\n        public void accept(long value) {\n            System.out.println(value);\n        }\n    }).sum();\n    System.out.println(\"-----------------------\");\n\n    // 测试range()方法，不包含最后一个值\n    System.out.println(\"生成1~10的序列：\");\n    LongStream range = LongStream.range(1, 11);\n    range.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试rangeClosed()方法，包含最后一个值\n    System.out.println(\"生成1~10的序列：\");\n    LongStream rangeClosed = LongStream.rangeClosed(1, 10);\n    rangeClosed.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试reduce()方法，首个元素为流的第一个元素\n    System.out.println(\"求年龄和：\");\n    long v = userList.stream().mapToLong(User::getAge).reduce(new LongBinaryOperator() {\n        @Override\n        public long applyAsLong(long left, long right) {\n            return left + right;\n        }\n    }).orElse(-1);\n    System.out.println(v);\n    System.out.println(\"-----------------------\");\n\n    // 测试reduce()方法，首个元素为identity（即第一个参数）\n    System.out.println(\"求年龄和：\");\n    long sum = userList.stream().mapToLong(User::getAge).reduce(0, new LongBinaryOperator() {\n        @Override\n        public long applyAsLong(long left, long right) {\n            return left + right;\n        }\n    });\n    System.out.println(sum);\n    System.out.println(\"-----------------------\");\n\n    // 测试sequential()方法\n    System.out.println(\"返回顺序流：\");\n    System.out.println(userList.parallelStream().mapToLong(User::getAge).sequential());\n    System.out.println(\"-----------------------\");\n\n    // 测试skip()方法\n    System.out.println(\"跳过前三个元素：\");\n    userList.stream().mapToLong(User::getAge).skip(3).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试sorted()方法\n    System.out.println(\"按年龄大小排序：\");\n    userList.stream().mapToLong(User::getAge).sorted().forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试sum()方法\n    double sum1 = userList.stream().mapToLong(User::getAge).sum();\n    System.out.println(\"求年龄总和：\");\n    System.out.println(sum1);\n    System.out.println(\"-----------------------\");\n\n    // 测试summaryStatistics()方法，返回各种摘要信息\n    LongSummaryStatistics statistics = userList.stream().mapToLong(User::getAge).summaryStatistics();\n    System.out.println(\"和：\" + statistics.getSum());\n    System.out.println(\"数量：\" + statistics.getCount());\n    System.out.println(\"最大值：\" + statistics.getMax());\n    System.out.println(\"最小值：\" + statistics.getMin());\n    System.out.println(\"平均值：\" + statistics.getAverage());\n    System.out.println(\"-----------------------\");\n\n    // 测试toArray()方法\n    System.out.println(\"转换为long数组：\");\n    long[] longs2 = userList.stream().mapToLong(User::getAge).toArray();\n    System.out.println(Arrays.toString(longs2));\n    System.out.println(\"-----------------------\");\n}\n```\n\n控制台输出：\n\n```Plain\n是否所有用户都小于50岁：true\n-----------------------\n是否存在年龄小于10岁的用户：false\n-----------------------\n18.0\n28.0\n32.0\n21.0\n21.0\n-----------------------\n用户评价年龄为：24.0\n-----------------------\n通过装箱的Stream统计数量：5\n-----------------------\n遍历通过builder()方法创建的LongStream元素：\n1\n2\n3\n-----------------------\n列举所有大于20的年龄：\n[28, 32, 21, 21]\n-----------------------\n打印两个连接起来的LongStream元素：\n18\n28\n32\n21\n21\n1\n2\n3\n4\n5\n-----------------------\n流中元素的总数：\n5\n-----------------------\n打印去重后的年龄：\n18\n28\n32\n21\n-----------------------\n获取一个空的LongStream：\njava.util.stream.LongPipeline$Head@70177ecd\n-----------------------\n过滤调年龄大于30的用户：\n18\n28\n21\n21\n-----------------------\n返回流中任意元素并包装成OptionalLong：\n18\n-----------------------\n返回流中首个元素并包装成OptionalLong：\n18\n-----------------------\n测试flatMap()方法，每人年龄+10岁：\n28\n38\n42\n31\n31\n-----------------------\n打印每个年龄：\n32\n21\n21\n28\n18\n-----------------------\n打印每个年龄：\n18\n28\n32\n21\n21\n-----------------------\n随机生成10个数字：\n[544954945, -857768077, -207128286, 69120021, 793453961, -7796011, 549982729, 1902220118, 1969892020, 354573389]\n-----------------------\n生成10个等差数：\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n通过iterate打印元素：\n18\n28\n32\n21\n21\n-----------------------\n求前三个用户的平均年龄：\n26.0\n-----------------------\n将所有年龄+20岁：\n38\n48\n52\n41\n41\n-----------------------\n将所有年龄映射为整型：\n18\n28\n32\n21\n21\n-----------------------\n将所有年龄映射为浮点型：\n18.0\n28.0\n32.0\n21.0\n21.0\n-----------------------\n将所有年龄映射为用户：\nUser(age=18, height=null, weight=null, username=null)\nUser(age=28, height=null, weight=null, username=null)\nUser(age=32, height=null, weight=null, username=null)\nUser(age=21, height=null, weight=null, username=null)\nUser(age=21, height=null, weight=null, username=null)\n-----------------------\n获取最大的年龄：\n32.0\n-----------------------\n获取最小的年龄：\n18.0\n-----------------------\n返回是否没有年龄大于100的用户：\ntrue\n-----------------------\n打印生成的多个元素序列：\n1\n2\n3\n4\n5\n-----------------------\n打印生成的单个元素序列：\n1\n-----------------------\n返回并发流：\njava.util.stream.ReferencePipeline$5@5ce65a89\n-----------------------\n打印流中的每个元素：\n18\n28\n32\n21\n21\n-----------------------\n生成1~10的序列：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n-----------------------\n生成1~10的序列：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n-----------------------\n求年龄和：\n120\n-----------------------\n求年龄和：\n120\n-----------------------\n返回顺序流：\njava.util.stream.ReferencePipeline$5@799f7e29\n-----------------------\n跳过前三个元素：\n21\n21\n-----------------------\n按年龄大小排序：\n18\n21\n21\n28\n32\n-----------------------\n求年龄总和：\n120.0\n-----------------------\n和：120\n数量：5\n最大值：32\n最小值：18\n平均值：24.0\n-----------------------\n转换为long数组：\n[18, 28, 32, 21, 21]\n-----------------------\n```\n\n### LongStream.Builder\n\nLongStream.Builder是LongStream是构建器，LongStream.Builder具有生命周期，其从构建阶段开始，在该阶段期间可以添加元素，然后转换到内置阶段，之后可能不添加元素。构建阶段从调用build()方法开始，它创建一个有序流，其元素是添加到流构建器的元素，按照它们被添加的顺序。\n\nLongStream.Builder提供以下方法：\n\n| **方法类型及返回值**       | **方法名称**   | **描述**                           |\n| -------------------------- | -------------- | ---------------------------------- |\n| void                       | accept(long t) | 向要构建的流添加元素。             |\n| default LongStream.Builder | add(long t)    | 向要构建的流添加元素。             |\n| LongStream                 | build()        | 构建流，将此构建器转换为内置状态。 |\n\n测试方法：\n\n```Java\nprivate static void test8(List<User> userList) {\n    // 测试builder()方法\n    LongStream build1 = LongStream.builder().add(1).add(2).add(3).build();\n    System.out.println(\"遍历通过builder()方法创建的LongStream元素：\");\n    build1.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n}\n```\n\n控制台输出：\n\n```Plain\n遍历通过builder()方法创建的LongStream元素：\n1\n2\n3\n-----------------------\n```\n\nLongStream.Builderd的accept(double t)方法只在LongStreamBuilderImpl中有实现，LongStreamBuilderImpl在两个地方有用法：\n\n1. LongStream的builder()方法：\n\n```Java\n/**\n* 返回LongStreamBuilderImpl实例\n*/\npublic static Builder builder() {\n    return new Streams.LongStreamBuilderImpl();\n}\n```\n\n2. LongStream的of()方法：\n\n```Java\n/**\n* 返回具有单个元素的LongStream \n*/\npublic static LongStream of(long t) {\n    return StreamSupport.longStream(new Streams.LongStreamBuilderImpl(t), false);\n}\n```\n\n### Stream\n\n支持顺序和并行聚合操作的一系列元素。以下示例说明了使用Stream和IntStream的汇总操作：\n\n```Java\nint sum = widgets.stream().filter(w -> w.getColor() == RED).mapToInt(w -> w.getWeight()).sum();  \n```\n\n在这个例子中，widgets是Collection<Widget>。我们通过Collection.stream()创建一个Widget对象的流，过滤它以产生仅包含红色小部件的流，然后将其转换为表示每个红色小部件的权重的int值。然后将该流相加以产生总重量。\n\n除了Stream为对象引用的流，还存在IntStream、LongStream和DoubleStream。\n\n为了执行计算，流operations被组合成**pipelines**。  pipelines由源（其可以是数组、集合、生成函数、I/O通道等）组成，零个或多个**中间操作**（其将流转换成另一个流，例如filter(Predicate)）以及**终端操作**（产生结果或副作用，如count()或forEach(Consumer)）。流具有**懒惰性**，源数据上的计算仅在终端操作启动时执行，源元素仅在需要时才被使用。\n\n集合和流，具有一些表面上的相似之处，但具有不同的目标。集合主要关注其元素的有效管理和访问。相比之下，流不提供直接访问或操纵其元素的手段，而是关心描述其源和将在该源上进行聚合的计算操作。但是，如果提供的流操作不提供所需的功能，则可以使用BaseStream.iterator()和BaseStream.spliterator()操作来执行受控遍历。\n\n**pipelines**，如上面的“小部件”示例，可以被视为流源上的**查询** 。除非源是明确设计用于并发修改（例如ConcurrentHashMap），否则在查询流源时可能会导致不可预测或错误的行为。\n\n大多数流操作接受用户指定行为的参数，例如上面示例中传递给mapToInt的lambda表达式w->w.getWeight() 。为了保持正确的行为，这些**行为参数** ：\n\n- 必须是non-interfering（他们不修改流源）。\n- 在大多数情况下必须是stateless（它们的结果不应该取决于在pipelines的执行期间可能改变的任何状态）。\n\n这些参数始终是functional interface的实例，例如Function，并且通常是lambda表达式或方法引用。除非另有说明，否则这些参数必须**为非空值** 。\n\n一个流应该只操作一次（调用中间或终端流操作）。例如，这排除了“分叉”流，即同一个源提供两个或多个管道，或同一流的多次遍历。如果流实现检测到流正在被重用，它可能会抛出IllegalStateException。然而，由于一些流操作可能返回它们的接收器而不是新的流对象，因此不可能在所有情况下都检测到重用。\n\nStreams有一个BaseStream.close()方法并实现了AutoCloseable，但几乎所有的流实例在使用后都不需要关闭。通常，只有源为IO通道的流（例如由Files.lines（Path，Charset）返回的流）才需要关闭。大多数流都由集合、数组或生成函数支持，这些函数不需要特殊的资源管理。（如果流确实需要关闭，则可以在try-with-resources语句中将其声明为资源。）\n\n流管道可以按顺序执行，也可以并行执行。此执行模式是流的一个属性。流是通过顺序执行或并行执行的初始选择创建的。（例如，Collection.stream()创建一个顺序流，Collection.sparallelStream()创建并行流。）这种执行模式的选择可以通过BaseStream.sequential()或BaseStream.parallel()方法进行修改，也可以使用BaseStream.isParallel()判断是否为并行流。\n\nStream有以下方法：\n\n| **方法类型及返回值**         | **方法名称**                                                 | **描述**                                                     |\n| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| boolean                      | allMatch(Predicate<? super T> predicate)                     | 返回此流的所有元素是否与提供的谓词匹配。                     |\n| boolean                      | anyMatch(Predicate<? super T> predicate)                     | 返回此流的任何元素是否与提供的谓词匹配。                     |\n| static <T> Stream.Builder<T> | builder()                                                    | 返回一个Stream的构建器。                                     |\n| <R,A> R                      | collect(Collector<? super T,A,R> collector)                  | 使用Collector对此流的元素执行mutable reduction Collector 。  |\n| <R> R                        | collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner) | 对此流的元素执行mutable reduction操作。                      |\n| static <T> Stream<T>         | concat(Stream<? extends T> a, Stream<? extends T> b)         | 创建一个懒惰连接的流，其元素是第一个流的所有元素，后跟第二个流的所有元素。 |\n| long                         | count()                                                      | 返回此流中的元素数。                                         |\n| Stream<T>                    | distinct()                                                   | 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流。 |\n| static <T> Stream<T>         | empty()                                                      | 返回一个空的顺序Stream 。                                    |\n| Stream<T>                    | filter(Predicate<? super T> predicate)                       | 返回由与此给定谓词匹配的此流的元素组成的流。                 |\n| Optional<T>                  | findAny()                                                    | 返回描述流的一些元素的Optional如果流为空，则返回一个空的Optional 。 |\n| Optional<T>                  | findFirst()                                                  | 返回描述此流的第一个元素的Optional如果流为空，则返回一个空的Optional 。 |\n| <R> Stream<R>                | flatMap(Function<? super T,? extends Stream<? extends R>> mapper) | 返回由通过将提供的映射函数应用于每个元素而产生的映射流的内容来替换该流的每个元素的结果的流。 |\n| DoubleStream                 | flatMapToDouble(Function<? super T,? extends DoubleStream> mapper) | 返回一个DoubleStream ，其中包含将该流的每个元素替换为通过将提供的映射函数应用于每个元素而产生的映射流的内容的结果。 |\n| IntStream                    | flatMapToInt(Function<? super T,? extends IntStream> mapper) | 返回一个 IntStream ，其中包含将该流的每个元素替换为通过将提供的映射函数应用于每个元素而产生的映射流的内容的结果。 |\n| LongStream                   | flatMapToLong(Function<? super T,? extends LongStream> mapper) | 返回一个 LongStream ，其中包含将该流的每个元素替换为通过将提供的映射函数应用于每个元素而产生的映射流的内容的结果。 |\n| void                         | forEach(Consumer<? super T> action)                          | 对此流的每个元素执行操作。                                   |\n| void                         | forEachOrdered(Consumer<? super T> action)                   | 如果流具有定义的遇到顺序，则以流的遇到顺序对该流的每个元素执行操作。 |\n| static <T> Stream<T>         | generate(Supplier<T> s)                                      | 返回无限顺序无序流，其中每个元素由提供的 Supplier 。         |\n| static <T> Stream<T>         | iterate(T seed, UnaryOperator<T> f)                          | 返回有序无限连续 Stream由函数的迭代应用产生 f至初始元素 seed ，产生 Stream包括seed，f(seed) ，f(f(seed)) ，等 |\n| Stream<T>                    | limit(long maxSize)                                          | 返回由此流的元素组成的流，截短长度不能超过maxSize 。         |\n| <R> Stream<R>                | map(Function<? super T,? extends R> mapper)                  | 返回由给定函数应用于此流的元素的结果组成的流。               |\n| DoubleStream                 | mapToDouble(ToDoubleFunction<? super T> mapper)              | 返回一个DoubleStream ，其中包含将给定函数应用于此流的元素的结果。 |\n| IntStream                    | mapToInt(ToIntFunction<? super T> mapper)                    | 返回一个IntStream ，其中包含将给定函数应用于此流的元素的结果。 |\n| LongStream                   | mapToLong(ToLongFunction<? super T> mapper)                  | 返回一个LongStream ，其中包含将给定函数应用于此流的元素的结果。 |\n| Optional<T>                  | max(Comparator<? super T> comparator)                        | 根据提供的 Comparator返回此流的最大元素。                    |\n| Optional<T>                  | min(Comparator<? super T> comparator)                        | 根据提供的 Comparator返回此流的最小元素。                    |\n| boolean                      | noneMatch(Predicate<? super T> predicate)                    | 返回此流的元素是否与提供的谓词匹配。                         |\n| static <T> Stream<T>         | of(T... values)                                              | 返回其元素是指定值的顺序排序流。                             |\n| static <T> Stream<T>         | of(T t)                                                      | 返回包含单个元素的顺序Stream 。                              |\n| Stream<T>                    | peek(Consumer<? super T> action)                             | 返回由该流的元素组成的流，另外在从生成的流中消耗元素时对每个元素执行提供的操作。 |\n| Optional<T>                  | reduce(BinaryOperator<T> accumulator)                        | 使用associative累积函数对此流的元素执行reduction，并返回描述减小值的Optional（如果有）。 |\n| T                            | reduce(T identity, BinaryOperator<T> accumulator)            | 使用提供的身份值和associative累积功能对此流的元素执行 reduction，并返回减小的值。 |\n| <U> U                        | reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner) | 执行reduction在此流中的元素，使用所提供的身份，积累和组合功能。 |\n| Stream<T>                    | skip(long n)                                                 | 在丢弃流的第一个n元素后，返回由该流的n元素组成的流。         |\n| Stream<T>                    | sorted()                                                     | 返回由此流的元素组成的流，根据自然顺序排序。                 |\n| Stream<T>                    | sorted(Comparator<? super T> comparator)                     | 返回由该流的元素组成的流，根据提供的Comparator进行排序。     |\n| Object[]                     | toArray()                                                    | 返回一个包含此流的元素的数组。                               |\n| <A> A[]                      | toArray(IntFunction<A[]> generator)                          | 使用提供的generator函数返回一个包含此流的元素的数组，以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组。 |\n\n测试方法：\n\n```Java\nprivate static void test9(List<User> userList) {\n    // 测试allMatch()方法\n    boolean allMatch = userList.stream().allMatch(new Predicate<User>() {\n        @Override\n        public boolean test(User user) {\n            return user.getAge() < 35 && user.getHeight() > 180;\n        }\n    });\n    System.out.println(\"是否所有用户年龄都小于35岁且身高大于180cm：\");\n    System.out.println(allMatch);\n    System.out.println(\"-----------------------\");\n\n    // 测试anyMatch()方法\n    boolean anyMatch = userList.stream().anyMatch(new Predicate<User>() {\n        @Override\n        public boolean test(User user) {\n            return user.getAge() < 35 && user.getHeight() > 180;\n        }\n    });\n    System.out.println(\"是否存在年龄小于35岁且身高大于180cm的用户：\");\n    System.out.println(anyMatch);\n    System.out.println(\"-----------------------\");\n\n    // 测试builder()方法\n    Stream<User> build = Stream.<User>builder()\n            .add(User.builder().username(\"a\").age(1).height(165.0).weight(100.0).build())\n            .add(User.builder().username(\"b\").age(2).height(175.0).weight(110.0).build())\n            .add(User.builder().username(\"c\").age(3).height(185.0).weight(120.0).build())\n            .build();\n    System.out.println(\"使用builder()方法构建流：\");\n    build.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试collect()方法\n    Map<Integer, List<User>> collect = userList.stream().collect(Collectors.groupingBy(new Function<User, Integer>() {\n        @Override\n        public Integer apply(User user) {\n            return user.getAge();\n        }\n    }));\n    System.out.println(\"根据年龄进行分组：\");\n    System.out.println(collect);\n    System.out.println(\"-----------------------\");\n\n    // 测试collect()方法\n    Map<Integer, List<User>> collect1 = userList.stream().collect(\n            new Supplier<Map<Integer, List<User>>>() {\n                @Override\n                public Map<Integer, List<User>> get() {\n                    return new HashMap<>();\n                }\n            },\n            new BiConsumer<Map<Integer, List<User>>, User>() {\n                @Override\n                public void accept(Map<Integer, List<User>> map, User user) {\n                    map.put(user.getAge(), new ArrayList<User>() {{\n                        add(user);\n                    }});\n                }\n            },\n            new BiConsumer<Map<Integer, List<User>>, Map<Integer, List<User>>>() {\n                @Override\n                public void accept(Map<Integer, List<User>> map1, Map<Integer, List<User>> map2) {\n                    map1.putAll(map2);\n                }\n            }\n    );\n    System.out.println(\"根据年龄进行分组：\");\n    System.out.println(collect1);\n    System.out.println(\"-----------------------\");\n\n    // 测试concat()方法\n    System.out.println(\"打印两个连接起来的Stream元素：\");\n    Stream.concat(userList.stream(), Stream.of(User.builder().username(\"lastuser\").age(1).height(165.0).weight(100.0).build())).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试count()方法\n    System.out.println(\"统计用户数量：\");\n    long count = userList.stream().count();\n    System.out.println(count);\n    System.out.println(\"-----------------------\");\n\n    // 测试distinct()方法 根据Object.equals(Object)方法去重，对象需要重写equals方法\n    System.out.println(\"去重后打印：\");\n    userList.stream().distinct().forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试empty()方法\n    Stream<User> empty = Stream.empty();\n    System.out.println(\"返回引用对象为User类型的空流：\");\n    System.out.println(empty);\n    System.out.println(\"-----------------------\");\n\n    // 测试filter()方法\n    System.out.println(\"过滤掉年龄大于等于35岁的用户：\");\n    userList.stream().filter(new Predicate<User>() {\n        @Override\n        public boolean test(User user) {\n            return user.getAge() < 35;\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试findAny()方法，返回流中任意的一个元素，结果不稳定\n    User user = userList.stream().findAny().orElse(User.builder().build());\n    System.out.println(\"返回流中任意一个元素：\");\n    System.out.println(user);\n    System.out.println(\"-----------------------\");\n\n    // 测试findFirst()方法，返回流中第一个元素，结果稳定\n    User user1 = userList.stream().findAny().orElse(User.builder().build());\n    System.out.println(\"返回流中首个元素：\");\n    System.out.println(user1);\n    System.out.println(\"-----------------------\");\n\n    // 测试flatMap()方法\n    System.out.println(\"测试flatMap()方法，每人年龄+10岁：\");\n    userList.stream().flatMap(new Function<User, Stream<?>>() {\n        @Override\n        public Stream<?> apply(User user) {\n            user.setAge(user.getAge() + 10);\n            return Stream.of(user);\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试flatMapToDouble()方法\n    System.out.println(\"测试flatMapToDouble()方法：\");\n    userList.stream().flatMapToDouble(new Function<User, DoubleStream>() {\n        @Override\n        public DoubleStream apply(User user) {\n            return DoubleStream.of(user.getHeight());\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试flatMapToInt()方法\n    System.out.println(\"flatMapToInt()方法：\");\n    userList.stream().flatMapToInt(new Function<User, IntStream>() {\n        @Override\n        public IntStream apply(User user) {\n            return IntStream.of(user.getAge());\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试flatMapToLong()方法\n    System.out.println(\"flatMapToLong()方法：\");\n    userList.stream().flatMapToLong(new Function<User, LongStream>() {\n        @Override\n        public LongStream apply(User user) {\n            return LongStream.of(user.getAge());\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试forEach()方法，不保证顺序\n    System.out.println(\"打印每个年龄：\");\n    userList.parallelStream().forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试forEachOrdered()方法，保证顺序\n    System.out.println(\"打印每个年龄：\");\n    userList.parallelStream().forEachOrdered(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试generate()方法\n    System.out.println(\"随机生成10个数字：\");\n    Random random = new Random();\n    Object[] objects1 = Stream.<Long>generate(new Supplier<Long>() {\n        @Override\n        public Long get() {\n            return random.nextLong();\n        }\n    }).limit(10).toArray();\n    System.out.println(Arrays.toString(objects1));\n    System.out.println(\"-----------------------\");\n\n    // 测试iterate()方法\n    System.out.println(\"生成10个等差数：\");\n    Object[] objects2 = Stream.iterate(2, new UnaryOperator<Integer>() {\n        @Override\n        public Integer apply(Integer op) {\n            return op + 2;\n        }\n    }).limit(10).toArray();\n    System.out.println(Arrays.toString(objects2));\n\n    // 测试iterate()方法\n    Iterator<User> iterator = userList.stream().iterator();\n    System.out.println(\"通过iterate打印元素：\");\n    while (iterator.hasNext()) {\n        System.out.println(iterator.next());\n    }\n    System.out.println(\"-----------------------\");\n\n    // 测试limit()方法\n    System.out.println(\"求前三个用户：\");\n    userList.stream().limit(3).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试map()方法\n    System.out.println(\"将所有年龄+20岁：\");\n    userList.stream().map(new Function<User, User>() {\n        @Override\n        public User apply(User user) {\n            user.setAge(user.getAge() + 20);\n            return user;\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapToDouble()方法\n    System.out.println(\"获取所有用户身高：\");\n    userList.stream().mapToDouble(new ToDoubleFunction<User>() {\n        @Override\n        public double applyAsDouble(User value) {\n            return value.getHeight();\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapToInt()方法\n    System.out.println(\"获取所有用户年龄：\");\n    userList.stream().mapToInt(new ToIntFunction<User>() {\n        @Override\n        public int applyAsInt(User value) {\n            return value.getAge();\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapToInt()方法\n    System.out.println(\"获取所有用户年龄：\");\n    userList.stream().mapToInt(new ToIntFunction<User>() {\n        @Override\n        public int applyAsInt(User value) {\n            return value.getAge();\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapToLong()方法\n    System.out.println(\"获取所有用户年龄：\");\n    userList.stream().mapToLong(new ToLongFunction<User>() {\n        @Override\n        public long applyAsLong(User value) {\n            return value.getAge();\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试max()方法\n    User max = userList.stream().max(new Comparator<User>() {\n        @Override\n        public int compare(User o1, User o2) {\n            return o1.getAge() - o2.getAge();\n        }\n    }).orElse(User.builder().age(-1).build());\n    System.out.println(\"获取最大的年龄：\");\n    System.out.println(max.getAge());\n    System.out.println(\"-----------------------\");\n\n    // 测试min()方法\n    User min = userList.stream().min(new Comparator<User>() {\n        @Override\n        public int compare(User o1, User o2) {\n            return o1.getAge() - o2.getAge();\n        }\n    }).orElse(User.builder().age(-1).build());\n    System.out.println(\"获取最小的年龄：\");\n    System.out.println(min.getAge());\n    System.out.println(\"-----------------------\");\n\n    // 测试noneMatch()方法\n    System.out.println(\"返回是否没有年龄大于100的用户：\");\n    boolean noneMatch = userList.stream().noneMatch(new Predicate<User>() {\n        @Override\n        public boolean test(User user) {\n            return user.getAge() > 100;\n        }\n    });\n    System.out.println(noneMatch);\n    System.out.println(\"-----------------------\");\n\n    // 测试of()方法\n    System.out.println(\"打印生成的多个元素序列：\");\n    Stream.of(\n            User.builder().username(\"zhangsan\").age(13).height(163.0).weight(45.0).build(),\n            User.builder().username(\"lisi\").age(13).height(163.0).weight(45.0).build(),\n            User.builder().username(\"wangwu\").age(13).height(163.0).weight(45.0).build(),\n            User.builder().username(\"zhaoliu\").age(13).height(163.0).weight(45.0).build()\n    ).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试of()方法\n    System.out.println(\"打印生成的单个元素序列：\");\n    Stream.of(User.builder().username(\"zhangsan\").age(13).height(163.0).weight(45.0).build()).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试parallel()方法\n    System.out.println(\"返回并发流：\");\n    System.out.println(userList.stream().parallel());\n    System.out.println(\"-----------------------\");\n\n    // 测试peek()方法，是一个中间操作，主要用于调试\n    System.out.println(\"打印流中的每个元素：\");\n    userList.stream().peek(new Consumer<User>() {\n        @Override\n        public void accept(User user) {\n            System.out.println(user);\n        }\n    }).count();\n    System.out.println(\"-----------------------\");\n\n    // 测试reduce()方法，首个元素为流的第一个元素\n    System.out.println(\"求年龄和：\");\n    Optional<User> reduce = userList.stream().reduce(new BinaryOperator<User>() {\n        @Override\n        public User apply(User user, User user2) {\n            return User.builder().age(user.getAge() + user2.getAge()).build();\n        }\n    });\n    System.out.println(reduce.get());\n    System.out.println(\"-----------------------\");\n\n    // 测试reduce()方法，首个元素为identity（即第一个参数）\n    System.out.println(\"求年龄和：\");\n    User reduce1 = userList.stream().reduce(User.builder().age(0).build(), new BinaryOperator<User>() {\n        @Override\n        public User apply(User user, User user2) {\n            return User.builder().age(user.getAge() + user2.getAge()).build();\n        }\n    });\n    System.out.println(reduce1);\n    System.out.println(\"-----------------------\");\n\n    // 测试sequential()方法\n    System.out.println(\"返回顺序流：\");\n    System.out.println(userList.parallelStream().sequential());\n    System.out.println(\"-----------------------\");\n\n    // 测试skip()方法\n    System.out.println(\"跳过前三个元素：\");\n    userList.stream().skip(3).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n    // 测试sorted()方法\n    System.out.println(\"按年龄大小排序：\");\n    userList.stream().sorted(new Comparator<User>() {\n        @Override\n        public int compare(User o1, User o2) {\n            return o1.getAge() - o2.getAge();\n        }\n    }).forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n\n\n    // 测试toArray()方法\n    System.out.println(\"转换为User数组：\");\n    Object[] objects = userList.stream().toArray();\n    System.out.println(Arrays.toString(objects));\n    System.out.println(\"-----------------------\");\n\n    // 测试toArray()方法\n    System.out.println(\"转换为User数组：\");\n    User[] as = userList.stream().<User>toArray(new IntFunction<User[]>() {\n        @Override\n        public User[] apply(int value) {\n            return new User[value];\n        }\n    });\n    System.out.println(Arrays.toString(as));\n    System.out.println(\"-----------------------\");\n}\n```\n\n控制台输出：\n\n```Plain\n是否所有用户年龄都小于35岁且身高大于180cm：\nfalse\n-----------------------\n是否存在年龄小于35岁且身高大于180cm的用户：\nfalse\n-----------------------\n使用builder()方法构建流：\nUser(age=1, height=165.0, weight=100.0, username=a)\nUser(age=2, height=175.0, weight=110.0, username=b)\nUser(age=3, height=185.0, weight=120.0, username=c)\n-----------------------\n根据年龄进行分组：\n{32=[User(age=32, height=180.0, weight=79.0, username=wangwu)], 18=[User(age=18, height=160.0, weight=50.0, username=zhangsan)], 21=[User(age=21, height=162.0, weight=70.0, username=zhangsan), User(age=21, height=169.0, weight=72.0, username=zhaoliu), User(age=21, height=169.0, weight=72.0, username=zhaoliu)], 28=[User(age=28, height=172.0, weight=56.0, username=lisi)]}\n-----------------------\n根据年龄进行分组：\n{32=[User(age=32, height=180.0, weight=79.0, username=wangwu)], 18=[User(age=18, height=160.0, weight=50.0, username=zhangsan)], 21=[User(age=21, height=169.0, weight=72.0, username=zhaoliu)], 28=[User(age=28, height=172.0, weight=56.0, username=lisi)]}\n-----------------------\n打印两个连接起来的Stream元素：\nUser(age=18, height=160.0, weight=50.0, username=zhangsan)\nUser(age=28, height=172.0, weight=56.0, username=lisi)\nUser(age=32, height=180.0, weight=79.0, username=wangwu)\nUser(age=21, height=162.0, weight=70.0, username=zhangsan)\nUser(age=21, height=169.0, weight=72.0, username=zhaoliu)\nUser(age=21, height=169.0, weight=72.0, username=zhaoliu)\nUser(age=1, height=165.0, weight=100.0, username=lastuser)\n-----------------------\n统计用户数量：\n6\n-----------------------\n去重后打印：\nUser(age=18, height=160.0, weight=50.0, username=zhangsan)\nUser(age=28, height=172.0, weight=56.0, username=lisi)\nUser(age=32, height=180.0, weight=79.0, username=wangwu)\nUser(age=21, height=162.0, weight=70.0, username=zhangsan)\nUser(age=21, height=169.0, weight=72.0, username=zhaoliu)\n-----------------------\n返回引用对象为User类型的空流：\njava.util.stream.ReferencePipeline$Head@312b1dae\n-----------------------\n过滤掉年龄大于等于35岁的用户：\nUser(age=18, height=160.0, weight=50.0, username=zhangsan)\nUser(age=28, height=172.0, weight=56.0, username=lisi)\nUser(age=32, height=180.0, weight=79.0, username=wangwu)\nUser(age=21, height=162.0, weight=70.0, username=zhangsan)\nUser(age=21, height=169.0, weight=72.0, username=zhaoliu)\nUser(age=21, height=169.0, weight=72.0, username=zhaoliu)\n-----------------------\n返回流中任意一个元素：\nUser(age=18, height=160.0, weight=50.0, username=zhangsan)\n-----------------------\n返回流中首个元素：\nUser(age=18, height=160.0, weight=50.0, username=zhangsan)\n-----------------------\n测试flatMap()方法，每人年龄+10岁：\nUser(age=28, height=160.0, weight=50.0, username=zhangsan)\nUser(age=38, height=172.0, weight=56.0, username=lisi)\nUser(age=42, height=180.0, weight=79.0, username=wangwu)\nUser(age=31, height=162.0, weight=70.0, username=zhangsan)\nUser(age=31, height=169.0, weight=72.0, username=zhaoliu)\nUser(age=31, height=169.0, weight=72.0, username=zhaoliu)\n-----------------------\n测试flatMapToDouble()方法：\n160.0\n172.0\n180.0\n162.0\n169.0\n169.0\n-----------------------\nflatMapToInt()方法：\n28\n38\n42\n31\n31\n31\n-----------------------\nflatMapToLong()方法：\n28\n38\n42\n31\n31\n31\n-----------------------\n打印每个年龄：\nUser(age=31, height=162.0, weight=70.0, username=zhangsan)\nUser(age=31, height=169.0, weight=72.0, username=zhaoliu)\nUser(age=31, height=169.0, weight=72.0, username=zhaoliu)\nUser(age=42, height=180.0, weight=79.0, username=wangwu)\nUser(age=38, height=172.0, weight=56.0, username=lisi)\nUser(age=28, height=160.0, weight=50.0, username=zhangsan)\n-----------------------\n打印每个年龄：\nUser(age=28, height=160.0, weight=50.0, username=zhangsan)\nUser(age=38, height=172.0, weight=56.0, username=lisi)\nUser(age=42, height=180.0, weight=79.0, username=wangwu)\nUser(age=31, height=162.0, weight=70.0, username=zhangsan)\nUser(age=31, height=169.0, weight=72.0, username=zhaoliu)\nUser(age=31, height=169.0, weight=72.0, username=zhaoliu)\n-----------------------\n随机生成10个数字：\n[1615966171823288384, -7259602941028351229, -8753231398543192414, -5934361928967435957, -8657526691897631118, 3475987589712582957, -7014446858359418156, -2699681240803486737, -5644722432246409033, -5677493669317247050]\n-----------------------\n生成10个等差数：\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n通过iterate打印元素：\nUser(age=28, height=160.0, weight=50.0, username=zhangsan)\nUser(age=38, height=172.0, weight=56.0, username=lisi)\nUser(age=42, height=180.0, weight=79.0, username=wangwu)\nUser(age=31, height=162.0, weight=70.0, username=zhangsan)\nUser(age=31, height=169.0, weight=72.0, username=zhaoliu)\nUser(age=31, height=169.0, weight=72.0, username=zhaoliu)\n-----------------------\n求前三个用户：\nUser(age=28, height=160.0, weight=50.0, username=zhangsan)\nUser(age=38, height=172.0, weight=56.0, username=lisi)\nUser(age=42, height=180.0, weight=79.0, username=wangwu)\n-----------------------\n将所有年龄+20岁：\nUser(age=48, height=160.0, weight=50.0, username=zhangsan)\nUser(age=58, height=172.0, weight=56.0, username=lisi)\nUser(age=62, height=180.0, weight=79.0, username=wangwu)\nUser(age=51, height=162.0, weight=70.0, username=zhangsan)\nUser(age=51, height=169.0, weight=72.0, username=zhaoliu)\nUser(age=51, height=169.0, weight=72.0, username=zhaoliu)\n-----------------------\n获取所有用户身高：\n160.0\n172.0\n180.0\n162.0\n169.0\n169.0\n-----------------------\n获取所有用户年龄：\n48\n58\n62\n51\n51\n51\n-----------------------\n获取所有用户年龄：\n48\n58\n62\n51\n51\n51\n-----------------------\n获取所有用户年龄：\n48\n58\n62\n51\n51\n51\n-----------------------\n获取最大的年龄：\n62\n-----------------------\n获取最小的年龄：\n48\n-----------------------\n返回是否没有年龄大于100的用户：\ntrue\n-----------------------\n打印生成的多个元素序列：\nUser(age=13, height=163.0, weight=45.0, username=zhangsan)\nUser(age=13, height=163.0, weight=45.0, username=lisi)\nUser(age=13, height=163.0, weight=45.0, username=wangwu)\nUser(age=13, height=163.0, weight=45.0, username=zhaoliu)\n-----------------------\n打印生成的单个元素序列：\nUser(age=13, height=163.0, weight=45.0, username=zhangsan)\n-----------------------\n返回并发流：\njava.util.stream.ReferencePipeline$Head@49c2faae\n-----------------------\n打印流中的每个元素：\nUser(age=48, height=160.0, weight=50.0, username=zhangsan)\nUser(age=58, height=172.0, weight=56.0, username=lisi)\nUser(age=62, height=180.0, weight=79.0, username=wangwu)\nUser(age=51, height=162.0, weight=70.0, username=zhangsan)\nUser(age=51, height=169.0, weight=72.0, username=zhaoliu)\nUser(age=51, height=169.0, weight=72.0, username=zhaoliu)\n-----------------------\n求年龄和：\nUser(age=321, height=null, weight=null, username=null)\n-----------------------\n求年龄和：\nUser(age=321, height=null, weight=null, username=null)\n-----------------------\n返回顺序流：\njava.util.stream.ReferencePipeline$Head@20ad9418\n-----------------------\n跳过前三个元素：\nUser(age=51, height=162.0, weight=70.0, username=zhangsan)\nUser(age=51, height=169.0, weight=72.0, username=zhaoliu)\nUser(age=51, height=169.0, weight=72.0, username=zhaoliu)\n-----------------------\n按年龄大小排序：\nUser(age=48, height=160.0, weight=50.0, username=zhangsan)\nUser(age=51, height=162.0, weight=70.0, username=zhangsan)\nUser(age=51, height=169.0, weight=72.0, username=zhaoliu)\nUser(age=51, height=169.0, weight=72.0, username=zhaoliu)\nUser(age=58, height=172.0, weight=56.0, username=lisi)\nUser(age=62, height=180.0, weight=79.0, username=wangwu)\n-----------------------\n转换为User数组：\n[User(age=48, height=160.0, weight=50.0, username=zhangsan), User(age=58, height=172.0, weight=56.0, username=lisi), User(age=62, height=180.0, weight=79.0, username=wangwu), User(age=51, height=162.0, weight=70.0, username=zhangsan), User(age=51, height=169.0, weight=72.0, username=zhaoliu), User(age=51, height=169.0, weight=72.0, username=zhaoliu)]\n-----------------------\n转换为User数组：\n[User(age=48, height=160.0, weight=50.0, username=zhangsan), User(age=58, height=172.0, weight=56.0, username=lisi), User(age=62, height=180.0, weight=79.0, username=wangwu), User(age=51, height=162.0, weight=70.0, username=zhangsan), User(age=51, height=169.0, weight=72.0, username=zhaoliu), User(age=51, height=169.0, weight=72.0, username=zhaoliu)]\n-----------------------\n```\n\n### Stream.Builder\n\nStream.Builder是Stream是构建器，Stream.Builder具有生命周期，其从构建阶段开始，在该阶段期间可以添加元素，然后转换到内置阶段，之后可能不添加元素。构建阶段从调用build()方法开始，它创建一个有序流，其元素是添加到流构建器的元素，按照它们被添加的顺序。\n\nStream.Builder提供以下方法：\n\n| **方法类型及返回值**       | **方法名称**   | **描述**                           |\n| -------------------------- | -------------- | ---------------------------------- |\n| void                       | accept(long t) | 向要构建的流添加元素。             |\n| default LongStream.Builder | add(long t)    | 向要构建的流添加元素。             |\n| LongStream                 | build()        | 构建流，将此构建器转换为内置状态。 |\n\n测试方法：\n\n```Java\nprivate static void test10(List<User> userList) {\n    // 测试builder()方法\n    Stream build = Stream.<User>builder()\n            .add(User.builder().username(\"zhangsan\").build())\n            .add(User.builder().username(\"lisi\").build())\n            .add(User.builder().username(\"wangwu\").build())\n            .add(User.builder().username(\"zhaoliu\").build())\n            .build();\n    System.out.println(\"遍历通过builder()方法创建的Stream元素：\");\n    build.forEach(System.out::println);\n    System.out.println(\"-----------------------\");\n}\n```\n\n控制台输出：\n\n```Plain\n遍历通过builder()方法创建的Stream元素：\nUser(age=null, height=null, weight=null, username=zhangsan)\nUser(age=null, height=null, weight=null, username=lisi)\nUser(age=null, height=null, weight=null, username=wangwu)\nUser(age=null, height=null, weight=null, username=zhaoliu)\n-----------------------\n```\n\nStream.Builderd的accept(double t)方法只在StreamBuilderImpl中有实现，StreamBuilderImpl在两个地方有用法：\n\n1. Stream的builder()方法：\n\n```Java\n/**\n* 返回StreamBuilderImpl实例\n*/\npublic static<T> Builder<T> builder() {\n    return new Streams.StreamBuilderImpl<>();\n}\n```\n\n2. Stream的of()方法：\n\n```Java\n/**\n* 返回具有单个元素的Stream \n*/\npublic static<T> Stream<T> of(T t) {\n    return StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false);\n}\n```\n\n## 类\n\n### Collectors\n\nCollectors是一个工具类，其中实现了很多的Collect操作供我们使用。\n\nCollectors提供以下方法：\n\n| **方法类型及返回值**                                         | **方法名称**                                                 | **描述**                                                     |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| static <T> Collector<T,?,Double>                             | averagingDouble(ToDoubleFunction<? super T> mapper)          | 返回一个 Collector ，它产生应用于输入元素的双值函数的算术平均值。 |\n| static <T> Collector<T,?,Double>                             | averagingInt(ToIntFunction<? super T> mapper)                | 返回一个 Collector ，它产生应用于输入元素的整数值函数的算术平均值。 |\n| static <T> Collector<T,?,Double>                             | averagingLong(ToLongFunction<? super T> mapper)              | 返回一个 Collector ，它产生应用于输入元素的长值函数的算术平均值。 |\n| static <T,A,R,RR> Collector<T,A,RR>                          | collectingAndThen(Collector<T,A,R> downstream, Function<R,RR> finisher) | 适应 Collector进行额外的整理转换。                           |\n| static <T> Collector<T,?,Long>                               | counting()                                                   | 返回 Collector类型的接受元件 T计数输入元件的数量。           |\n| static <T,K> Collector<T,?,Map<K,List<T>>>                   | groupingBy(Function<? super T,? extends K> classifier)       | 返回 Collector “由基团”上的类型的输入元件操作实现 T ，根据分类功能分组元素，并且在返回的结果 Map 。 |\n| static <T,K,A,D> Collector<T,?,Map<K,D>>                     | groupingBy(Function<? super T,? extends K> classifier, Collector<? super T,A,D> downstream) | 返回 Collector “由基团”上的类型的输入元件操作实现级联 T ，根据分类功能分组元素，然后使用下游的指定执行与给定键相关联的值的归约运算 Collector 。 |\n| static <T,K,D,A,M extends Map<K,D>> Collector<T,?,M>         | groupingBy(Function<? super T,? extends K> classifier, Supplier<M> mapFactory, Collector<? super T,A,D> downstream) | 返回 Collector “由基团”上的类型的输入元件操作实现级联 T ，根据分类功能分组元素，然后使用下游的指定执行与给定键相关联的值的归约运算 Collector 。 |\n| static <T,K> Collector<T,?,ConcurrentMap<K,List<T>>>         | groupingByConcurrent(Function<? super T,? extends K> classifier) | 返回一个并发 Collector “由基团”上的类型的输入元件操作实现 T ，根据分类功能分组元素。 |\n| static <T,K,A,D> Collector<T,?,ConcurrentMap<K,D>>           | groupingByConcurrent(Function<? super T,? extends K> classifier, Collector<? super T,A,D> downstream) | 返回一个并发 Collector “由基团”上的类型的输入元件操作实现级联 T ，根据分类功能分组元素，然后使用下游的指定执行与给定键相关联的值的归约运算 Collector 。 |\n| static <T,K,A,D,M extends ConcurrentMap<K,D>> Collector<T,?,M> | groupingByConcurrent(Function<? super T,? extends K> classifier, Supplier<M> mapFactory, Collector<? super T,A,D> downstream) | 返回一个并发 Collector “由基团”上的类型的输入元件操作实现级联 T ，根据分类功能分组元素，然后使用下游的指定执行与给定键相关联的值的归约运算 Collector 。 |\n| static Collector<CharSequence,?,String>                      | joining()                                                    | 返回一个 Collector ，按照遇到的顺序将输入元素连接到一个 String中。 |\n| static Collector<CharSequence,?,String>                      | joining(CharSequence delimiter)                              | 返回一个 Collector ，按照遇到的顺序连接由指定的分隔符分隔的输入元素。 |\n| static Collector<CharSequence,?,String>                      | joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) | 返回一个 Collector ，它将按照指定的 Collector分隔的输入元素与指定的前缀和后缀进行连接。 |\n| static <T,U,A,R> Collector<T,?,R>                            | mapping(Function<? super T,? extends U> mapper, Collector<? super U,A,R> downstream) | 适应一个 Collector类型的接受元件 U至类型的一个接受元件 T通过积累前应用映射函数到每个输入元素。 |\n| static <T> Collector<T,?,Optional<T>>                        | maxBy(Comparator<? super T> comparator)                      | 返回一个 Collector ，它根据给出的 Comparator产生最大元素，描述为 Optional<T> 。 |\n| static <T> Collector<T,?,Optional<T>>                        | minBy(Comparator<? super T> comparator)                      | 返回一个 Collector ，根据给出的 Comparator产生最小元素，描述为 Optional<T> 。 |\n| static <T> Collector<T,?,Map<Boolean,List<T>>>               | partitioningBy(Predicate<? super T> predicate)               | 返回一个 Collector ，根据Predicate对输入元素进行 Predicate ，并将它们组织成 Map<Boolean, List<T>>。 |\n| static <T,D,A> Collector<T,?,Map<Boolean,D>>                 | partitioningBy(Predicate<? super T> predicate, Collector<? super T,A,D> downstream) | 返回一个 Collector ，它根据Predicate对输入元素进行 Predicate ，根据另一个 Collector减少每个分区的值，并将其组织成 Map<Boolean, D> ，其值是下游缩减的结果。 |\n| static <T> Collector<T,?,Optional<T>>                        | reducing(BinaryOperator<T> op)                               | 返回一个 Collector ，它在指定的 Collector下执行其输入元素的 BinaryOperator 。 |\n| static <T> Collector<T,?,T>                                  | reducing(T identity, BinaryOperator<T> op)                   | 返回 Collector执行下一个指定的减少其输入元件的 BinaryOperator使用所提供的身份。 |\n| static <T,U> Collector<T,?,U>                                | reducing(U identity, Function<? super T,? extends U> mapper, BinaryOperator<U> op) | 返回一个 Collector ，它在指定的映射函数和 BinaryOperator下执行其输入元素的 BinaryOperator。 |\n| static <T> Collector<T,?,DoubleSummaryStatistics>            | summarizingDouble(ToDoubleFunction<? super T> mapper)        | 返回一个 Collector ， double生产映射函数应用于每个输入元素，并返回结果值的汇总统计信息。 |\n| static <T> Collector<T,?,IntSummaryStatistics>               | summarizingInt(ToIntFunction<? super T> mapper)              | 返回一个 Collector ， int生产映射函数应用于每个输入元素，并返回结果值的汇总统计信息。 |\n| static <T> Collector<T,?,LongSummaryStatistics>              | summarizingLong(ToLongFunction<? super T> mapper)            | 返回一个 Collector ， long生产映射函数应用于每个输入元素，并返回结果值的汇总统计信息。 |\n| static <T> Collector<T,?,Double>                             | summingDouble(ToDoubleFunction<? super T> mapper)            | 返回一个 Collector ，它产生应用于输入元素的双值函数的和。    |\n| static <T> Collector<T,?,Integer>                            | summingInt(ToIntFunction<? super T> mapper)                  | 返回一个 Collector ，它产生应用于输入元素的整数值函数的和。  |\n| static <T> Collector<T,?,Long>                               | summingLong(ToLongFunction<? super T> mapper)                | 返回一个 Collector ，它产生应用于输入元素的长值函数的和。    |\n| static <T,C extends Collection<T>> Collector<T,?,C>          | toCollection(Supplier<C> collectionFactory)                  | 返回一个 Collector ，按照遇到的顺序将输入元素累加到一个新的 Collection中。 |\n| static <T,K,U> Collector<T,?,ConcurrentMap<K,U>>             | toConcurrentMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper) | 返回一个并发的 Collector ，它将元素累加到 ConcurrentMap ，其键和值是将所提供的映射函数应用于输入元素的结果。 |\n| static <T,K,U> Collector<T,?,ConcurrentMap<K,U>>             | toConcurrentMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction) | 返回一个并发的 Collector ，它将元素累加到一个 ConcurrentMap ，其键和值是将提供的映射函数应用于输入元素的结果。 |\n| static <T,K,U,M extends ConcurrentMap<K,U>> Collector<T,?,M> | toConcurrentMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapSupplier) | 返回一个并发的 Collector ，它将元素累加到一个 ConcurrentMap ，其键和值是将所提供的映射函数应用于输入元素的结果。 |\n| static <T> Collector<T,?,List<T>>                            | toList()                                                     | 返回一个 Collector ，它将输入元素 List到一个新的 List。      |\n| static <T,K,U> Collector<T,?,Map<K,U>>                       | toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper) | 返回一个 Collector ，它将元素累加到一个 Map ，其键和值是将所提供的映射函数应用于输入元素的结果。 |\n| static <T,K,U> Collector<T,?,Map<K,U>>                       | toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction) | 返回一个 Collector ，它将元素累加到 Map ，其键和值是将提供的映射函数应用于输入元素的结果。 |\n| static <T,K,U,M extends Map<K,U>> Collector<T,?,M>           | toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapSupplier) | 返回一个 Collector ，它将元素累加到一个 Map ，其键和值是将所提供的映射函数应用于输入元素的结果。 |\n| static <T> Collector<T,?,Set<T>>                             | toSet()                                                      | 返回一个 Collector ，将输入元素 Set到一个新的 Set。          |\n\n测试方法：\n\n```Java\nprivate static void test11(List<User> userList) {\n    // 测试averagingDouble()方法\n    Double collect1 = userList.stream().collect(Collectors.averagingDouble(new ToDoubleFunction<User>() {\n        @Override\n        public double applyAsDouble(User value) {\n            return value.getHeight();\n        }\n    }));\n    System.out.println(\"求用户平均身高：\");\n    System.out.println(collect1);\n    System.out.println(\"-----------------------\");\n\n\n    // 测试averagingInt()方法\n    Double collect2 = userList.stream().collect(Collectors.averagingInt(new ToIntFunction<User>() {\n        @Override\n        public int applyAsInt(User value) {\n            return value.getAge();\n        }\n    }));\n    System.out.println(\"求用户平均年龄：\");\n    System.out.println(collect2);\n    System.out.println(\"-----------------------\");\n\n    // 测试averagingLong()方法\n    Double collect3 = userList.stream().collect(Collectors.averagingLong(new ToLongFunction<User>() {\n        @Override\n        public long applyAsLong(User value) {\n            return value.getAge();\n        }\n    }));\n    System.out.println(\"求用户平均年龄：\");\n    System.out.println(collect3);\n    System.out.println(\"-----------------------\");\n\n    // 测试collectingAndThen()方法\n    System.out.println(\"先根据年龄分组，在统计分组数量：\");\n    Integer collect = userList.stream().collect(Collectors.collectingAndThen(Collectors.groupingBy(User::getAge), Map::size));\n    System.out.println(collect);\n    System.out.println(\"-----------------------\");\n\n\n    // 测试counting()方法\n    Long collect4 = userList.stream().collect(Collectors.counting());\n    System.out.println(\"统计用户数量：\");\n    System.out.println(collect4);\n    System.out.println(\"-----------------------\");\n\n    // 测试groupingBy()方法\n    Map<Integer, List<User>> collect5 = userList.stream().collect(Collectors.groupingBy(User::getAge));\n    System.out.println(\"根据用户年龄分组：\");\n    System.out.println(collect5);\n    System.out.println(\"-----------------------\");\n\n    // 测试groupingBy()方法\n    Map<Integer, List<String>> collect6 = userList.stream().collect(Collectors.groupingBy(User::getAge, Collectors.mapping(User::getUsername, Collectors.toList())));\n    System.out.println(\"根据用户年龄分组，再获取姓名列表：\");\n    System.out.println(collect6);\n    System.out.println(\"-----------------------\");\n\n    // 测试groupingBy()方法\n    Map<Integer, List<String>> collect7 = userList.stream().collect(Collectors.groupingBy(User::getAge, HashMap::new, Collectors.mapping(User::getUsername, Collectors.toList())));\n    System.out.println(\"根据用户年龄分组，再获取姓名列表：\");\n    System.out.println(collect7);\n    System.out.println(\"-----------------------\");\n\n    // 测试groupingByConcurrent()方法\n    Map<Integer, List<User>> collect8 = userList.stream().collect(Collectors.groupingByConcurrent(User::getAge));\n    System.out.println(\"根据用户年龄分组：\");\n    System.out.println(collect8);\n    System.out.println(\"-----------------------\");\n\n    // 测试groupingByConcurrent()方法\n    Map<Integer, List<String>> collect9 = userList.stream().collect(Collectors.groupingByConcurrent(User::getAge, Collectors.mapping(User::getUsername, Collectors.toList())));\n    System.out.println(\"根据用户年龄分组，再获取姓名列表：\");\n    System.out.println(collect9);\n    System.out.println(\"-----------------------\");\n\n    // 测试groupingByConcurrent()方法\n    Map<Integer, List<String>> collect10 = userList.stream().collect(Collectors.groupingByConcurrent(User::getAge, ConcurrentHashMap::new, Collectors.mapping(User::getUsername, Collectors.toList())));\n    System.out.println(\"根据用户年龄分组，再获取姓名列表：\");\n    System.out.println(collect10);\n    System.out.println(\"-----------------------\");\n\n    // 测试joining()方法\n    String collect11 = userList.stream().map(User::getUsername).collect(Collectors.joining());\n    System.out.println(\"输出年龄拼接：\");\n    System.out.println(collect11);\n    System.out.println(\"-----------------------\");\n\n    // 测试joining()方法\n    String collect12 = userList.stream().map(User::getUsername).collect(Collectors.joining(\",\"));\n    System.out.println(\"输出年龄拼接，以逗号分割：\");\n    System.out.println(collect12);\n    System.out.println(\"-----------------------\");\n\n    // 测试mapping()方法\n    String collect13 = userList.stream().collect(Collectors.mapping(User::getUsername, Collectors.joining(\",\")));\n    System.out.println(\"输出年龄拼接，以逗号分割：\");\n    System.out.println(collect13);\n    System.out.println(\"-----------------------\");\n\n    // 测试maxBy()方法\n    Optional<User> collect14 = userList.stream().collect(Collectors.maxBy(new Comparator<User>() {\n        @Override\n        public int compare(User o1, User o2) {\n            return o1.getAge() - o2.getAge();\n        }\n    }));\n    System.out.println(\"求年龄最大的用户：\");\n    System.out.println(collect14.get());\n    System.out.println(\"-----------------------\");\n\n    // 测试minBy()方法\n    Optional<User> collect15 = userList.stream().collect(Collectors.minBy(new Comparator<User>() {\n        @Override\n        public int compare(User o1, User o2) {\n            return o1.getAge() - o2.getAge();\n        }\n    }));\n    System.out.println(\"求年龄最小的用户：\");\n    System.out.println(collect15.get());\n    System.out.println(\"-----------------------\");\n\n    // 测试partitioningBy()方法\n    Map<Boolean, List<User>> collect16 = userList.stream().collect(Collectors.partitioningBy(new Predicate<User>() {\n        @Override\n        public boolean test(User user) {\n            return user.getAge() > 30;\n        }\n    }));\n    System.out.println(\"以年龄30岁为分界线：\");\n    System.out.println(collect16);\n    System.out.println(\"-----------------------\");\n\n    // 测试partitioningBy()方法\n    Map<Boolean, Long> collect17 = userList.stream().collect(Collectors.partitioningBy(new Predicate<User>() {\n        @Override\n        public boolean test(User user) {\n            return user.getAge() > 30;\n        }\n    }, Collectors.counting()));\n    System.out.println(\"以年龄30岁为分界线：\");\n    System.out.println(collect17);\n    System.out.println(\"-----------------------\");\n\n    // 测试reducing()方法\n    Optional<User> collect18 = userList.stream().collect(Collectors.reducing(new BinaryOperator<User>() {\n        @Override\n        public User apply(User user, User user2) {\n            return User.builder().age(user.getAge() + user2.getAge()).build();\n        }\n    }));\n    System.out.println(\"求年龄和：\");\n    System.out.println(collect18.get());\n    System.out.println(\"-----------------------\");\n\n    // 测试reducing()方法\n    User collect19 = userList.stream().collect(Collectors.reducing(User.builder().age(0).build(), new BinaryOperator<User>() {\n        @Override\n        public User apply(User user, User user2) {\n            return User.builder().age(user.getAge() + user2.getAge()).build();\n        }\n    }));\n    System.out.println(\"求年龄和：\");\n    System.out.println(collect19);\n    System.out.println(\"-----------------------\");\n\n    // 测试reducing()方法\n    Integer collect20 = userList.stream().collect(\n            Collectors.reducing(0,\n                    new Function<User, Integer>() {\n                        @Override\n                        public Integer apply(User user) {\n                            return user.getAge();\n                        }\n                    },\n                    new BinaryOperator<Integer>() {\n                        @Override\n                        public Integer apply(Integer o, Integer o2) {\n                            return o + o2;\n                        }\n                    }));\n    System.out.println(\"求年龄和：\");\n    System.out.println(collect20);\n    System.out.println(\"-----------------------\");\n\n    // 测试summarizingDouble()方法\n    DoubleSummaryStatistics collect21 = userList.stream().collect(Collectors.summarizingDouble(User::getHeight));\n    System.out.println(\"获取身高统计信息：\");\n    System.out.println(\"最高身高：\" + collect21.getMax());\n    System.out.println(\"身高数量：\" + collect21.getCount());\n    System.out.println(\"平均身高：\" + collect21.getAverage());\n    System.out.println(\"最矮身高：\" + collect21.getMin());\n    System.out.println(\"身高总和：\" + collect21.getSum());\n    System.out.println(\"-----------------------\");\n\n    // 测试summarizingInt()方法\n    IntSummaryStatistics collect22 = userList.stream().collect(Collectors.summarizingInt(User::getAge));\n    System.out.println(\"获取年龄统计信息：\");\n    System.out.println(\"最大年龄：\" + collect22.getMax());\n    System.out.println(\"年龄数量：\" + collect22.getCount());\n    System.out.println(\"平均年龄：\" + collect22.getAverage());\n    System.out.println(\"最低年龄：\" + collect22.getMin());\n    System.out.println(\"年龄总和：\" + collect22.getSum());\n    System.out.println(\"-----------------------\");\n\n\n    // 测试summarizingLong()方法\n    LongSummaryStatistics collect23 = userList.stream().collect(Collectors.summarizingLong(User::getAge));\n    System.out.println(\"获取年龄统计信息：\");\n    System.out.println(\"最大年龄：\" + collect23.getMax());\n    System.out.println(\"年龄数量：\" + collect23.getCount());\n    System.out.println(\"平均年龄：\" + collect23.getAverage());\n    System.out.println(\"最低年龄：\" + collect23.getMin());\n    System.out.println(\"年龄总和：\" + collect23.getSum());\n    System.out.println(\"-----------------------\");\n\n    // 测试summingDouble()方法\n    Double collect24 = userList.stream().collect(Collectors.summingDouble(User::getHeight));\n    System.out.println(\"身高总和：\");\n    System.out.println(collect24);\n    System.out.println(\"-----------------------\");\n\n    // 测试summingInt()方法\n    Integer collect25 = userList.stream().collect(Collectors.summingInt(User::getAge));\n    System.out.println(\"年龄总和：\");\n    System.out.println(collect25);\n    System.out.println(\"-----------------------\");\n\n    // 测试summingInt()方法\n    Long collect26 = userList.stream().collect(Collectors.summingLong(User::getAge));\n    System.out.println(\"年龄总和：\");\n    System.out.println(collect26);\n    System.out.println(\"-----------------------\");\n\n    // 测试toCollection()方法\n    List<User> collect27 = userList.stream().collect(Collectors.<User, List<User>>toCollection(new Supplier<List<User>>() {\n        @Override\n        public List<User> get() {\n            return new ArrayList<>();\n        }\n    }));\n    System.out.println(\"转换为集合：\");\n    System.out.println(collect27);\n    System.out.println(\"-----------------------\");\n\n    // 测试toConcurrentMap()方法\n    ConcurrentMap<Double, String> collect28 = userList.stream().collect(Collectors.<User, Double, String>toConcurrentMap(User::getHeight, User::getUsername));\n    System.out.println(\"转换为并发集合：\");\n    System.out.println(collect28);\n    System.out.println(\"-----------------------\");\n\n    // 测试toConcurrentMap()方法\n    ConcurrentMap<String, Double> collect29 = userList.stream().collect(Collectors.<User, String, Double>toConcurrentMap(User::getUsername, User::getHeight, new BinaryOperator<Double>() {\n        @Override\n        public Double apply(Double s, Double s2) {\n            return s + s2;\n        }\n    }));\n    System.out.println(\"转换为并发集合：\");\n    System.out.println(collect29);\n    System.out.println(\"-----------------------\");\n\n    // 测试toConcurrentMap()方法\n    ConcurrentMap<String, Double> collect30 = userList.stream().collect(Collectors.<User, String, Double, ConcurrentMap<String, Double>>toConcurrentMap(User::getUsername, User::getHeight, new BinaryOperator<Double>() {\n        @Override\n        public Double apply(Double s, Double s2) {\n            return s + s2;\n        }\n    }, new Supplier<ConcurrentMap<String, Double>>() {\n        @Override\n        public ConcurrentMap<String, Double> get() {\n            return new ConcurrentHashMap<>();\n        }\n    }));\n    System.out.println(\"转换为并发集合：\");\n    System.out.println(collect30);\n    System.out.println(\"-----------------------\");\n\n    // 测试toList()方法\n    List<User> collect31 = userList.stream().collect(Collectors.toList());\n    System.out.println(\"转换为列表：\");\n    System.out.println(collect31);\n    System.out.println(\"-----------------------\");\n\n    // 测试toMap()方法\n    Map<Double, String> collect32 = userList.stream().collect(Collectors.toMap(User::getHeight, User::getUsername));\n    System.out.println(\"转换为集合：\");\n    System.out.println(collect32);\n    System.out.println(\"-----------------------\");\n\n    // 测试toMap()方法\n    Map<String, Double> collect33 = userList.stream().collect(Collectors.toMap(User::getUsername, User::getHeight, new BinaryOperator<Double>() {\n        @Override\n        public Double apply(Double aDouble, Double aDouble2) {\n            return aDouble + aDouble2;\n        }\n    }));\n    System.out.println(\"转换为集合：\");\n    System.out.println(collect33);\n    System.out.println(\"-----------------------\");\n\n    // 测试toMap()方法\n    Map<String, Double> collect34 = userList.stream().collect(Collectors.toMap(User::getUsername, User::getHeight, new BinaryOperator<Double>() {\n        @Override\n        public Double apply(Double aDouble, Double aDouble2) {\n            return aDouble + aDouble2;\n        }\n    }, new Supplier<Map<String, Double>>() {\n        @Override\n        public Map<String, Double> get() {\n            return new HashMap<>();\n        }\n    }));\n    System.out.println(\"转换为集合：\");\n    System.out.println(collect34);\n    System.out.println(\"-----------------------\");\n\n    // 测试toMap()方法\n    Set<User> collect35 = userList.stream().collect(Collectors.toSet());\n    System.out.println(\"转换为set集合：\");\n    System.out.println(collect35);\n    System.out.println(\"-----------------------\");\n}\n```\n\n控制台输出：\n\n```Plain\n求用户平均身高：\n168.83333333333334\n-----------------------\n求用户平均年龄：\n23.5\n-----------------------\n求用户平均年龄：\n23.5\n-----------------------\n先根据年龄分组，在统计分组数量：\n4\n-----------------------\n统计用户数量：\n6\n-----------------------\n根据用户年龄分组：\n{32=[User(age=32, height=180.0, weight=79.0, username=wangwu)], 18=[User(age=18, height=160.0, weight=50.0, username=zhangsan)], 21=[User(age=21, height=162.0, weight=70.0, username=zhangsan), User(age=21, height=169.0, weight=72.0, username=zhaoliu), User(age=21, height=170.0, weight=72.0, username=zhaoliu)], 28=[User(age=28, height=172.0, weight=56.0, username=lisi)]}\n-----------------------\n根据用户年龄分组，再获取姓名列表：\n{32=[wangwu], 18=[zhangsan], 21=[zhangsan, zhaoliu, zhaoliu], 28=[lisi]}\n-----------------------\n根据用户年龄分组，再获取姓名列表：\n{32=[wangwu], 18=[zhangsan], 21=[zhangsan, zhaoliu, zhaoliu], 28=[lisi]}\n-----------------------\n根据用户年龄分组：\n{32=[User(age=32, height=180.0, weight=79.0, username=wangwu)], 18=[User(age=18, height=160.0, weight=50.0, username=zhangsan)], 21=[User(age=21, height=162.0, weight=70.0, username=zhangsan), User(age=21, height=169.0, weight=72.0, username=zhaoliu), User(age=21, height=170.0, weight=72.0, username=zhaoliu)], 28=[User(age=28, height=172.0, weight=56.0, username=lisi)]}\n-----------------------\n根据用户年龄分组，再获取姓名列表：\n{32=[wangwu], 18=[zhangsan], 21=[zhangsan, zhaoliu, zhaoliu], 28=[lisi]}\n-----------------------\n根据用户年龄分组，再获取姓名列表：\n{32=[wangwu], 18=[zhangsan], 21=[zhangsan, zhaoliu, zhaoliu], 28=[lisi]}\n-----------------------\n输出年龄拼接：\nzhangsanlisiwangwuzhangsanzhaoliuzhaoliu\n-----------------------\n输出年龄拼接，以逗号分割：\nzhangsan,lisi,wangwu,zhangsan,zhaoliu,zhaoliu\n-----------------------\n输出年龄拼接，以逗号分割：\nzhangsan,lisi,wangwu,zhangsan,zhaoliu,zhaoliu\n-----------------------\n求年龄最大的用户：\nUser(age=32, height=180.0, weight=79.0, username=wangwu)\n-----------------------\n求年龄最小的用户：\nUser(age=18, height=160.0, weight=50.0, username=zhangsan)\n-----------------------\n以年龄30岁为分界线：\n{false=[User(age=18, height=160.0, weight=50.0, username=zhangsan), User(age=28, height=172.0, weight=56.0, username=lisi), User(age=21, height=162.0, weight=70.0, username=zhangsan), User(age=21, height=169.0, weight=72.0, username=zhaoliu), User(age=21, height=170.0, weight=72.0, username=zhaoliu)], true=[User(age=32, height=180.0, weight=79.0, username=wangwu)]}\n-----------------------\n以年龄30岁为分界线：\n{false=5, true=1}\n-----------------------\n求年龄和：\nUser(age=141, height=null, weight=null, username=null)\n-----------------------\n求年龄和：\nUser(age=141, height=null, weight=null, username=null)\n-----------------------\n求年龄和：\n141\n-----------------------\n获取身高统计信息：\n最高身高：180.0\n身高数量：6\n平均身高：168.83333333333334\n最矮身高：160.0\n身高总和：1013.0\n-----------------------\n获取年龄统计信息：\n最大年龄：32\n年龄数量：6\n平均年龄：23.5\n最低年龄：18\n年龄总和：141\n-----------------------\n获取年龄统计信息：\n最大年龄：32\n年龄数量：6\n平均年龄：23.5\n最低年龄：18\n年龄总和：141\n-----------------------\n身高总和：\n1013.0\n-----------------------\n年龄总和：\n141\n-----------------------\n年龄总和：\n141\n-----------------------\n转换为集合：\n[User(age=18, height=160.0, weight=50.0, username=zhangsan), User(age=28, height=172.0, weight=56.0, username=lisi), User(age=32, height=180.0, weight=79.0, username=wangwu), User(age=21, height=162.0, weight=70.0, username=zhangsan), User(age=21, height=169.0, weight=72.0, username=zhaoliu), User(age=21, height=170.0, weight=72.0, username=zhaoliu)]\n-----------------------\n转换为并发集合：\n{160.0=zhangsan, 162.0=zhangsan, 172.0=lisi, 169.0=zhaoliu, 170.0=zhaoliu, 180.0=wangwu}\n-----------------------\n转换为并发集合：\n{lisi=172.0, zhaoliu=339.0, zhangsan=322.0, wangwu=180.0}\n-----------------------\n转换为并发集合：\n{lisi=172.0, zhaoliu=339.0, zhangsan=322.0, wangwu=180.0}\n-----------------------\n转换为列表：\n[User(age=18, height=160.0, weight=50.0, username=zhangsan), User(age=28, height=172.0, weight=56.0, username=lisi), User(age=32, height=180.0, weight=79.0, username=wangwu), User(age=21, height=162.0, weight=70.0, username=zhangsan), User(age=21, height=169.0, weight=72.0, username=zhaoliu), User(age=21, height=170.0, weight=72.0, username=zhaoliu)]\n-----------------------\n转换为集合：\n{162.0=zhangsan, 160.0=zhangsan, 170.0=zhaoliu, 169.0=zhaoliu, 172.0=lisi, 180.0=wangwu}\n-----------------------\n转换为集合：\n{lisi=172.0, zhaoliu=339.0, zhangsan=322.0, wangwu=180.0}\n-----------------------\n转换为集合：\n{lisi=172.0, zhaoliu=339.0, zhangsan=322.0, wangwu=180.0}\n-----------------------\n转换为set集合：\n[User(age=32, height=180.0, weight=79.0, username=wangwu), User(age=21, height=162.0, weight=70.0, username=zhangsan), User(age=21, height=169.0, weight=72.0, username=zhaoliu), User(age=18, height=160.0, weight=50.0, username=zhangsan), User(age=21, height=170.0, weight=72.0, username=zhaoliu), User(age=28, height=172.0, weight=56.0, username=lisi)]\n-----------------------\n```\n\n### StreamSupport\n\nStreamSupport用于创建和操作流的低级实用程序方法。\n\n这个类主要是为库编写人员提供数据结构的流视图，大多数面向最终用户的静态流方法都在各种stream类中。\n\nStreamSupport提供以下方法：\n\n| **方法类型及返回值** | **方法名称**                                                 | **描述**                                                     |\n| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| static DoubleStream  | doubleStream(Spliterator.OfDouble spliterator, boolean parallel) | 创建一个新的串行或并行 DoubleStream从 Spliterator.OfDouble。 |\n| static DoubleStream  | doubleStream(Supplier<? extends Spliterator.OfDouble> supplier, int characteristics, boolean parallel) | 创建一个新的顺序或并行 DoubleStream从 Supplier的 Spliterator.OfDouble。 |\n| static IntStream     | intStream(Spliterator.OfInt spliterator, boolean parallel)   | 创建一个新的串行或并行 IntStream从 Spliterator.OfInt。       |\n| static IntStream     | intStream(Supplier<? extends Spliterator.OfInt> supplier, int characteristics, boolean parallel) | 创建一个新的顺序或并行 IntStream从 Supplier的 Spliterator.OfInt。 |\n| static LongStream    | longStream(Spliterator.OfLong spliterator, boolean parallel) | 创建一个新的串行或并行 LongStream从 Spliterator.OfLong。     |\n| static LongStream    | longStream(Supplier<? extends Spliterator.OfLong> supplier, int characteristics, boolean parallel) | 创建一个新的顺序或并行 LongStream从 Supplier的 Spliterator.OfLong。 |\n| static <T> Stream<T> | stream(Spliterator<T> spliterator, boolean parallel)         | 创建一个新的串行或并行 Stream从 Spliterator。                |\n| static <T> Stream<T> | stream(Supplier<? extends Spliterator<T>> supplier, int characteristics, boolean parallel) | 创建一个新的顺序或并行 Stream从 Supplier的 Spliterator。     |\n\n以构建Steam为例，打开Stream.of()方法：\n\n```Java\npublic static<T> Stream<T> of(T t) {\n    return StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false);\n}\n```\n\n调用的是StreamSupport的stream()方法构造Stream实现。\n\n进入StreamSupport的stream()方法：\n\n```Java\npublic static <T> Stream<T> stream(Spliterator<T> spliterator, boolean parallel) {\n    Objects.requireNonNull(spliterator);\n    return new ReferencePipeline.Head<>(spliterator,\n                                        StreamOpFlag.fromCharacteristics(spliterator),\n                                        parallel);\n}\n```\n\n发现最终返回的是一个ReferencePipeline的静态内部类Head。\n","tags":["java基础"],"categories":["java"]},{"title":"实现一个计算器","url":"/2023/04/22/实现一个计算器.html","content":"\n# 题目描述\n\n实现一个计算器支持+、-、*、/、（、)等，需要支持括号嵌套。\n\n示例 1：\n\n```Plain\n输入：s = 1*2-3*5*8/4+3\n输出：-25\n```\n\n示例 2：\n\n```Plain\n输入：s = 12*4-25+6/(2+(2-1)*2-1)-4*3\n输出：13\n```\n\n示例 3：\n\n```Plain\n输入：s = 12*4-(25+6/(2+(2-1)*2-1)-4*3)\n输出：33\n```\n\n示例 4：\n\n```Plain\n输入：s = 12*4/2-(25+6/(2+(2-1)*2-1)-4*3)\n输出：9\n```\n\n# 我的解法\n\n## 思路\n\n此题与leetcode题库中的 [面试题 16.26. 计算器](https://leetcode.cn/problems/calculator-lcci/description/) 非常类似，不同的是此题需要处理嵌套的括号。一个比较普遍的思路就是首先处理括号，将整个表达式转换为没有括号的算式，再进行计算。\n\n我们使用栈记录已经遍历的字符，当遇到第一个右括号时，说明是第一个嵌套最深的括号，我们依次弹出元素，直到遇到与其匹配的左括号，计算后，再次压入栈中。重复以上步骤，便可处理掉所有括号，接下来再计算算式。\n\n## 代码\n\n```Java\nclass Solution {\n\n    public int calculate(String s) {\n        LinkedList<String> s1 = new LinkedList<>();\n        // 处理括号\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c != ')') {\n                s1.addLast(String.valueOf(c));\n                continue;\n            }\n            StringBuilder sb = new StringBuilder();\n            while (!s1.isEmpty() && !\"(\".equals(s1.getLast())) {\n                sb.append(s1.removeLast());\n            }\n            s1.removeLast();\n            s1.addLast(String.valueOf(calculateNormal(sb.reverse().toString())));\n        }\n        // 去掉括号之后的算式\n        StringBuilder sb = new StringBuilder();\n        s1.forEach(sb::append);\n        return calculateNormal(sb.toString());\n    }\n\n\n    private int calculateNormal(String s) {\n        int num = 0;\n        char preSign = '+';\n        LinkedList<Integer> stack = new LinkedList<>();\n        // 处理+ - * /\n        for (int i = 0; i < s.length(); ++i) {\n            boolean digit = Character.isDigit(s.charAt(i));\n            if (digit) {\n                num = num * 10 + s.charAt(i) - '0';\n            }\n            if (!digit || i == s.length() - 1) {\n                switch (preSign) {\n                    case '+':\n                        stack.push(num);\n                        break;\n                    case '-':\n                        stack.push(-num);\n                        break;\n                    case '*':\n                        stack.push(stack.pop() * num);\n                        break;\n                    default:\n                        stack.push(stack.pop() / num);\n                }\n                preSign = s.charAt(i);\n                num = 0;\n            }\n        }\n        return (int) stack.stream().mapToInt(x -> x).summaryStatistics().getSum();\n    }\n\n}\n```\n\n## 测试\n\n添加测试用例：\n\n```Java\nclass Test {\n    String S;\n    int Expect;\n\n    public Test(String s, int expect) {\n        this.S = s;\n        this.Expect = expect;\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        Test[] testList = new Test[]{\n                new Test(\"1*2-3*5*8/4+3\", 1 * 2 - 3 * 5 * 8 / 4 + 3),\n                new Test(\"12*4-25+6/(2+(2-1)*2-1)-4*3\", 12 * 4 - 25 + 6 / (2 + (2 - 1) * 2 - 1) - 4 * 3),\n                new Test(\"12*4-(25+6/(2+(2-1)*2-1)-4*3)\", 12 * 4 - (25 + 6 / (2 + (2 - 1) * 2 - 1) - 4 * 3)),\n                new Test(\"12*4/2-(25+6/(2+(2-1)*2-1)-4*3)\", 12 * 4 / 2 - (25 + 6 / (2 + (2 - 1) * 2 - 1) - 4 * 3)),\n        };\n        for (Test test : testList) {\n            int calculate = solution.calculate(test.S);\n            System.out.println((calculate == test.Expect) + \"------>\" + calculate);\n        }\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\ntrue------>-25\ntrue------>13\ntrue------>33\ntrue------>9\n```\n","tags":["算法题"],"categories":["算法练习"]},{"title":"零钱兑换 II","url":"/2023/04/19/零钱兑换-II.html","content":"\n# 题目描述\n\n> 题目链接：[518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/description/)\n\n给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。\n\n请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。\n\n假设每一种面额的硬币有无限个。\n\n题目数据保证结果符合 32 位带符号整数。\n\n**示例1：**\n\n```Plain\n输入：amount = 5, coins = [1, 2, 5]\n输出：4\n解释：有四种方式可以凑成总金额：\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n```\n\n**示例2：**\n\n```Plain\n输入：amount = 3, coins = [2]\n输出：0\n解释：只用面额 2 的硬币不能凑成总金额 3 。\n```\n\n**示例2：**\n\n```Plain\n输入：amount = 10, coins = [10] \n输出：1\n```\n\n提示：\n\n- `1 <= coins.length <= 300`\n- `1 <= coins[i] <= 5000`\n- `coins` 中的所有值 **互不相同**\n- `0 <= amount <= 5000`\n\n# 我的题解\n\n## **方法一：01背包思想**\n\n### **思路**\n\n设dp[i][j]为在前i个银币中凑成金额为j的种类数量，考虑第i个硬币参不参与凑数过程：\n\n- 不参与，则dp[i][j] = dp[i-1][j]\n- 参与，考虑第i个硬币选k次，最多选 j / coins[i]次，因此求dp[ i - 1][j - coins[i] * k]之和\n\n考虑动态规划初始化，因为当硬币值为n时，可以凑成金额为k*n的种类有一种，因此为了保证dp[ i - 1][j - coins[i] * k]中j - coins[i] * k == 0时有一种选择，因此我们把dp[i][0]初始化为1.\n\n以示例一举例，求得dp数组为\n\n```Plain\n1 0 0 0 0 0 \n1 1 1 1 1 1 \n1 1 2 2 3 3 \n1 1 2 2 3 4\n```\n\n### **代码**\n\n```Java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[][] dp = new int[coins.length + 1][amount + 1];\n        for (int i = 0; i < dp.length; i++) {\n            dp[i][0] = 1;\n        }\n        for (int i = 1; i < dp.length; i++) {\n            for (int j = 1; j < dp[0].length; j++) {\n                for (int k = 0; k <= j / coins[i - 1]; k++) {\n                    dp[i][j] += dp[i - 1][j - k * coins[i - 1]];\n                }\n            }\n        }\n        return dp[coins.length][amount];\n    }\n}\n```\n\n## **方法二：完全背包**\n\n### **思路**\n\n和上述01背包思想不同，完全背包直接利用了dp[i][j]语义，方法一解法是通过遍历来获取含第i个硬币的组合，因此多了一层循环，而完全背包递推公式为：\n\n```Plain\ndp[i][j] += dp[i - 1][j] + dp[i][j - coins[i - 1]];\n```\n\n注意后半部分，dp[i][j - coins[i - 1]]，也就是直接添加第i个硬币已经参与并且值为j - coins[i-1]的种类\n\n### **代码**\n\n```Java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[][] dp = new int[coins.length + 1][amount + 1];\n        for (int i = 0; i < dp.length; i++) {\n            dp[i][0] = 1;\n        }\n        for (int i = 1; i < dp.length; i++) {\n            for (int j = 1; j < dp[0].length; j++) {\n                if (j >= coins[i - 1]) {\n                    dp[i][j] += dp[i - 1][j] + dp[i][j - coins[i - 1]];\n                } else {\n                    dp[i][j] += dp[i - 1][j];\n                }\n            }\n        }\n        return dp[coins.length][amount];\n    }\n}\n```\n\n使用一维数组优化：\n\n```Java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n        for (int i = 0; i < coins.length; i++) {\n            for (int j = coins[i]; j <= amount; j++) {\n                dp[j] += dp[j - coins[i]];\n            }\n        }\n        return dp[amount];\n    }\n}\n```\n","tags":["算法题"],"categories":["算法练习"]},{"title":"一和零","url":"/2023/04/19/一和零.html","content":"\n# 题目描述\n\n> 题目链接：[474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/description/)\n\n给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。\n\n请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。\n\n如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。\n\n**示例1：**\n\n```Plain\n输入：strs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3\n输出：4\n解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\"10\",\"0001\",\"1\",\"0\"} ，因此答案是 4 。\n其他满足题意但较小的子集包括 {\"0001\",\"1\"} 和 {\"10\",\"1\",\"0\"} 。{\"111001\"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n```\n\n**示例2：**\n\n```Plain\n输入：strs = [\"10\", \"0\", \"1\"], m = 1, n = 1\n输出：2\n解释：最大的子集是 {\"0\", \"1\"} ，所以答案是 2 。\n```\n\n提示：\n\n- `1 <= strs.length <= 600`\n- `1 <= strs[i].length <= 100`\n- `strs[i]` 仅由 `'0'` 和 `'1'` 组成\n- `1 <= m, n <= 100`\n\n# 我的题解\n\n## **方法一：动态规划**\n\n### **思路**\n\n设dp[i][j][k]为前i个字符串中能装入m个0，n个1的个数，则：\n\n```Plain\n当i>=zeroCount&&j>=firstCount时：\ndp[i][j][k] = Math.max(dp[i-1][j][k],dp[i-1][j - zeroCount][k - firstCount] + 1)；\n其他：\ndp[i][j][k] = dp[i-1][j][k]\n```\n\n### **代码**\n\n```Java\nclass Solution {\n    public int findMaxForm(String[] s, int m, int n) {\n        int[][][] dp = new int[s.length + 1][m + 1][n + 1];\n        for (int i = 1; i < s.length + 1; i++) {\n            for (int j = 0; j < m + 1; j++) {\n                for (int k = 0; k < n + 1; k++) {\n                    int zeroCount = getZeroCount(s[i - 1]);\n                    int firstCount = s[i - 1].length() - zeroCount;\n                    if (j >= zeroCount && k >= firstCount) {\n                        dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - zeroCount][k - firstCount] + 1);\n                    } else {\n                        dp[i][j][k] = dp[i - 1][j][k];\n                    }\n                }\n            }\n        }\n        return dp[s.length][m][n];\n    }\n\n    private int getZeroCount(String s) {\n        int result = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '0') {\n                result++;\n            }\n        }\n        return result;\n    }\n}\n```\n\n注意m和n的遍历都需要从0开始，因为会有m = 0, n = 1这种情况\n","tags":["算法题"],"categories":["算法练习"]},{"title":"目标和","url":"/2023/04/19/目标和.html","content":"\n# 题目描述\n\n> 题目链接：[494. 目标和](https://leetcode.cn/problems/target-sum/description/)\n\n给你一个整数数组 `nums` 和一个整数 `target` 。\n\n向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：\n\n- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `\"+2-1\"` 。\n\n返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。\n\n**示例1：**\n\n```Plain\n输入：nums = [1,1,1,1,1], target = 3\n输出：5\n解释：一共有 5 种方法让最终目标和为 3 。\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n```\n\n**示例2：**\n\n```Plain\n输入：nums = [1], target = 1\n输出：1\n```\n\n提示：\n\n- `1 <= nums.length <= 20`\n- `0 <= nums[i] <= 1000`\n- `0 <= sum(nums[i]) <= 1000`\n- `-1000 <= target <= 1000`\n\n# 我的题解\n\n## **方法一：动态规划**\n\n### **思路**\n\n由题意，求出数组的和为sum，那么添加运算符号后，则最终的结果范围为：-sum~sum，\n\n设dp[i][j]为前i个数中和为j的个数，因此每一个状态都有dp[i-1][0~j]推出，以实例一为例：\n\n```Plain\n  -5 -4 -3 -2 -1 0 1 2 3 4 5\n1  0  0  0  0  1 0 1 0 0 0 0\n2  0  0  0  1  0 2 0 1 0 0 0 \n......\n```\n\n每一行状态都由上一组状态推出，这里使用map进行计算\n\n### **代码**\n\n```Java\nclass Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        map.put(nums[0], map.getOrDefault(nums[0], 0) + 1);\n        map.put(-nums[0], map.getOrDefault(-nums[0], 0) + 1);\n        for (int i = 1; i < nums.length; i++) {\n            int index = i;\n            HashMap<Integer, Integer> t = map;\n            HashMap<Integer, Integer> m = new HashMap<>();\n            map.forEach((k, v) -> {\n                m.put(k + nums[index], m.getOrDefault(k + nums[index], 0) + t.get(k));\n                m.put(k - nums[index], m.getOrDefault(k - nums[index], 0) + t.get(k));\n            });\n            map = m;\n        }\n        return map.getOrDefault(target, 0);\n    }\n}\n```\n","tags":["算法题"],"categories":["算法练习"]},{"title":"最后一块石头的重量 II","url":"/2023/04/19/最后一块石头的重量-II.html","content":"\n# 题目描述\n\n> 题目链接：[1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/description/)\n\n有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。\n\n每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：\n\n- 如果 `x == y`，那么两块石头都会被完全粉碎；\n- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。\n\n最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。\n\n**示例1：**\n\n```Plain\n输入：stones = [2,7,4,1,8,1]\n输出：1\n解释：\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n```\n\n**示例2：**\n\n```Plain\n输入：stones = [31,26,33,21,40]\n输出：5\n```\n\n提示：\n\n- `1 <= stones.length <= 30`\n- `1 <= stones[i] <= 100`\n\n# 我的题解\n\n## **方法一：动态规划**\n\n### **思路**\n\n最后剩下的石头重量最小，那么最理想的情况就是0，也就是可以将数组分为两个数组，其和相等，这样的话碰撞后则为0。\n\n顺着这个思路，我们可以将数组分为两个数组，其差最小，也就是两个数组的和尽量相等；那么我们可以求出整个数组的和，以和/2作为背包容量，遍历数组，求得能装进背包得最大重量weight，那么另一个数组的和则为sum - weight，最终答案为两数组和之差：sum - 2 * weight\n\n### **代码**\n\n```Java\nclass Solution {\n    public int lastStoneWeightII(int[] stones) {\n        int sum = Arrays.stream(stones).sum();\n        int target = sum / 2;\n        int[][] dp = new int[stones.length + 1][target + 1];\n        for (int i = 1; i < dp.length; i++) {\n            for (int j = 1; j < dp[0].length; j++) {\n                if (j >= stones[i - 1]) {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i - 1]] + stones[i - 1]);\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return sum - 2 * dp[stones.length][target];\n    }\n}\n```\n\n滚动数组优化：\n\n```Java\nclass Solution {\n    public int lastStoneWeightII(int[] stones) {\n        int sum = Arrays.stream(stones).sum();\n        int target = sum / 2;\n        int[] dp = new int[target + 1];\n        for (int i = 0; i < stones.length; i++) {\n            for (int j = target; j >= stones[i]; j--) {\n                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);\n            }\n        }\n        return sum - 2 * dp[target];\n    }\n}\n```\n","tags":["算法题"],"categories":["算法练习"]},{"title":"分割等和子集","url":"/2023/04/19/分割等和子集.html","content":"\n# 题目描述\n\n> 题目链接：[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/description/)\n\n给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n**示例1：**\n\n```Plain\n输入：nums = [1,5,11,5]\n输出：true\n解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n```\n\n**示例2：**\n\n```Plain\n输入：nums = [1,2,3,5]\n输出：false\n解释：数组不能分割成两个元素和相等的子集。\n```\n\n提示：\n\n- `1 <= nums.length <= 200`\n- `1 <= nums[i] <= 100`\n\n# 我的题解\n\n## **方法一：动态规划**\n\n### **思路**\n\n求出当前数组和，若为奇数则不可分成两个相等的子集，若和为偶数，则需要子集的和必须为和/2，也就是可以转化为从数组中选择若干数字，装入容量为和/2的背包中，是否能装满，因此转化为01背包问题。\n\n### **代码**\n\n```Java\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int sum = Arrays.stream(nums).sum();\n        if ((sum & 1) == 1) {\n            return false;\n        }\n        int target = sum / 2;\n        int[][] dp = new int[nums.length + 1][target + 1];\n        for (int i = 1; i < dp.length; i++) {\n            for (int j = 1; j < dp[0].length; j++) {\n                if (j >= nums[i - 1]) {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + nums[i - 1]);\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[nums.length][target] == target;\n    }\n}\n```\n\n一维数组优化：\n\n```Java\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int sum = Arrays.stream(nums).sum();\n        if ((sum & 1) == 1) {\n            return false;\n        }\n        int target = sum / 2;\n        int[] dp = new int[target + 1];\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = target; j >= nums[i]; j--) {\n                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);\n            }\n        }\n        return dp[target] == target;\n    }\n}\n```\n","tags":["算法题"],"categories":["算法练习"]},{"title":"不同的二叉搜索树","url":"/2023/04/19/不同的二叉搜索树.html","content":"\n# 题目描述\n\n> 题目链接：[96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)\n\n给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。\n\n**示例1：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/01.png)\n\n```Plain\n输入：n = 3\n输出：5\n```\n\n**示例2：**\n\n```Plain\n输入：n = 1\n输出：1\n```\n\n提示：\n\n- `1 <= n <= 19`\n\n# 我的题解\n\n## **方法一：动态规划**\n\n### **思路**\n\n选择根节点，则当前树的种数则为左边子树的总数乘以右边子树的种数，即：\n\n```Java\n//选择i为根节点，j-1为左边子树的节点个数，i-j为右边子树的节点个数\ndp[i] = dp[j - 1] * dp[i - j];\n```\n\n### **代码**\n\n```Java\nclass Solution {\n    public int numTrees(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i < dp.length; i++) {\n            for (int j = 1; j <= i; j++) {\n                dp[i] += dp[j - 1] * dp[i - j];\n            }\n        }\n        return dp[n];\n    }\n}\n```\n","tags":["算法题"],"categories":["算法练习"]},{"title":"整数拆分","url":"/2023/04/19/整数拆分.html","content":"\n# 题目描述\n\n> 题目链接：[343. 整数拆分](https://leetcode.cn/problems/integer-break/description/)\n\n给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。\n\n返回 *你可以获得的最大乘积* 。\n\n**示例1：**\n\n```Plain\n输入: n = 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1。\n```\n\n**示例2：**\n\n```Plain\n输入: n = 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。\n```\n\n提示：\n\n- `2 <= n <= 58`\n\n# 我的题解\n\n## **方法一：动态规划**\n\n### **思路**\n\n考虑一个整数**拆或者不拆**，则递推公式为：\n\n```Java\ndp[i] = Math.max(dp[i - j] * j, (i - j) * j)\n```\n\n### **代码**\n\n```Java\nclass Solution {\n    public int integerBreak(int n) {\n        int[] dp = new int[n];\n        dp[0] = 1;\n        for (int i = 1; i < dp.length; i++) {\n            for (int j = 1; j < i + 1; j++) {\n                dp[i] = Math.max(dp[i], Math.max(dp[i - j] * j, (i + 1 - j) * j));\n            }\n        }\n        return dp[n - 1];\n    }\n}\n```\n","tags":["算法题"],"categories":["算法练习"]},{"title":"不同路径 II","url":"/2023/04/19/不同路径-II.html","content":"\n# 题目描述\n\n> 题目链接：[63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)\n\n一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。\n\n**示例1：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II/01.png)\n\n```Plain\n输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n输出：2\n解释：3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n1. 向右 -> 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右 -> 向右\n```\n\n**示例2：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II/02.png)\n\n```Plain\n输入：obstacleGrid = [[0,1],[0,0]]\n输出：1\n```\n\n提示：\n\n- `m == obstacleGrid.length`\n- `n == obstacleGrid[i].length`\n- `1 <= m, n <= 100`\n- `obstacleGrid[i][j]` 为 `0` 或 `1`\n\n# 我的题解\n\n## **方法一：动态规划**\n\n### **思路**\n\n假设当前位置为(i, j)，那么有两种路径可以到达当前位置，即(i-1, j)和(i, j-1)，因此到达当前位置的路径数可由左边和上边的路径推出，因此递推公式为：\n\n```Java\ndp[i][j] = dp[i-1][j] + dp[i][j-1]\n```\n\n考虑obstacleGrid[i][j]的位置有障碍物，则dp[i][j]为0，即obstacleGrid[i][j]不可达。\n\n### **代码**\n\n```Java\nclass Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int m = obstacleGrid.length + 1, n = obstacleGrid[0].length + 1;\n        int[][] dp = new int[m][n];\n        dp[1][1] = obstacleGrid[0][0] == 0 ? 1 : 0;\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (obstacleGrid[i-1][j-1] == 1) {\n                    dp[i][j] = 0;\n                } else {\n                    dp[i][j] += dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n}\n```\n\n使用滚动数组进行优化：\n\n```Java\nclass Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int m = obstacleGrid.length, n = obstacleGrid[0].length;\n        int[] dp = new int[n];\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (obstacleGrid[i][j] == 1) {\n                    dp[j] = 0;\n                } else if (i == 0 && j == 0) {\n                    dp[j] = 1;\n                } else if (i == 0) {\n                    dp[j] = dp[j - 1];\n                } else if (j == 0) {\n                    dp[j] = dp[j];\n                } else {\n                    dp[j] += dp[j - 1];\n                }\n            }\n        }\n        return dp[n - 1];\n    }\n}\n```\n","tags":["算法题"],"categories":["算法练习"]},{"title":"不同路径","url":"/2023/04/19/不同路径.html","content":"\n# 题目描述\n\n> 题目链接：[62. 不同路径](https://leetcode.cn/problems/unique-paths/)\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/01.png)\n\n```Plain\n输入：m = 3, n = 7\n输出：28\n```\n\n**示例1：**\n\n```Plain\n输入：m = 3, n = 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向下\n```\n\n**示例2：**\n\n```Plain\n输入：m = 7, n = 3\n输出：28\n```\n\n**示例3：**\n\n```Plain\n输入：m = 3, n = 3\n输出：6\n```\n\n提示：\n\n- `1 <= m, n <= 100`\n- 题目数据保证答案小于等于 `2 * 10(9)`\n\n# 我的题解\n\n## **方法一：动态规划**\n\n### **思路**\n\n假设当前位置为(i, j)，那么有两种路径可以到达当前位置，即(i-1, j)和(i, j-1)，因此到达当前位置的路径数可由左边和上边的路径推出，因此递推公式为：\n\n```Java\ndp[i][j] = dp[i-1][j] + dp[i][j-1]\n```\n\n### **代码**\n\n```Java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m + 1][n + 1];\n        dp[1][1] = 1;\n        for (int i = 1; i < m + 1; i++) {\n            for (int j = 1; j < n + 1; j++) {\n                dp[i][j] += dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m][n];\n    }\n}\n```\n\n使用滚动数组优化：\n\n```Java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int max = Math.max(m, n);\n        int min = Math.min(m, n);\n        int[] dp = new int[min];\n        for (int i = 0; i < max; i++) {\n            for (int j = 0; j < min; j++) {\n                if (i == 0 || j == 0) {\n                    dp[j] = 1;\n                } else {\n                    dp[j] += dp[j - 1];\n                }\n            }\n        }\n        return dp[min - 1];\n    }\n}\n```\n\n### **结果**\n\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n\n内存消耗：38.3 MB, 在所有 Java 提交中击败了52.72%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"使用最小花费爬楼梯","url":"/2023/04/19/使用最小花费爬楼梯.html","content":"\n# 题目描述\n\n> 题目链接：[746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)\n\n给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n\n请你计算并返回达到楼梯顶部的最低花费。\n\n**示例1：**\n\n```Plain\n输入：cost = [10,15,20]\n输出：15\n解释：你将从下标为 1 的台阶开始。\n- 支付 15 ，向上爬两个台阶，到达楼梯顶部。\n总花费为 15 。\n```\n\n**示例2：**\n\n```Plain\n输入：cost = [1,100,1,1,1,100,1,1,100,1]\n输出：6\n解释：你将从下标为 0 的台阶开始。\n- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。\n- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。\n- 支付 1 ，向上爬一个台阶，到达楼梯顶部。\n总花费为 6 。\n```\n\n提示：\n\n- `2 <= cost.length <= 1000`\n- `0 <= cost[i] <= 999`\n\n# 我的题解\n\n## **方法一：动态规划**\n\n### **思路**\n\n当爬到第n阶楼梯时，有两种方法可以到达：\n\n- 从n-1阶楼梯爬1阶到第n阶\n- 从n-2阶楼梯爬2阶到第n阶\n\n设dp[i]为爬到第i层的最小花费，则动态规划公式为：dp[i] = Math.min( dp[i-1] + dp[i-2] ) + cost[i]\n\n因为当前状态只依赖前两个状态，因此，可以使用变量优化\n\n### **代码**\n\n```Java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int a = cost[0], b = cost[1], c;\n        for (int i = 2; i < cost.length; i++) {\n            c = Math.min(a, b) + cost[i];\n            a = b;\n            b = c;\n        }\n        return Math.min(a, b);\n    }\n}\n```\n\n### **结果**\n\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n\n内存消耗：40.9 MB, 在所有 Java 提交中击败了69.45%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"爬楼梯","url":"/2023/04/19/爬楼梯.html","content":"\n# 题目描述\n\n> 题目链接：[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)\n\n假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。\n\n每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n**示例1：**\n\n```Plain\n输入：n = 2\n输出：2\n解释：有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶\n```\n\n**示例2：**\n\n```Plain\n输入：n = 3\n输出：3\n解释：有三种方法可以爬到楼顶。\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n```\n\n提示：\n\n- `1 <= n <= 45`\n\n# 我的题解\n\n## **方法一：动态规划**\n\n### **思路**\n\n当爬到第n阶楼梯时，有两种方法可以到达：\n\n- 从n-1阶楼梯爬1阶到第n阶\n- 从n-2阶楼梯爬2阶到第n阶\n\n因此动态规划公式为：dp[n] = dp[n-1] + dp[n-2]\n\n因为当前状态只依赖前两个状态，因此，可以使用变量优化\n\n### **代码**\n\n```Java\nclass Solution {\n    public int climbStairs(int n) {\n        if (n < 3) {\n            return n;\n        }\n        int a = 1, b = 2, c = 0;\n        for (int i = 2; i < n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return c;\n    }\n}\n```\n\n### **结果**\n\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n\n内存消耗：38.5 MB, 在所有 Java 提交中击败了25.77%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"斐波那契数","url":"/2023/04/19/斐波那契数.html","content":"\n# 题目描述\n\n> 题目链接：[509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)\n\n斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n```Plain\nF(0) = 0，F(1) = 1\nF(n) = F(n - 1) + F(n - 2)，其中 n > 1\n```\n\n给定 n ，请计算 F(n) 。\n\n**示例1：**\n\n```Plain\n输入：n = 2\n输出：1\n解释：F(2) = F(1) + F(0) = 1 + 0 = 1\n```\n\n**示例2：**\n\n```Plain\n输入：n = 3\n输出：2\n解释：F(3) = F(2) + F(1) = 1 + 1 = 2\n```\n\n**示例3：**\n\n```Plain\n输入：n = 4\n输出：3\n解释：F(4) = F(3) + F(2) = 2 + 1 = 3\n```\n\n提示：\n\n- `0 <= n <= 30`\n\n# 我的题解\n\n## **方法一：动态规划**\n\n### **思路**\n\n一个简单的状态转移\n\n### **代码**\n\n```Java\nclass Solution {\n    public int fib(int n) {\n        if (n == 0 || n == 1) {\n            return n;\n        }\n        int a = 0, b = 1, c = 0;\n        for (int i = 0; i <= n - 2; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return c;\n    }\n}\n```\n\n### **结果**\n\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n\n内存消耗：38.5 MB, 在所有 Java 提交中击败了24.07%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"子集","url":"/2023/04/19/子集.html","content":"\n# 题目描述\n\n> 题目链接：[78. 子集](https://leetcode.cn/problems/subsets/)\n\n给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。\n\n解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。\n\n**示例1：**\n\n```Plain\n输入：nums = [1,2,3]\n输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n```\n\n**示例2：**\n\n```Plain\n输入：nums = [0]\n输出：[[],[0]]\n```\n\n提示：\n\n- `1 <= nums.length <= 10`\n- `-10 <= nums[i] <= 10`\n- `nums` 中的所有元素 **互不相同**\n\n# 我的题解\n\n## **方法一：回溯**\n\n### **思路**\n\n当前元素选或者不选\n\n### **代码**\n\n```Java\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> r = new ArrayList<>();\n        dfs(result, r, 0, nums);\n        return result;\n    }\n\n    private void dfs(List<List<Integer>> result, List<Integer> r, int index, int[] nums) {\n        if (index >= nums.length) {\n            result.add(new ArrayList<>(r));\n            return;\n        }\n        //选\n        r.add(nums[index]);\n        dfs(result, r, index + 1, nums);\n        r.remove(r.size() - 1);\n        //不选\n        dfs(result, r, index + 1, nums);\n    }\n}\n```\n\n### **结果**\n\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n\n内存消耗：42 MB, 在所有 Java 提交中击败了5.13%的用户\n\n## **方法二：移位运算**\n\n### **思路**\n\nn个集合的子集个数为2^n，因此可以用二进制位来表示当前元素选或者不选。\n\n### **代码**\n\n```Java\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        int pow = (int) Math.pow(2, nums.length);\n        for (int i = 0; i < pow; i++) {\n            List<Integer> r = new ArrayList<>();\n            for (int j = 0; j < nums.length; j++) {\n                int t = 1 << j;\n                if ((i & t) == t) {\n                    r.add(nums[j]);\n                }\n            }\n            result.add(r);\n        }\n        return result;\n    }\n}\n```\n\n### **结果**\n\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n\n内存消耗：41.6 MB, 在所有 Java 提交中击败了44.86%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"字符串相乘","url":"/2023/04/19/字符串相乘.html","content":"\n# 题目描述\n\n> 题目链接：[43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/)\n\n给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。\n\n注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。\n\n**示例1：**\n\n```Plain\n输入: num1 = \"2\", num2 = \"3\"\n输出: \"6\"\n```\n\n**示例2：**\n\n```Plain\n输入: num1 = \"123\", num2 = \"456\"\n输出: \"56088\"\n```\n\n提示：\n\n- 1 <= num1.length, num2.length <= 200\n- num1 和 num2 只能由数字组成。\n- num1 和 num2 都不包含任何前导零，除了数字0本身。\n\n# 我的题解\n\n## **方法一：模拟乘法**\n\n### **思路**\n\n模拟乘法计算过程，使用数组记录中间值。\n\n### **代码**\n\n```Java\nclass Solution {\n    public String multiply(String num1, String num2) {\n        if (\"0\".equals(num1) || \"0\".equals(num2)) {\n            return \"0\";\n        }\n        int n = num1.length(), m = num2.length();\n        int[] r = new int[n + m];\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = m - 1; j >= 0; j--) {\n                int index = m - j - 1 + (n - i - 1);\n                int a = num1.charAt(i) - '0';\n                int b = num2.charAt(j) - '0';\n                int sum = a * b + r[index];\n                r[index] = sum % 10;\n                int c = sum / 10;\n                r[index + 1] += c;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        int index = r.length - 1;\n        while (r[index] == 0) {\n            index--;\n        }\n        for (int i = index; i >= 0; i--) {\n            sb.append(r[i]);\n        }\n        return sb.toString();\n    }\n}\n```\n\n### **结果**\n\n执行用时：3 ms, 在所有 Java 提交中击败了67.02%的用户\n\n内存消耗：39.8 MB, 在所有 Java 提交中击败了99.65%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"括号生成","url":"/2023/04/19/括号生成.html","content":"\n# 题目描述\n\n> 题目链接：[22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)\n\n数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。\n\n**示例1：**\n\n```Plain\n输入：n = 3\n输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n```\n\n**示例2：**\n\n```Plain\n输入：n = 1\n输出：[\"()\"]\n```\n\n提示：\n\n- `1 <= n <= 8`\n\n# 我的题解\n\n## **方法一：回溯+剪枝**\n\n### **思路**\n\n回溯法枚举所有情况，其中根据条件进行剪枝：当已加入的右括号大于左括号，这时不能够构成一个有效的括号\n\n### **代码**\n\n```Java\nclass Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> result = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        dfs(result, sb, n, n);\n        return result;\n    }\n\n    private void dfs(List<String> result, StringBuilder sb, int left, int right) {\n        if (left > right) {\n            return;\n        }\n        if (left == 0 && right == 0) {\n            result.add(sb.toString());\n            return;\n        }\n        if (left > 0) {\n            sb.append(\"(\");\n            dfs(result, sb, left - 1, right);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        if (right > 0) {\n            sb.append(\")\");\n            dfs(result, sb, left, right - 1);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n}\n```\n\n### **结果**\n\n执行用时：1 ms, 在所有 Java 提交中击败了76.53%的用户\n\n内存消耗：41.2 MB, 在所有 Java 提交中击败了92.68%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"滑动窗口最大值","url":"/2023/04/19/滑动窗口最大值.html","content":"\n# 题目描述\n\n> 题目链接：[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)\n\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n\n返回 滑动窗口中的最大值 。\n\n**示例1：**\n\n```Plain\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n**示例2：**\n\n```Plain\n输入：nums = [1], k = 1\n输出：[1]\n```\n\n提示：\n\n- `1 <= nums.length <= 10(5)`\n- `-10(4) <= nums[i] <= 10(4)`\n- `1 <= k <= nums.length`\n\n# 我的题解\n\n## **方法一：单调双端队列**\n\n### **思路**\n\n使用单调双端队列，队列中始终维持单调递减，当左边窗口移除元素时，判断是否为最大元素，是则出队，当右边窗口加入元素时，从右向左判断队列中元素是否小于当前元素，小则出队，最后当前元素入队。\n\n### **代码**\n\n```Java\nclass Solution {\n\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int index = 0;\n        ArrayDeque<Integer> queue = new ArrayDeque<>();\n        int[] result = new int[nums.length - k + 1];\n        for (int i = 0; i < k; i++) {\n            while (!queue.isEmpty() && queue.peekLast() < nums[i]) {\n                queue.pollLast();\n            }\n            queue.offerLast(nums[i]);\n        }\n        result[index++] = queue.peekFirst();\n        for (int i = k; i < nums.length; i++) {\n            if (queue.peekFirst() == nums[i - k]) {\n                queue.pollFirst();\n            }\n            while (!queue.isEmpty() && queue.peekLast() < nums[i]) {\n                queue.pollLast();\n            }\n            queue.offerLast(nums[i]);\n            result[index++] = queue.peekFirst();\n        }\n        return result;\n    }\n}\n```\n\n### **结果**\n\n执行用时：26 ms, 在所有 Java 提交中击败了94.05%的用户\n\n内存消耗：55.5 MB, 在所有 Java 提交中击败了95.74%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"复原 IP 地址","url":"/2023/04/19/复原-IP-地址.html","content":"\n# 题目描述\n\n> 题目链接：[93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)\n\n有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。\n\n例如：\"0.1.2.201\" 和 \"192.168.1.1\" 是 有效 IP 地址，但是 \"0.011.255.245\"、\"192.168.1.312\" 和 \"192.168@1.1\" 是 无效 IP 地址。\n\n给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。\n\n**示例1：**\n\n```Plain\n输入：s = \"25525511135\"\n输出：[\"255.255.11.135\",\"255.255.111.35\"]\n```\n\n**示例2：**\n\n```Plain\n输入：s = \"0000\"\n输出：[\"0.0.0.0\"]\n```\n\n**实例3：**\n\n```Plain\n输入：s = \"101023\"\n输出：[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n```\n\n提示：\n\n- `1 <= s.length <= 20`\n- `s` 仅由数字组成\n\n# 我的题解\n\n## **方法一：回溯法**\n\n### **思路**\n\n枚举每一个可能的值，组装成最终结果\n\n### **代码**\n\n```Java\nclass Solution {\n\n    public List<String> restoreIpAddresses(String s) {\n        List<String> result = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        dfs(result, sb, 0, s, 0);\n        return result;\n    }\n\n    private void dfs(List<String> result, StringBuilder sb, int index, String s, int deep) {\n        int length = s.length();\n        if (deep == 4) {\n            String r = sb.deleteCharAt(sb.length() - 1).toString();\n            if (index == length) {\n                result.add(r);\n            }\n            return;\n        }\n        if (index >= length) {\n            return;\n        }\n        for (int i = 1; i <= 3; i++) {\n            int end = Math.min(index + i, length);\n            String str = s.substring(index, end);\n            //根据部分内容剪枝\n            if (str.length() > 1 && str.charAt(0) == '0' || Integer.parseInt(str) > 255) {\n                continue;\n            }\n            StringBuilder t = new StringBuilder(sb).append(str).append(\".\");\n            dfs(result, t, end, s, deep + 1);\n            //最后一部分去重\n            if (end == length) {\n                break;\n            }\n        }\n    }\n}\n```\n\n### **结果**\n\n执行用时：2 ms, 在所有 Java 提交中击败了73.78%的用户\n\n内存消耗：41.2 MB, 在所有 Java 提交中击败了71.95%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"重排链表","url":"/2023/04/19/重排链表.html","content":"\n# 题目描述\n\n> 题目链接：[143. 重排链表](https://leetcode.cn/problems/reorder-list/)\n\n给定一个单链表 L 的头节点 head ，单链表 L 表示为：\n\n```Plain\nL0 → L1 → … → Ln - 1 → Ln\n```\n\n请将其重新排列后变为：\n\n```Plain\nL0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …\n```\n\n不能只是单纯的改变节点内部的值，而是需要**实际的进行节点交换**。\n\n**示例1：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/01.png)\n\n```Plain\n输入：head = [1,2,3,4]\n输出：[1,4,2,3]\n```\n\n**示例2：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/02.png)\n\n```Plain\n输入：head = [1,2,3,4,5]\n输出：[1,5,2,4,3]\n```\n\n提示：\n\n- 链表的长度范围为 `[1, 5 * 10(4)]`\n- `1 <= node.val <= 1000`\n\n# 我的题解\n\n## **方法一：双端队列**\n\n### **思路**\n\n很明显的思路，先遍历一遍，放入双端队列中，然后从两边取节点重组链表。\n\n### **代码**\n\n```Java\nclass Solution {\n    public void reorderList(ListNode head) {\n        ArrayDeque<ListNode> queue = new ArrayDeque<>();\n        ListNode p = head;\n        while (p != null) {\n            queue.offer(p);\n            p = p.next;\n        }\n        ListNode h = queue.pollFirst();\n        boolean f = true;\n        while (!queue.isEmpty()) {\n            h.next = f ? queue.pollLast() : queue.pollFirst();\n            f = !f;\n            h = h.next;\n        }\n        h.next = null;\n    }\n}\n```\n\n### **结果**\n\n执行用时：3 ms, 在所有 Java 提交中击败了32.51%的用户\n\n内存消耗：44 MB, 在所有 Java 提交中击败了71.11%的用户\n\n## **方法二：查找中间节点+链表反转+合并链表**\n\n### **思路**\n\n首先查找链表的中间节点，然后将第二部分链表反转，最后再合并两部分的链表，可以达到O(1)的空间复杂度。\n\n### **代码**\n\n```Java\nclass Solution {\n    public void reorderList(ListNode head) {\n        if (head == null || head.next == null) {\n            return;\n        }\n        ListNode center = findCenterNode(head);\n        ListNode l1 = head;\n        ListNode l2 = reverseList(center);\n        mergeList(l1, l2);\n    }\n\n    private void mergeList(ListNode l1, ListNode l2) {\n        ListNode h = new ListNode(-1);\n        boolean f = true;\n        while (l1 != null && l2 != null) {\n            if (f) {\n                h.next = l1;\n                l1 = l1.next;\n            } else {\n                h.next = l2;\n                l2 = l2.next;\n            }\n            f = !f;\n            h = h.next;\n        }\n        h.next = l1 != null ? l1 : l2;\n    }\n\n    private ListNode reverseList(ListNode head) {\n        ListNode p1 = null, p2 = head;\n        while (p2 != null) {\n            ListNode t = p2.next;\n            p2.next = p1;\n            p1 = p2;\n            p2 = t;\n        }\n        return p1;\n    }\n\n    private ListNode findCenterNode(ListNode head) {\n        ListNode p1 = head, p2 = head, t = head;\n        while (p2 != null && p2.next != null) {\n            t = p1;\n            p1 = p1.next;\n            p2 = p2.next.next;\n        }\n        t.next = null;\n        return p1;\n    }\n}\n```\n\n### **结果**\n\n执行用时：2 ms, 在所有 Java 提交中击败了41.75%的用户\n\n内存消耗：44 MB, 在所有 Java 提交中击败了64.87%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"二叉树中的最大路径和","url":"/2023/04/19/二叉树中的最大路径和.html","content":"\n# 题目描述\n\n> 题目链接：[124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)\n\n**路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个 节点**，且不一定经过根节点。\n\n**路径和** 是路径中各节点值的总和。\n\n给你一个二叉树的根节点 root ，返回其 最大路径和 。\n\n**示例1：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/01.png)\n\n```Plain\n输入：root = [1,2,3]\n输出：6\n解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6\n```\n\n**示例2：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/02.png)\n\n```Plain\n输入：root = [-10,9,20,null,null,15,7]\n输出：42\n解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42\n```\n\n提示：\n\n- 树中节点数目范围是 `[1, 3 * 10(4)]`\n- `-1000 <= Node.val <= 1000`\n\n# 我的题解\n\n## **方法一：递归**\n\n### **思路**\n\n由题意可知，最大路径的组成可能为：\n\n- 根节点+左子树+右子树\n- 根节点+左子树\n- 根节点+右子树\n- 根节点\n- 左子树\n- 右子树\n\n因此我们应该考虑根节点是否选择的问题，递归返回值定义为当前树最大的路径（注意不要带根节点），然后在遍历过程中我们取最大值，即为整棵树的最大路径。\n\n而当前树的最大路径为：\n\n- 根节点\n- 左子树+根节点\n- 右子树+根节点\n\n的最大值，在求整棵树路径的最大值时，我们要再加上根节点判断。\n\n### **代码**\n\n```Java\nclass Solution {\n\n    private int result = Integer.MIN_VALUE;\n\n    public int maxPathSum(TreeNode root) {\n        dfs(root);\n        return result;\n    }\n\n    private int dfs(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int left = dfs(root.left);\n        int right = dfs(root.right);\n        int max = root.val;\n        max = Math.max(max, left + root.val);\n        max = Math.max(max, right + root.val);\n        result = Math.max(Math.max(result, max), left + right + root.val);\n        return max;\n    }\n}\n```\n\n### **结果**\n\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n\n内存消耗：43.1 MB, 在所有 Java 提交中击败了40.15%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"相交链表","url":"/2023/04/19/相交链表.html","content":"\n# 题目描述\n\n> 题目链接：[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\n\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/01.png)\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\n\nlistA - 第一个链表\n\nlistB - 第二个链表\n\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\n\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n**示例1：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/02.png)\n\n```Plain\n= 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。\n```\n\n**示例2：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/03.png)\n\n```Plain\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n```\n\n**示例3：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/04.png)\n\n```Plain\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n```\n\n提示：\n\n- listA 中节点数目为 m\n- listB 中节点数目为 n\n- 1 <= m, n <= 3 * 104\n- 1 <= Node.val <= 105\n- 0 <= skipA <= m\n- 0 <= skipB <= n\n- 如果 listA 和 listB 没有交点，intersectVal 为 0\n- 如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n# 我的题解\n\n## **方法一：双指针+数学**\n\n### **思路**\n\n以下图为例：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/05.png)\n\n设4->1段为a，5->1段为b，8->5段为c，指针p1指向4，指针p2指向5，一起向后移动，当移动到null时，p1指向5，p2指向4；则指针指向同一位置时，此位置即为相交点：\n\n- 当相交前两链表长度相同，则指针必将指向同一位置\n- 当相交前两链表长度不同，有a+c+b == b+c+a，则指针必将指向同一位置\n\n### **代码**\n\n```Java\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA, p2 = headB;\n        while (p1 != p2) {\n            p1 = p1 == null ? headB : p1.next;\n            p2 = p2 == null ? headA : p2.next;\n        }\n        return p1;\n    }\n}\n```\n\n### **结果**\n\n执行用时：1 ms, 在所有 Java 提交中击败了98.12%的用户\n\n内存消耗：44.7 MB, 在所有 Java 提交中击败了8.34%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"全排列","url":"/2023/04/19/全排列.html","content":"\n# 题目描述\n\n> 题目链接：[46. 全排列](https://leetcode.cn/problems/permutations/)\n\n给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。\n\n**示例1：**\n\n```Plain\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n**示例2：**\n\n```Plain\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n```\n\n**示例3：**\n\n```Plain\n输入：nums = [1]\n输出：[[1]]\n```\n\n提示：\n\n- `1 <= nums.length <= 6`\n- `-10 <= nums[i] <= 10`\n- `nums` 中的所有整数 **互不相同**\n\n# 我的题解\n\n## **方法一：回溯法**\n\n### **思路**\n\n非常经典的递归题目，对于nums = [1,2,3]，我们很容易想到：\n\n先选取第一个数1，再选取第二个数2，最后选取3，得到一个答案[1,2,3](选取长度等于nums.length即代表存在一个答案)，加入答案数组；然后回溯上一个操作，不选3，不选2，选3，再选2，我们得到了另一个答案[1,3,2]。\n\n因此我们需要一个标记数组标记当前数字是否已被选择，当得到一个答案之后回溯上一个选择即可。\n\n### **代码**\n\n```Java\nclass Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        boolean[] flag = new boolean[nums.length];\n        List<Integer> r = new ArrayList<>();\n        List<List<Integer>> result = new ArrayList<>();\n        dfs(nums, flag, result, r);\n        return result;\n    }\n\n    private void dfs(int[] nums, boolean[] flag, List<List<Integer>> result, List<Integer> r) {\n        if (r.size() == nums.length) {\n            result.add(new ArrayList<>(r));\n            return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (!flag[i]) {\n                r.add(nums[i]);\n                flag[i] = true;\n                dfs(nums, flag, result, r);\n                r.remove(r.size() - 1);\n                flag[i] = false;\n            }\n        }\n    }\n}\n```\n\n### **结果**\n\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n\n内存消耗：41.6 MB, 在所有 Java 提交中击败了59.47%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"二叉树的锯齿形层序遍历","url":"/2023/04/19/二叉树的锯齿形层序遍历.html","content":"\n# 题目描述\n\n> 题目链接：[103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)\n\n给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n\n**示例1：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/01.png)\n\n```Plain\n输入：root = [3,9,20,null,null,15,7]\n输出：[[3],[20,9],[15,7]]\n```\n\n**示例2：**\n\n```Plain\n输入：root = [1]\n输出：[[1]]\n```\n\n**示例3：**\n\n```Plain\n输入：root = []\n输出：[]\n```\n\n提示：\n\n- 树中节点数目在范围 `[0, 2000]` 内\n- `-100 <= Node.val <= 100`\n\n# 我的题解\n\n## **方法一：层序遍历**\n\n### **思路**\n\n普通层序遍历即可，注意单数层顺序添加元素，双数层逆向添加元素即可\n\n### **代码**\n\n```Java\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList<>();\n        }\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        List<List<Integer>> result = new ArrayList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            LinkedList<Integer> r = new LinkedList<>();\n            for (int i = queue.size() - 1; i >= 0; i--) {\n                TreeNode poll = queue.poll();\n                if ((result.size() & 1) == 0) {\n                    r.addLast(poll.val);\n                } else {\n                    r.addFirst(poll.val);\n                }\n                if (poll.left != null) {\n                    queue.offer(poll.left);\n                }\n                if (poll.right != null) {\n                    queue.offer(poll.right);\n                }\n            }\n            result.add(r);\n        }\n        return result;\n    }\n}\n```\n\n### **结果**\n\n执行用时：1 ms, 在所有 Java 提交中击败了69.28%的用户\n\n内存消耗：40.2 MB, 在所有 Java 提交中击败了57.76%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"二叉树的最近公共祖先","url":"/2023/04/18/二叉树的最近公共祖先.html","content":"\n# 题目描述\n\n> 题目链接：[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n**示例1：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/01.png)\n\n```SQL\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n```\n\n**示例2：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/02.png)\n\n```Plain\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出：5\n解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n```\n\n**示例3：**\n\n```Plain\n输入：root = [1,2], p = 1, q = 2\n输出：1\n```\n\n提示：\n\n- 树中节点数目在范围 [2, 105] 内。\n- -109 <= Node.val <= 109\n- 所有 Node.val 互不相同 。\n- p != q\n- p 和 q 均存在于给定的二叉树中。\n\n# 我的题解\n\n## **方法一：层序遍历**\n\n### **思路**\n\n一个非常直观的思路是，从p、q两个节点向上找，找到第一个公共节点，即是最近公共祖先节点。因此我们先层序遍历，记录当前节点的前一节点，再向上查找第一个公共节点，代码如下：\n\n### **代码**\n\n```Java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        queue.offer(root);\n        TreeNode tp = null, tq = null;\n        HashMap<TreeNode, TreeNode> map = new HashMap<>();\n        while (!queue.isEmpty() && (tp == null || tq == null)) {\n            TreeNode poll = queue.poll();\n            if (poll.val == p.val) {\n                tp = poll;\n            }\n            if (poll.val == q.val) {\n                tq = poll;\n            }\n            if (poll.left != null) {\n                queue.offer(poll.left);\n                map.put(poll.left, poll);\n            }\n            if (poll.right != null) {\n                queue.offer(poll.right);\n                map.put(poll.right, poll);\n            }\n        }\n        HashSet<TreeNode> set = new HashSet<>();\n        while (tp != null) {\n            set.add(tp);\n            tp = map.get(tp);\n        }\n        while (tq != null && !set.contains(tq)) {\n            tq = map.get(tq);\n        }\n        return tq;\n    }\n}\n```\n\n### **结果**\n\n执行用时：12 ms, 在所有 Java 提交中击败了6.96%的用户\n\n内存消耗：42 MB, 在所有 Java 提交中击败了98.21%的用户\n\n## **方法二：深度遍历**\n\n### **思路**\n\n一般对于这种题目，我们首先考虑最基本的情况：\n\n- p、q位于root左右两边，那当前节点就是最近公共祖先\n- root==p，q可能位于root左边或右边，那么当前节点就是最近公共祖先\n- root==q，p可能位于root左边或右边，那么当前节点就是最近公共祖先\n\n因此，采用后序遍历：\n\n### **代码**\n\n```Java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root.val == p.val || root.val == q.val) {\n            return root;\n        }\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if (left != null && right != null) {\n            return root;\n        }\n        return left != null ? left : right;\n    }\n}\n```\n\n### **结果**\n\n执行用时：6 ms, 在所有 Java 提交中击败了99.99%的用户\n\n内存消耗：42.9 MB, 在所有 Java 提交中击败了39.74%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"合并两个有序数组","url":"/2023/04/18/合并两个有序数组.html","content":"\n# 题目描述\n\n> 题目链接：[88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)\n\n给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n\n**注意：**最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n\n**示例1：**\n\n```Plain\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n输出：[1,2,2,3,5,6]\n解释：需要合并 [1,2,3] 和 [2,5,6] 。\n合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n```\n\n**示例2：**\n\n```Plain\n输入：nums1 = [1], m = 1, nums2 = [], n = 0\n输出：[1]\n解释：需要合并 [1] 和 [] 。\n合并结果是 [1] 。\n```\n\n**示例3：**\n\n```Plain\n输入：nums1 = [0], m = 0, nums2 = [1], n = 1\n输出：[1]\n解释：需要合并的数组是 [] 和 [1] 。\n合并结果是 [1] 。\n注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n```\n\n提示：\n\n- nums1.length == m + n\n- nums2.length == n\n- 0 <= m, n <= 200\n- 1 <= m + n <= 200\n- -109 <= nums1[i], nums2[j] <= 109\n\n# 我的题解\n\n## **方法一：双指针**\n\n### **思路**\n\n非常经典的有序数组的合并题目，一般这种题目使用双指针即可，不过此题要合并到另一个数组，考虑到顺序结果指针移动时可能会覆盖到原有值，因此我们使用倒叙填充数组。\n\n### **代码**\n\n```Java\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int x = m - 1, y = n - 1;\n        int index = nums1.length - 1;\n        while (x >= 0 && y >= 0) {\n            if (nums1[x] > nums2[y]) {\n                nums1[index--] = nums1[x--];\n            } else {\n                nums1[index--] = nums2[y--];\n            }\n        }\n        while (x >= 0) {\n            nums1[index--] = nums1[x--];\n        }\n        while (y >= 0) {\n            nums1[index--] = nums2[y--];\n        }\n    }\n}\n```\n\n### **结果**\n\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n\n内存消耗：41.1 MB, 在所有 Java 提交中击败了89.79%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"环形链表","url":"/2023/04/18/环形链表.html","content":"\n# 题目描述\n\n> 题目链接：[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)\n\n给你一个链表的头节点 head ，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n\n如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n\n**示例1：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/01.png)\n\n```Plain\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n**示例2：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/02.png)\n\n```Plain\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n```\n\n**示例3：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/03.png)\n\n```Plain\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n```\n\n提示：\n\n- 链表中节点的数目范围是 `[0, 10(4)]`\n- `-10(5) <= Node.val <= 10(5)`\n- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。\n\n# 我的题解\n\n## **方法一：双指针**\n\n### **思路**\n\n这里涉及到一个数学知识，那就是追及问题。当路径呈一个环状时，物体a，b以不同的速度绕着该环运动，那么他们必定会相遇。因此我们使用这个性质来解题：\n\n### **代码**\n\n```Java\nclass Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode p1 = head, p2 = head;\n        while (p2 != null && p2.next != null) {\n            p1 = p1.next;\n            p2 = p2.next.next;\n            if (p1 == p2) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n### **结果**\n\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n\n内存消耗：42.4 MB, 在所有 Java 提交中击败了75.61%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"有效的括号","url":"/2023/04/18/有效的括号.html","content":"\n# 题目描述\n\n> 题目链接：[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n- 左括号必须用相同类型的右括号闭合。\n- 左括号必须以正确的顺序闭合。\n- 每个右括号都有一个对应的相同类型的左括号。\n\n**示例1：**\n\n```Plain\n输入：s = \"()\"\n输出：true\n```\n\n**示例2：**\n\n```Plain\n输入：s = \"()[]{}\"\n输出：true\n```\n\n**示例3：**\n\n```Plain\n输入：s = \"(]\"\n输出：false\n```\n\n提示：\n\n- `1 <= s.length <= 10(4)`\n- `s` 仅由括号 `'()[]{}'` 组成\n\n# 我的题解\n\n## **方法一：栈**\n\n### **思路**\n\n非常经典的栈类型题目，当栈顶字符与当前字符匹配时，出栈即可；反之入栈，类似于消除游戏。最终如果栈为空则表示为有效的括号。\n\n### **代码**\n\n```Java\nclass Solution {\n    public boolean isValid(String s) {\n        if ((s.length() & 1) == 1) {\n            return false;\n        }\n        ArrayDeque<Character> stack = new ArrayDeque<>();\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (!stack.isEmpty() && isMatch(stack.peek(), ch)) {\n                stack.pop();\n            } else {\n                stack.push(ch);\n            }\n        }\n        return stack.isEmpty();\n    }\n\n    private boolean isMatch(char source, char target) {\n        return (source == '(' && target == ')') || (source == '[' && target == ']') || (source == '{' && target == '}');\n    }\n}\n```\n\n### **结果**\n\n执行用时：2 ms, 在所有 Java 提交中击败了52.71%的用户\n\n内存消耗：39.4 MB, 在所有 Java 提交中击败了63.30%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"岛屿数量","url":"/2023/04/18/岛屿数量.html","content":"\n# 题目描述\n\n> 题目链接：[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)\n\n给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\n岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n\n此外，你可以假设该网格的四条边均被水包围。\n\n**示例1：**\n\n```Plain\n输入：grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n输出：1\n```\n\n**示例2：**\n\n```Plain\n输入：grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n输出：3\n```\n\n提示：\n\n- `m == grid.length`\n- `n == grid[i].length`\n- `1 <= m, n <= 300`\n- `grid[i][j]` 的值为 `'0'` 或 `'1'`\n\n# 我的题解\n\n## 主要思路\n\n这道题的思路非常直观，很容易让人想到以当前坐标出发，遍历到岛屿边界，并将结果+1即可。值得注意的地方是遍历过的坐标无需再遍历，因此我们可以设置一个标识变量来记录，当然这里我就直接改变原数组，也能达到最终效果。下面以深度遍历和广度遍历两种方法实现：\n\n## **方法一：深度遍历**\n\n### **思路**\n\n见主要思路\n\n### **代码**\n\n```Java\nclass Solution {\n    public int numIslands(char[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int result = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    dfs(grid, i, j);\n                    result++;\n                }\n            }\n        }\n        return result;\n    }\n\n    private void dfs(char[][] grid, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') {\n            return;\n        }\n        grid[i][j] = '0';\n        //上\n        dfs(grid, i - 1, j);\n        //右\n        dfs(grid, i, j + 1);\n        //下\n        dfs(grid, i + 1, j);\n        //左\n        dfs(grid, i, j - 1);\n    }\n}\n```\n\n### **结果**\n\n执行用时：2 ms, 在所有 Java 提交中击败了100.00%的用户\n\n内存消耗：49.7 MB, 在所有 Java 提交中击败了61.75%的用户\n\n## **方法二：广度遍历**\n\n### **思路**\n\n见主要思路\n\n### **代码**\n\n```Java\nclass Solution {\n    public int numIslands(char[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int result = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    bfs(grid, i, j);\n                    result++;\n                }\n            }\n        }\n        return result;\n    }\n\n    private void bfs(char[][] grid, int i, int j) {\n        Queue<int[]> queue = new ArrayDeque<>();\n        grid[i][j] = '0';\n        queue.offer(new int[]{i, j});\n        while (!queue.isEmpty()) {\n            int[] poll = queue.poll();\n            int x = poll[0];\n            int y = poll[1];\n            //上\n            if (x - 1 >= 0 && grid[x - 1][y] == '1') {\n                grid[x - 1][y] = '0';\n                queue.offer(new int[]{x - 1, y});\n            }\n            //右\n            if (y + 1 < grid[0].length && grid[x][y + 1] == '1') {\n                grid[x][y + 1] = '0';\n                queue.offer(new int[]{x, y + 1});\n            }\n            //下\n            if (x + 1 < grid.length && grid[x + 1][y] == '1') {\n                grid[x + 1][y] = '0';\n                queue.offer(new int[]{x + 1, y});\n            }\n            //左\n            if (y - 1 >= 0 && grid[x][y - 1] == '1') {\n                grid[x][y - 1] = '0';\n                queue.offer(new int[]{x, y - 1});\n            }\n        }\n    }\n}\n```\n\n### **结果**\n\n执行用时：4 ms, 在所有 Java 提交中击败了33.41%的用户\n\n内存消耗：48.7 MB, 在所有 Java 提交中击败了96.37%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"买卖股票的最佳时机","url":"/2023/04/18/买卖股票的最佳时机.html","content":"\n# 题目描述\n\n> 题目链接：[121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)\n\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n**示例1：**\n\n```Plain\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n\n**示例2：**\n\n```Plain\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n提示：\n\n- `1 <= prices.length <= 10(5)`\n- `0 <= prices[i] <= 10(4)`\n\n# 我的题解\n\n## **方法一：一次遍历**\n\n### **思路**\n\n由题目可得知两个**关键信息**\n\n- 只交易一次\n- 当天买入且只能在未来某天卖出\n\n我们很自然地能够想到，用花最少的钱再以最高的价格卖出，因此我们可以使用一个变量来维护遍历过程中所遇到的最小值，并且用当天的价格减去这个最小值，即可获得**（当天价格-当天及以前的最小值）**，这个值的最大值即代表：**当天及以前买卖所能获得的最大利润**。\n\n### **代码**\n\n```Java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int min = Integer.MAX_VALUE;\n        int result = 0;\n        for (int price : prices) {\n            min = Math.min(min, price);\n            result = Math.max(result, price - min);\n        }\n        return result;\n    }\n}\n```\n\n### **结果**\n\n执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户\n\n内存消耗：57.6 MB, 在所有 Java 提交中击败了49.93%的用户\n","tags":["算法题"],"categories":["算法练习"]},{"title":"最长回文子串","url":"/2023/04/18/最长回文子串.html","content":"\n# 题目描述\n\n> 题目链接：[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/?favorite=2cktkvj)\n\n给你一个字符串 `s`，找到 `s` 中最长的回文子串。\n\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n\n**示例1：**\n\n```Plain\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n```\n\n**示例2：**\n\n```Plain\n输入：s = \"cbbd\"\n输出：\"bb\"\n```\n\n提示：\n\n- `1 <= s.length <= 1000`\n- `s` 仅由数字和英文字母组成\n\n# 我的题解\n\n## **方法一：动态规划**\n\n### **思路**\n\n假设`dp[i][j]`表示字符串`s`下标从`i~j`的子字符串是否为回文串，那么有以下转移方程：\n\n- 若`i==j`，表示子字符串有一个字符，为回文串，因此`dp[i][j]=true`\n- 若`i==j-1`，表示子字符串有两个字符\n    - 若`s[i]==s[j]`，则`dp[i][j]=true`\n    - 若`s[i]!=s[j]`，则`dp[i][j]=false`\n- 否则表示子字符串拥有两个以上字符\n    - 若`s[i]==s[j]`并且`dp[i+1][j-1]==true`，则`dp[i][j]=true`\n    - 否则`dp[i][j]=false`\n\n在具体编写代码时需要考虑两个问题：\n\n1. 由于子字符串必定存在，因此`j >= i`\n2. 由于`dp[i][j] = (s[i]==s[j] && dp[i+1][j-1]==true)`，因此在遍历`dp`数组时，应从左下角开始遍历。\n\n图示第二个问题，假设字符串长度为5：\n\n暂时无法在飞书文档外展示此内容\n\n### **代码**\n\n```Java\nclass Solution {\n    public String longestPalindrome(String s) {\n        int m = s.length(), start = 0, end = 0;\n        boolean[][] dp = new boolean[m][m];\n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = i; j < m; j++) {\n                boolean b = (s.charAt(i) == s.charAt(j));\n                if (j - i <= 1) {\n                    // 子字符串为一个字符或两个字符组成的情况\n                    dp[i][j] = b;\n                } else if (i + 1 < m && j - 1 >= 0) {\n                    // 子字符串为两个以上字符组成的情况\n                    dp[i][j] = (b && dp[i + 1][j - 1]);\n                }\n                // 记录子字符串位置\n                if (dp[i][j] && j - i > end - start) {\n                    start = i;\n                    end = j;\n                }\n            }\n        }\n        return s.substring(start, end + 1);\n    }\n}\n```\n\n## **方法二：中心扩展法**\n\n### **思路**\n\n观察回文串我们发现：\n\n- 只有一个字符的为回文串\n- 有两个字符并且两个字符相同的字符串为回文串\n- 其他回文串都由一个字符或两个字符扩展而成\n\n因此，我们可以遍历字符串，以当前字符，以及当前字符和相邻字符为中心，向两边扩展，直到不能扩展为止。\n\n### **代码**\n\n```Java\nclass Solution {\n    public String longestPalindrome(String s) {\n        int max = 0, start = 0, end = 0;\n        for (int i = 0; i < s.length() - 1; i++) {\n            // 以当前字符为中心向两边扩展\n            int len1 = expand(s, i, i);\n            // 以当前字符与相邻字符为中心向两边扩展\n            int len2 = expand(s, i, i + 1);\n            int len = Math.max(len1, len2);\n            if (max < len) {\n                max = len;\n                // 重新计算子字符串位置\n                start = i - (len - 1) / 2;\n                end = i + len / 2;\n            }\n        }\n        return s.substring(start, end + 1);\n    }\n\n    private int expand(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n\n}\n```\n","tags":["算法题"],"categories":["算法练习"]},{"title":"无重复字符的最长子串","url":"/2023/04/18/无重复字符的最长子串.html","content":"\n# 题目描述\n\n> 题目链接：[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?favorite=2cktkvj)\n\n给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。\n\n**示例1：**\n\n```Plain\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n**示例2：**\n\n```Plain\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例3：**\n\n```Plain\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n提示：\n\n- `0 <= s.length <= 5 * 10(4)`\n- `s` 由英文字母、数字、符号和空格组成\n\n# 我的题解\n\n## **方法一：哈希表+滑动窗口**\n\n### **思路**\n\n使用左右指针记录滑动窗口的左边界和右边界，使用哈希表记录每个字符出现的位置，加速指针移动位置。\n\n1. 遍历字符串，如果当前字符串出现过，则更新左指针位置为最远位置\n2. 更新结果\n3. 将当前字符与位置加入哈希表\n4. 移动一位右指针\n\n### **代码**\n\n```Java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int l = 0, r = 0, result = 0;\n        HashMap<Character, Integer> map = new HashMap<>();\n        while (r < s.length()) {\n            char ch = s.charAt(r);\n            if (map.containsKey(ch)) {\n                // 移动左指针\n                l = Math.max(l, map.get(ch) + 1);\n            }\n            // 更新结果\n            result = Math.max(result, r - l + 1);\n            // 记录字符位置，移动右指针\n            map.put(ch, r++);\n        }\n        return result;\n    }\n}\n```\n\n由题目可知，字符串由英文字母、数字、符号和空格组成，我们也可以使用数组作为哈希表，由于数组中的元素默认值为0，因此我们要记录字符的下一个位置：\n\n```Java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int l = 0, r = 0, result = 0;\n        int[] map = new int[128];\n        while (r < s.length()) {\n            char ch = s.charAt(r);\n            // 移动左指针\n            l = Math.max(l, map[ch]);\n            // 更新结果\n            result = Math.max(result, r - l + 1);\n            // 记录字符的下一个位置，移动右指针\n            map[ch] = ++r;\n        }\n        return result;\n    }\n}\n```\n","tags":["算法题"],"categories":["算法练习"]},{"title":"两数相加","url":"/2023/04/18/两数相加.html","content":"\n# 题目描述\n\n> 题目链接：[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/?favorite=2cktkvj)\n\n给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n**示例1：**\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/01.png)\n\n```Plain\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807.\n```\n\n**示例2：**\n\n```Plain\n输入：l1 = [0], l2 = [0]\n输出：[0]\n```\n\n**示例3：**\n\n```Plain\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n```\n\n提示：\n\n- 每个链表中的节点数在范围 `[1, 100]` 内\n- `0 <= Node.val <= 9`\n- 题目数据保证列表表示的数字不含前导零\n\n# 我的题解\n\n## **方法一：模拟**\n\n### **思路**\n\n我们同时遍历两个链表，逐位计算它们的和，并与进位值相加。如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个0，这样不影响最后的计算结果。\n\n同时，如果最后进位值不为零，也需要再添加一个节点。\n\n### **代码**\n\n```Java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head = null, tail = null;\n        int c = 0;\n        while (l1 != null || l2 != null || c != 0) {\n            int n1 = l1 != null ? l1.val : 0;\n            int n2 = l2 != null ? l2.val : 0;\n            int sum = n1 + n2 + c;\n            if (head == null) {\n                head = tail = new ListNode(sum % 10);\n            } else {\n                tail.next = new ListNode(sum % 10);\n                tail = tail.next;\n            }\n            c = sum / 10;\n            if (l1 != null) {\n                l1 = l1.next;\n            }\n            if (l2 != null) {\n                l2 = l2.next;\n            }\n        }\n        return head;\n    }\n}\n```\n","tags":["算法题"],"categories":["算法练习"]},{"title":"两数之和","url":"/2023/04/18/两数之和.html","content":"\n# 题目描述\n\n> 题目链接：[1. 两数之和](https://leetcode.cn/problems/two-sum/description/?favorite=2cktkvj)\n\n给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`*  的那 **两个** 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n**示例1：**\n\n```Plain\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n```\n\n**示例2：**\n\n```Plain\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n```\n\n**示例3：**\n\n```Plain\n输入：nums = [3,3], target = 6\n输出：[0,1]\n```\n\n提示：\n\n- `2 <= nums.length <= 10(4)`\n- `-10(9) <= nums[i] <= 10(9)`\n- `-10(9) <= target <= 10(9)`\n- **只会存在一个有效答案**\n\n# 我的题解\n\n## **方法一：哈希表**\n\n### **思路**\n\n假设当前遍历到的数字为 `x`，创建一个哈希表，对于每一个 `x`，我们首先查询哈希表中是否存在 `target - x`，然后将 `x` 插入到哈希表中，即可保证不会让 `x` 和自己匹配。\n\n### **代码**\n\n```Java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int temp = target - nums[i];\n            if (map.containsKey(temp)) {\n                return new int[]{map.get(temp), i};\n            }\n            map.put(nums[i], i);\n        }\n        return new int[]{-1, -1};\n    }\n}\n```\n","tags":["算法题"],"categories":["算法练习"]},{"title":"手写LRU算法","url":"/2023/04/16/手写LRU算法.html","content":"\n# 功能\n\n设计并实现一个满足  [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。\n\n实现 `LRUCache` 类：\n\n- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存\n- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。\n- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。\n\n函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。\n\n# 思路\n\n`LRU`缓存机制可以通过**哈希表**辅以**双向链表**实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。\n\n双向链表按照被使用的顺序存储了这些键值对，**靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。**\n\n哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。\n\n这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在`O(1)`的时间内完成`get`或者`put`操作。具体的方法如下：\n\n- 对于`get`操作，首先判断`key`是否存在：\n    - 如果`key`不存在，则返回 −1；\n    - 如果`key`存在，则`key`对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。\n- 对于`put`操作，首先判断`key`是否存在：\n    - 如果`key`不存在，使用`key`和`value`创建一个新的节点，在双向链表的头部添加该节点，并将`key`和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；\n    - 如果`key`存在，则与`get`操作类似，先通过哈希表定位，再将对应的节点的值更新为`value`，并将该节点移到双向链表的头部。\n\n上述各项操作中，访问哈希表的时间复杂度为`O(1)`，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为`O(1)`。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在`O(1)`时间内完成。\n\n> 在双向链表的实现中，使用一个**伪头部（dummy head）**和**伪尾部（dummy tail）**标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。\n\n# 演示\n\n以下操作演示`LRUCache`中数据的变化。\n\n```Java\n输入\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n解释\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n```\n\n1. `LRUCache lRUCache = new LRUCache(2)`\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%89%8B%E5%86%99LRU%E7%AE%97%E6%B3%95/01.jpg)\n\n2. `lRUCache.put(1, 1)`\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%89%8B%E5%86%99LRU%E7%AE%97%E6%B3%95/02.jpg)\n\n3. `lRUCache.put(2, 2)`\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%89%8B%E5%86%99LRU%E7%AE%97%E6%B3%95/03.jpg)\n\n4. `lRUCache.get(1)`，返回1\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%89%8B%E5%86%99LRU%E7%AE%97%E6%B3%95/04.jpg)\n\n5. `lRUCache.put(3, 3)`，该操作会使得关键字2作废\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%89%8B%E5%86%99LRU%E7%AE%97%E6%B3%95/05.jpg)\n\n6. `lRUCache.get(2)`，返回-1(未找到)\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%89%8B%E5%86%99LRU%E7%AE%97%E6%B3%95/06.jpg)\n\n7. `lRUCache.put(4, 4)`\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%89%8B%E5%86%99LRU%E7%AE%97%E6%B3%95/07.jpg)\n\n8. `lRUCache.get(1)`，返回-1(未找到)\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%89%8B%E5%86%99LRU%E7%AE%97%E6%B3%95/08.jpg)\n\n9. `lRUCache.get(3)`，返回3\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%89%8B%E5%86%99LRU%E7%AE%97%E6%B3%95/09.jpg)\n\n10. `lRUCache.get(4)`，返回4\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%89%8B%E5%86%99LRU%E7%AE%97%E6%B3%95/10.jpg)\n\n# 代码\n\n```Java\nclass LRUCache {\n\n    /**\n     * 容量\n     */\n    private final int capacity;\n\n    /**\n     * 头节点\n     */\n    private final Node head;\n\n    /**\n     * 尾节点\n     */\n    private final Node tail;\n\n    /**\n     * hash表\n     */\n    private final HashMap<Integer, Node> map;\n\n    /**\n     * 构造方法\n     * @param capacity\n     */\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new HashMap<>();\n        head = new Node();\n        tail = new Node();\n        head.next = tail;\n        tail.pre = head;\n    }\n\n    /**\n     * get方法\n     * @param key\n     * @return\n     */\n    public int get(int key) {\n        if (!map.containsKey(key)) {\n            return -1;\n        }\n        Node node = map.get(key);\n        moveNodeToHead(node);\n        return node.value;\n    }\n\n    /**\n     * 将节点移动到头部\n     * @param node\n     */\n    private void moveNodeToHead(Node node) {\n        deletedNode(node);\n        addNodeToHead(node);\n    }\n\n    /**\n     * 从双向链表中删除节点\n     * @param node\n     */\n    private void deletedNode(Node node) {\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n    }\n\n    /**\n     * 添加节点到双向链表头部\n     * @param node\n     */\n    private void addNodeToHead(Node node) {\n        node.next = head.next;\n        head.next.pre = node;\n        node.pre = head;\n        head.next = node;\n    }\n\n    /**\n     * put方法\n     * @param key\n     * @param value\n     */\n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            node.value = value;\n            moveNodeToHead(node);\n        } else {\n            if (map.size() >= capacity) {\n                //删除最后元素\n                Node preNode = tail.pre;\n                map.remove(preNode.key);\n                deletedNode(preNode);\n            }\n            Node node = new Node(key, value);\n            map.put(key, node);\n            addNodeToHead(node);\n        }\n    }\n\n    private class Node {\n        public int key;\n        public int value;\n        public Node pre;\n        public Node next;\n\n        public Node() {\n        }\n\n        public Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n}\n```\n","tags":["算法题"],"categories":["手写系列"]},{"title":"Spring高级45讲【第六章】：OTHER","url":"/2023/04/15/Spring高级45讲【第六章】：OTHER.html","content":"\n# **FactoryBean**\n\n`FactoryBean`是一个工厂`Bean`，是用来产生产品对象的，`FactoryBean`本身是由`spring`管理的，但其产生的产品类却是部分受到`srping`的管理，为什么这么说呢？下面做一个试验：\n\n创建一个`Bean2`，由`spring`进行管理：\n\n```Java\n@Component\npublic class Bean2 {\n}\n```\n\n创建一个`Bean1`，注意不直接交由`spring`管理，没有加`@Component`注解，但实现了`BeanFactoryAware`接口，我们看看在`Bean1`创建的各个时期会不会回调实现的方法。\n\n```Java\npublic class Bean1 implements BeanFactoryAware {\n    private static final Logger log = LoggerFactory.getLogger(Bean1.class);\n\n    private Bean2 bean2;\n\n    @Autowired\n    public void setBean2(Bean2 bean2) {\n        log.debug(\"setBean2({})\", bean2);\n        this.bean2 = bean2;\n    }\n\n    public Bean2 getBean2() {\n        return bean2;\n    }\n\n    @PostConstruct\n    public void init() {\n        log.debug(\"init\");\n    }\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n        log.debug(\"setBeanFactory({})\", beanFactory);\n    }\n}\n```\n\n接下来创建一个`Bean1FactoryBean`，其实现了`FactoryBean`接口，泛型为`Bean1`，即生成类型为`Bean1`的`bean`，其中主要实现了三个方法：\n\n1. `getObjectType()`：获取生成的`Bean`的类型\n2. `isSingleton()`：是否是单例，`true`为单例，`false`为多例\n3. `getObject()`：具体生成`Bean`的逻辑\n\n注意`Bean1FactoryBean`添加了`@Component(\"bean1\")`注解，交由`spring`进行管理，取名为`\"bean1\"`\n\n```Java\n@Component(\"bean1\")\npublic class Bean1FactoryBean implements FactoryBean<Bean1> {\n\n    private static final Logger log = LoggerFactory.getLogger(Bean1FactoryBean.class);\n\n    // 决定了根据【类型】获取或依赖注入能否成功\n    @Override\n    public Class<?> getObjectType() {\n        return Bean1.class;\n    }\n\n    // 决定了 getObject() 方法被调用一次还是多次\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n\n    @Override\n    public Bean1 getObject() throws Exception {\n        Bean1 bean1 = new Bean1();\n        log.debug(\"create bean: {}\", bean1);\n        return bean1;\n    }\n}\n```\n\n编写启动类:\n\n```Java\n@ComponentScan\npublic class A43 {\n\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A43.class);\n        Bean1 bean1 = (Bean1) context.getBean(\"bean1\");\n        System.out.println(bean1);\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 21:22:32.003 [main] com.itheima.a43.Bean1FactoryBean    - create bean: com.itheima.a43.Bean1@60bd273d \ncom.itheima.a43.Bean1@60bd273d\n```\n\n我们根据名称获取`Bean`，比较奇怪的一点是我们获取的名称是`\"bean1\"`，在一般情况下获取的应该是`@Component(\"bean1\")`注解标注的类型，而`Bean1FactoryBean`获取的却是其生成的产品的类型，即`Bean1`。\n\n观察输出，我们发现`Bean1`并不是由`spring`创建的，在创建过程中并没有调用**依赖注入、初始化方法、****`setBeanFactory()`**等方法。但`spring`并不是完全没有参与产品类的创建，我们给`Bean1`添加一个后处理器，分别在`Bean1`初始化前和初始化打印相应日志：\n\n```Java\n@Component\npublic class Bean1PostProcessor implements BeanPostProcessor {\n\n    private static final Logger log = LoggerFactory.getLogger(Bean1PostProcessor.class);\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        if (beanName.equals(\"bean1\") && bean instanceof Bean1) {\n            log.debug(\"before [{}] init\", beanName);\n        }\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        if (beanName.equals(\"bean1\") && bean instanceof Bean1) {\n            log.debug(\"after [{}] init\", beanName);\n        }\n        return bean;\n    }\n}\n```\n\n`BeanPostProcessor`可以在`Bean`初始化前做一些增强，也可以在`Bean`初始化后做一些增强。\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 21:29:51.019 [main] com.itheima.a43.Bean1FactoryBean    - create bean: com.itheima.a43.Bean1@38cee291 \n[DEBUG] 21:29:51.038 [main] com.itheima.a43.Bean1PostProcessor  - after [bean1] init \ncom.itheima.a43.Bean1@38cee291\n```\n\n我们发现初始化前的增强逻辑没有调用，却调用了初始化后增强的逻辑，而**创建代理**就是在`Bean`初始化后进行的，因此产品对象是可以通过代理增强的。\n\n所以说产品对象部分受`spring`管理。\n\n注意产品对象单例并没有存放在`BeanFcatory`的单例池中，而是存在`BeanFactory`的`factoryBeanObjectCache`成员中。\n\n另外，如果我们在`getObjectType()`方法中返回`null`，那么通过类型获取`Bean`的时候会报错：\n\n```Plain\nException in thread \"main\" org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.itheima.a43.Bean1' available\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:351)\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:342)\n        at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1172)\n        at com.itheima.a43.A43.main(A43.java:19)\n```\n\n如果要获取`FactoryBean`本身，有两种方式：\n\n1. 通过类型获取\n2. 通过$+bean名称获取\n\n```Java\nSystem.out.println(context.getBean(Bean1FactoryBean.class));\nSystem.out.println(context.getBean(\"&bean1\"));\n```\n\n**FactoryBean总结：**\n\n1. 它的作用是用制造创建过程较为复杂的产品，如`SqlSessionFactory`, 但`@Bean`已具备等价功能\n2. 被`FactoryBean`创建的产品\n    1. 会认为创建、依赖注入、`Aware`接口回调、前初始化这些操作都是`FactoryBean`的职责, 这些流程都不会走\n    2. 唯有后初始化的流程会走, 也就是产品可以被代理增强\n    3. 单例的产品不会存储于`BeanFactory`的`singletonObjects`成员中, 而是另一个 `factoryBeanObjectCache`成员中\n3.  按名字去获取时, 拿到的是产品对象, 名字前面加`&`获取的是工厂对象\n\n# **@Indexed原理**\n\n`spring`组件扫描的效率是非常低的，会扫描包下的所有类，一个一个解析注解，如果有`@Component`、`@Bean`等注解的话，就会生成`BeanDefinition`并加入容器中。`spring`的扫描范围非常大，会影响到`spring`的启动速度。因此，`spring`在5.0中做了一个优化，能解决此问题。\n\n编写测试代码：\n\n```Java\n@Component\npublic class Bean1 {\n}\n\n@Component\npublic class Bean2 {\n}\n\n@Component\npublic class Bean3 {\n}\n\npublic class A44 {\n    public static void main(String[] args) throws IOException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n        // 组件扫描的核心类\n        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(beanFactory);\n        scanner.scan(A44.class.getPackageName());\n\n        for (String name : beanFactory.getBeanDefinitionNames()) {\n            System.out.println(name);\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nbean1\nbean2\nbean3\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\norg.springframework.context.event.internalEventListenerProcessor\norg.springframework.context.event.internalEventListenerFactory\n```\n\n`bean1`、`bean2`、`bean3`都被加入到了容器中。\n\n接下来我们添加依赖：\n\n```XML\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context-indexer</artifactId>\n    <optional>true</optional>\n</dependency>\n```\n\n并在`target/classes`目录下创建`META-INF/spring.components`文件，其内容为：\n\n```Properties\ncom.itheima.a44.Bean1=org.springframework.stereotype.Component\n```\n\n再次运行启动类，查看控制台：\n\n```Plain\nbean1\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\norg.springframework.context.event.internalEventListenerProcessor\norg.springframework.context.event.internalEventListenerFactory\n```\n\n发现只有`bean1`被加入了容器中。\n\n为什么呢？\n\n在`spring`5.0以后`ClassPathBeanDefinitionScanner`的`scan()`方法并不是首先进行包扫描，它首先是找一个位于`target/classesMETA-INF`目录下的`spring.components`文件。如果这个文件提供了`Bean`的名称，则优先加载此文件中的`Bean`，后续就不会再走`jar`包扫描的过程了。\n\n`spring.components`的配置格式为：\n\n1. `key`为类的路径\n2. `value`为类上添加的注解\n\n还记得我们添加的`spring-context-indexer`坐标吗？这个依赖的作用就是在编译阶段去找添加了`@Index`注解的类，如果有就生成位置文件加入到`spring.components`中。我们点开`@Component`注解：\n\n```Java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Indexed\npublic @interface Component {\n    String value() default \"\";\n}\n```\n\n发现`@Component`注解组合了`@Indexed`注解。但此时我们手动创建了这个文件，因此`spring`会直接使用我们创建的文件，而不是生成`spring.components`文件。\n\n`@Indexed`的作用就是在**编译阶段**，解析`@Indexed`注解，在`target/classesMETA-INF`目录下生成`spring.components`文件，在运行时直接读取此文件加载`BeanDefinition`而不是重新扫描包。\n\n**`@Indexed`****总结：**\n\n1. `@Indexed`的原理，在**编译时**就根据`@Indexed`生成`META-INF/spring.components`文件， 扫描时如果发现`META-INF/spring.components`存在, 则以它为准加载`BeanDefinition`\n2. 否则, 会遍历包下所有`class`资源 (包括`jar`内的)\n\n# **代理进一步理解**\n\n`spring`代理有几个特点：\n\n1. **依赖注入和初始化**影响的是原始对象\n2. 代理与目标是两个对象，二者成员变量并不共用数据\n3. `static`方法、`final`方法、`private`方法均无法增强\n\n代码演示第1个特点：\n\n创建`Bean1`类，其中有初始化方法、依赖注入方法。\n\n```Java\n@Component\npublic class Bean1 {\n\n    private static final Logger log = LoggerFactory.getLogger(Bean1.class);\n\n    protected Bean2 bean2;\n\n    protected boolean initialized;\n\n    @Autowired\n    public void setBean2(Bean2 bean2) {\n        log.debug(\"setBean2(Bean2 bean2)\");\n        this.bean2 = bean2;\n    }\n\n    @PostConstruct\n    public void init() {\n        log.debug(\"init\");\n        initialized = true;\n    }\n\n    public Bean2 getBean2() {\n        log.debug(\"getBean2()\");\n        return bean2;\n    }\n\n    public boolean isInitialized() {\n        log.debug(\"isInitialized()\");\n        return initialized;\n    }\n\n}\n```\n\n创建切面`MyAspect` ，对`Bean1`中的所有方法进行增强。\n\n```Java\n@Aspect\n@Component\npublic class MyAspect {\n\n    @Before(\"execution(* com.itheima.a45.Bean1.*(..))\")\n    public void before() {\n        System.out.println(\"before\");\n    }\n}\n```\n\n创建启动类：\n\n```Java\n@SpringBootApplication\npublic class A45 {\n\n    public static void main(String[] args) throws Exception {\n        ConfigurableApplicationContext context = SpringApplication.run(A45.class, args);\n\n        Bean1 proxy = context.getBean(Bean1.class);\n        System.out.println(proxy.getBean2());\n        System.out.println(proxy.isInitialized());\n        context.close();\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 17:07:35.297 [main] com.itheima.a45.Bean1               - setBean2(Bean2 bean2) \n[DEBUG] 17:07:35.297 [main] com.itheima.a45.Bean1               - init \nbefore\n[DEBUG] 17:07:35.913 [main] com.itheima.a45.Bean1               - getBean2() \ncom.itheima.a45.Bean2@1a1c21b4\nbefore\n[DEBUG] 17:07:35.913 [main] com.itheima.a45.Bean1               - isInitialized() \ntrue\n```\n\n我们发现，在初始化和依赖注入的时候代理是不生效的，说明在这两个阶段使用的是`Bean`的原始对象；我们拿`Bean`的实例时，实际上拿到的时`Bean`的代理对象，此时代理才生效。\n\n代码演示第2个特点：\n\n编写方法打印代理对象与目标对象的属性值：\n\n```Java\npublic static void showProxyAndTarget(Bean1 proxy) throws Exception {\n    System.out.println(\">>>>> 代理中的成员变量\");\n    System.out.println(\"\\tinitialized=\" + proxy.initialized);\n    System.out.println(\"\\tbean2=\" + proxy.bean2);\n\n    if (proxy instanceof Advised advised) {\n        System.out.println(\">>>>> 目标中的成员变量\");\n        Bean1 target = (Bean1) advised.getTargetSource().getTarget();\n        System.out.println(\"\\tinitialized=\" + target.initialized);\n        System.out.println(\"\\tbean2=\" + target.bean2);\n    }\n}\n```\n\n调用此方法，查看控制台：\n\n```Plain\n>>>>> 代理中的成员变量\n        initialized=false\n        bean2=null\n>>>>> 目标中的成员变量\n        initialized=true\n        bean2=com.itheima.a45.Bean2@640d604\n```\n\n我们发现代理对象中的成员变量是没有值的，因为代理对象没有参与依赖注入、初始化的过程，而目标对象中的成员变量是有值的。一般我们使用的是代理对象，而访问代理对象的属性时一般通过`get`、`set`方法，最终会访问目标对象中的值。\n\n代码演示第3个特点：\n\n在`Bean1`类中增加以下几个方法：\n\n```Java\npublic void m1() {\n    System.out.println(\"m1() 成员方法\");\n}\n\nfinal public void m2() {\n    System.out.println(\"m2() final 方法\");\n    \n    \n    \n}\n\n}\n\nstatic public void m3() {\n    System.out.println(\"m3() static 方法\");\n}\n\nprivate void m4() {\n    System.out.println(\"m4() private 方法\");\n}\n```\n\n然后通过代理对象调用：\n\n```Java\nBean1 proxy = context.getBean(Bean1.class);\nproxy.m1();\nproxy.m2();\nproxy.m3();\nMethod m4 = Bean1.class.getDeclaredMethod(\"m4\");\nm4.setAccessible(true);\nm4.invoke(proxy);\n```\n\n查看控制台：\n\n```Plain\nbefore\nm1() 成员方法\nm2() final 方法\nm3() static 方法\nm4() private 方法\n```\n\n只有成员方法被增强了。\n\n`static`方法、`final`方法、`private`方法这些方法都不能使用方法重写机制进行增强，如果需要增强可以使用`aspectj`或者`agent`等在编译时增强的方式。\n\n# **@Value装配底层**\n\n编写代码手动解析`@Value`注解：\n\n首先编写`Bean1`，其中使用`@Value`注解注入了两个值，`home`属性从环境变量中取值，`age`属性的值是固定的。\n\n```Java\npublic class Bean1 {\n    @Value(\"${JAVA_HOME}\")\n    private String home;\n    @Value(\"18\")\n    private int age;\n}\n```\n\n编写`main()`方法，创建容器并创建解析器。\n\n```Java\npublic static void main(String[] args) throws Exception {\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A46.class);\n    DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n    ContextAnnotationAutowireCandidateResolver resolver = new ContextAnnotationAutowireCandidateResolver();\n    resolver.setBeanFactory(beanFactory);\n}\n```\n\n编写测试，其中`DependencyDescriptor`构造方法有两个参数：\n\n1. 传入需要解析的字段\n2. 是否必须有这个字段，如果为`true`，则必须要有此字段；为`false`，没有此字段则会报错\n\n```Java\nprivate static void test1(AnnotationConfigApplicationContext context, ContextAnnotationAutowireCandidateResolver resolver, Field field) {\n    DependencyDescriptor dd1 = new DependencyDescriptor(field, false);\n    // 获取 @Value 的内容\n    String value = resolver.getSuggestedValue(dd1).toString();\n    System.out.println(value);\n    // 解析 ${}\n    value = context.getEnvironment().resolvePlaceholders(value);\n    System.out.println(value);\n}\n```\n\n在`main()`方法中调用`test1()`：\n\n```Java\ntest1(context, resolver, Bean1.class.getDeclaredField(\"home\"));\ntest1(context, resolver, Bean1.class.getDeclaredField(\"age\"));\n```\n\n查看输出：\n\n```Plain\n${JAVA_HOME}\nC:\\Path\\jdk-14.0.1\n18\n18\n```\n\n能正确解析`@Value`注解中的值。\n\n实际上在以上代码中并没有做类型转换的功能，我们可以打印一下类型：\n\n```Java\nSystem.out.println(value.getClass());\n```\n\n查看输出：\n\n```Plain\n${JAVA_HOME}\nC:\\Path\\jdk-14.0.1\nclass java.lang.String\n18\n18\nclass java.lang.String\n```\n\n发现`age`也是`String`类型，说明此时只解析了数据但没有进行类型转换，我们手动做一下类型转换，使用的是`spring`提供的高级类型转换器：\n\n```Java\nprivate static void test2(AnnotationConfigApplicationContext context, ContextAnnotationAutowireCandidateResolver resolver, Field field) {\n    DependencyDescriptor dd1 = new DependencyDescriptor(field, false);\n    // 获取 @Value 的内容\n    String value = resolver.getSuggestedValue(dd1).toString();\n    System.out.println(value);\n    // 解析 ${}\n    value = context.getEnvironment().resolvePlaceholders(value);\n    System.out.println(value);\n    System.out.println(value.getClass());\n    Object age = context.getBeanFactory().getTypeConverter().convertIfNecessary(value, dd1.getDependencyType());\n    System.out.println(age.getClass());\n}\n```\n\n再次运行，查看输出：\n\n```Plain\n${JAVA_HOME}\nC:\\Path\\jdk-14.0.1\nclass java.lang.String\nclass java.lang.String\n18\n18\nclass java.lang.String\nclass java.lang.Integer\n```\n\n成功进行了类型转换。\n\n`@Value`注解除了能进行值注入，也支持依赖注入，可以使用`spel`表达式，以下代码就是通过`spel`表达式在`Bean2`中注入名称为`bean3`的`Bean`。\n\n```Java\npublic class Bean2 {\n    @Value(\"#{@bean3}\") \n    private Bean3 bean3;\n}\n\n@Component(\"bean3\")\npublic class Bean3 {\n}\n```\n\n要解析类似`#{}`的`spel`表达式，我们需要使用到`BeanExpressionResolver`：\n\n```Java\nprivate static void test3(AnnotationConfigApplicationContext context, ContextAnnotationAutowireCandidateResolver resolver, Field field) {\n    DependencyDescriptor dd1 = new DependencyDescriptor(field, false);\n    // 获取 @Value 的内容\n    String value = resolver.getSuggestedValue(dd1).toString();\n    System.out.println(value);\n\n    // 解析 ${}\n    value = context.getEnvironment().resolvePlaceholders(value);\n    System.out.println(value);\n    System.out.println(value.getClass());\n\n    // 解析 #{}\n    Object bean3 = context.getBeanFactory().getBeanExpressionResolver().evaluate(value, new BeanExpressionContext(context.getBeanFactory(), null));\n\n    // 类型转换\n    Object result = context.getBeanFactory().getTypeConverter().convertIfNecessary(bean3, dd1.getDependencyType());\n    System.out.println(result);\n}\n```\n\n调用`test3()`方法：\n\n```Java\ntest3(context, resolver, Bean2.class.getDeclaredField(\"bean3\"));\n```\n\n查看输出：\n\n```Plain\n#{@bean3}\n#{@bean3}\nclass java.lang.String\ncom.itheima.a46.A46$Bean3@1c9b0314\n```\n\n`@Value`注解底层执行的顺序就和上面的顺序类似：\n\n1. 首先获取`@Value`原始内容\n2. 解析`${}`表达式\n3. 解析`#{}`表达式\n4. 进行必要的类型转换\n\n`@Value`中还可以进行嵌套解析，例如`Bean4`中内层嵌套了`${}`表达式，外侧嵌套了`#{}`表达式，同时`#{}`也支持拼接操作，解析的步骤就是先解析内层，再解析外层。\n\n```Java\nstatic class Bean4 {\n    @Value(\"#{'hello, ' + '${JAVA_HOME}'}\")\n    private String value;\n}\n```\n\n调用`test3()`方法测试：\n\n```Plain\n#{'hello, ' + '${JAVA_HOME}'}\n#{'hello, ' + 'C:\\Path\\jdk-14.0.1'}\nclass java.lang.String\nhello, C:\\Path\\jdk-14.0.1\n```\n\n能正确解析内容。\n\n# **@Autowired装配底层**\n\n`@Autowired`注解使用场景较多，主要有以下几种方式：\n\n1. 根据成员变量的类型注入\n2. 根据参数的类型注入\n3. 结果包装为`Optional`\n4. 结果包装为`ObjectProvider`、`ObjectFactory`\n5. 对`@Lazy`注解的处理\n\n接下来演示这几种方式的使用。\n\n1. 根据成员变量的类型注入\n\n创建`Bean2`：\n\n```Java\n@Component(\"bean2\")\nstatic class Bean2 {\n    @Override\n    public String toString() {\n        return super.toString();\n    }\n}\n```\n\n创建`Bean1`，自动注入属性`Bean2`:\n\n```Java\nstatic class Bean1 {\n    @Autowired\n    private Bean2 bean2;\n}\n```\n\n解析成员变量的类型注入需要使用到`DefaultListableBeanFactory`的`doResolveDependency()`方法：\n\n```Java\npublic static void main(String[] args) throws NoSuchFieldException, NoSuchMethodException {\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A47_1.class);\n    DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n    // 1. 根据成员变量的类型注入\n    DependencyDescriptor dd1 = new DependencyDescriptor(Bean1.class.getDeclaredField(\"bean2\"), false);\n    System.out.println(beanFactory.doResolveDependency(dd1, \"bean1\", null, null));\n}\n```\n\n运行`main()`方法，查看输出：\n\n```Plain\ncom.itheima.a47.A47_1$Bean2@723ca036\n```\n\n2. 根据参数的类型注入\n\n在`Bean1`中添加方法注入：\n\n```Java\nstatic class Bean1 {\n    @Autowired \n    public void setBean2(Bean2 bean2) {\n        this.bean2 = bean2;\n    }\n}\n```\n\n根据参数的类型注入和成员变量的类型注入类似，只不过创建`DependencyDescriptor`时，使用的是重载的构造方法，传入方法参数：\n\n```Java\npublic static void main(String[] args) throws NoSuchFieldException, NoSuchMethodException {\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A47_1.class);\n    DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n    System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\");\n    // 2. 根据参数的类型注入\n    Method setBean2 = Bean1.class.getDeclaredMethod(\"setBean2\", Bean2.class);\n    DependencyDescriptor dd2 = new DependencyDescriptor(new MethodParameter(setBean2, 0), false);\n    System.out.println(beanFactory.doResolveDependency(dd2, \"bean2\", null, null));\n}\n```\n\n运行`main()`方法，查看输出：\n\n```Plain\ncom.itheima.a47.A47_1$Bean2@723ca036\n```\n\n3. 结果包装为`Optional`\n\n有时候注入`Bean`时会将其包装为`Optional`，例如：\n\n```Java\nstatic class Bean1 {\n    @Autowired \n    private Optional<Bean2> bean3;\n}\n```\n\n以上代码想要注入的是内嵌的`Bean2`类型，而不是`Optional`类型。\n\n`spring`也支持解析内嵌类型，使用的是`DependencyDescriptor`的`increaseNestingLevel()`方法获取内嵌的类型。\n\n```Java\npublic class A47_1 {\n    public static void main(String[] args) throws NoSuchFieldException, NoSuchMethodException {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A47_1.class);\n        DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n        // 3. 结果包装为 Optional<Bean2>\n        DependencyDescriptor dd3 = new DependencyDescriptor(Bean1.class.getDeclaredField(\"bean3\"), false);\n        if (dd3.getDependencyType() == Optional.class) {\n            dd3.increaseNestingLevel();\n            Object result = beanFactory.doResolveDependency(dd3, \"bean3\", null, null);\n            System.out.println(Optional.ofNullable(result));\n        }\n    }\n```\n\n运行`main()`方法，查看输出：\n\n```Plain\nOptional[com.itheima.a47.A47_1$Bean2@723ca036]\n```\n\n4. 结果包装为`ObjectProvider`、`ObjectFactory`\n\n有时候注入`Bean`时会将其包装为`ObjectFactory`，例如：\n\n```Java\nstatic class Bean1 {\n    @Autowired \n    private ObjectFactory<Bean2> bean4;\n}\n```\n\n以上代码想要注入的是内嵌的`Bean2`类型，而不是`ObjectFactory`类型。\n\n`spring`也支持解析内嵌类型，使用的是`DependencyDescriptor`的`increaseNestingLevel()`方法获取内嵌的类型。\n\n同时只有在调用`ObjectFactory`的`getObject()`方法时，才想要拿到真正的`Bean`，因此我们可以延迟加载`Bean`，只有在调用`ObjectFactory`的`getObject()`方法时我们才真正执行初始化`Bean`的逻辑：\n\n```Java\npublic static void main(String[] args) throws NoSuchFieldException, NoSuchMethodException {\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A47_1.class);\n    DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();d1, \"bean1\", null, null));\n    // 4. 结果包装为 ObjectProvider,ObjectFactory\n    DependencyDescriptor dd4 = new DependencyDescriptor(Bean1.class.getDeclaredField(\"bean4\"), false);\n    if (dd4.getDependencyType() == ObjectFactory.class) {\n        dd4.increaseNestingLevel();\n        ObjectFactory objectFactory = new ObjectFactory() {\n            @Override\n            public Object getObject() throws BeansException {\n                return beanFactory.doResolveDependency(dd4, \"bean4\", null, null);\n            }\n        };\n        System.out.println(objectFactory.getObject());\n    }\n}\n```\n\n运行`main()`方法，查看输出：\n\n```Plain\ncom.itheima.a47.A47_1$Bean2@723ca036\n```\n\n5. 对`@Lazy`注解的处理\n\n`@Lazy`注解的作用有：\n\n- 当`@Lazy`放在类上，表示在启动的时候不会创建`bean`对象，当使用的时候才会创建\n- 当`@Lazy`放在`@Bean`注解的方法上，表示在启动的时候不会创建`bean`对象，当使用的时候才会创建\n- 当`@Lazy`放在`@Autowired`注解的属性上， 并不会直接给属性赋上真正的值，只是会赋值一个代理对象，当真正使用到这个属性的时候，才会去容器中找到一个符合的对象。在使用的时候，也会先执行代理对象的逻辑，然后再是真正bean对象的逻辑。\n- 写在方法或者方法参数前面上，效果和写在属性上是一样的，开始注入的只是代理对象，当真正调用的时候才会调用对应对象的逻辑\n- 写在构造方法或者构造方法参数前面上，和以上逻辑一样\n\n修改`Bean1`类：\n\n```Java\nstatic class Bean1 {\n    @Lazy \n    @Autowired \n    private Bean2 bean2;\n}\n```\n\n这里我们是将`@Lazy`放在`@Autowired`注解的属性上，因此会给属性赋值一个代理对象，这里使用的解析器是`ContextAnnotationAutowireCandidateResolver`：\n\n```Java\npublic static void main(String[] args) throws NoSuchFieldException, NoSuchMethodException {\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A47_1.class);\n    DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n    // 5. 对 @Lazy 的处理\n    DependencyDescriptor dd5 = new DependencyDescriptor(Bean1.class.getDeclaredField(\"bean2\"), false);\n    ContextAnnotationAutowireCandidateResolver resolver = new ContextAnnotationAutowireCandidateResolver();\n    resolver.setBeanFactory(beanFactory);\n    Object proxy = resolver.getLazyResolutionProxyIfNecessary(dd5, \"bean2\");\n    System.out.println(proxy);\n    System.out.println(proxy.getClass());\n}\n```\n\n运行`main()`方法，查看输出：\n\n```Plain\ncom.itheima.a47.A47_1$Bean2@723ca036\nclass com.itheima.a47.A47_1$Bean2$$EnhancerBySpringCGLIB$$537a559d\n```\n\n以上的很多种情况我们都用到了`DefaultListableBeanFactory`的`doResolveDependency()`方法，其实`@Value`注解、`@Autowired`注解最终都会进入`doResolveDependency()`方法的逻辑。\n\n只不过`doResolveDependency()`会优先处理`@Value`注解的字符串类型\n\n`doResolveDependency()`处理可以处理多种类型的注入，例如：\n\n1. 数组类型\n2. `List`类型\n3. 特殊类型，例如`applicationContext`\n4. 泛型\n5. 配合`@Qualifier`注解\n\n接下来我们模拟`doResolveDependency()`对以上类型的注入步骤。\n\n准备基础类：\n\n```Java\ninterface Dao<T> {\n\n}\n\ninterface Service {\n\n}\n\nstatic class Target {\n    @Autowired\n    private Service[] serviceArray;\n    @Autowired\n    private List<Service> serviceList;\n    @Autowired\n    private ConfigurableApplicationContext applicationContext;\n    @Autowired\n    private Dao<Teacher> dao;\n    @Autowired\n    @Qualifier(\"service2\")\n    private Service service;\n}\n\n@Component(\"dao1\")\nstatic class Dao1 implements Dao<Student> {\n}\n\n@Component(\"dao2\")\nstatic class Dao2 implements Dao<Teacher> {\n}\n\nstatic class Student {\n\n}\n\nstatic class Teacher {\n\n}\n\n@Component(\"service1\")\nstatic class Service1 implements Service {\n\n}\n\n@Component(\"service2\")\nstatic class Service2 implements Service {\n\n}\n\n@Component(\"service3\")\nstatic class Service3 implements Service {\n\n}\n```\n\n1. 模拟数组类型的解析\n\n对于数组类型的解析主要思路是拿到数组中元素的类型，根据类型从容器中获取`Bean`，最后将这些`Bean`转换为数组进行返回：\n\n```Java\nprivate static void testArray(DefaultListableBeanFactory beanFactory) throws NoSuchFieldException {\n    DependencyDescriptor dd1 = new DependencyDescriptor(Target.class.getDeclaredField(\"serviceArray\"), true);\n    if (dd1.getDependencyType().isArray()) {\n        // 获取数组中元素的真实类型\n        Class<?> componentType = dd1.getDependencyType().getComponentType();\n        System.out.println(componentType);\n        String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, componentType);\n        List<Object> beans = new ArrayList<>();\n        for (String name : names) {\n            System.out.println(name);\n            // 获取Bean\n            Object bean = dd1.resolveCandidate(name, componentType, beanFactory);\n            beans.add(bean);\n        }\n        // 将list转换为数组\n        Object array = beanFactory.getTypeConverter().convertIfNecessary(beans, dd1.getDependencyType());\n        System.out.println(array);\n    }\n}\n```\n\n编写`main()`调用：\n\n```Java\npublic static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A47_2.class);\n    DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n    System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>> 1. 数组类型\");\n    testArray(beanFactory);\n}\n```\n\n查看输出：\n\n```Plain\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 1. 数组类型\ninterface com.itheima.a47.A47_2$Service\nservice3\nservice2\nservice1\n[Lcom.itheima.a47.A47_2$Service;@3de8f619\n```\n\n2. 模拟`list`类型的解析\n\n对于`list`类型的解析主要思路是拿到`list`中元素的类型，根据类型从容器中获取`Bean`，最后将这些`Bean`转换为`list`进行返回：\n\n```Java\nprivate static void testList(DefaultListableBeanFactory beanFactory) throws NoSuchFieldException {\n    DependencyDescriptor dd2 = new DependencyDescriptor(Target.class.getDeclaredField(\"serviceList\"), true);\n    if (dd2.getDependencyType() == List.class) {\n        // 获取list中元素的真实类型\n        Class<?> resolve = dd2.getResolvableType().getGeneric().resolve();\n        System.out.println(resolve);\n        List<Object> list = new ArrayList<>();\n        String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, resolve);\n        for (String name : names) {\n            Object bean = dd2.resolveCandidate(name, resolve, beanFactory);\n            // 获取Bean\n            list.add(bean);\n        }\n        System.out.println(list);\n    }\n}\n```\n\n编写`main()`调用：\n\n```Java\npublic static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A47_2.class);\n    DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n    System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2. List 类型\");\n    testList(beanFactory);\n}\n```\n\n查看输出：\n\n```Plain\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2. List 类型\ninterface com.itheima.a47.A47_2$Service\n[com.itheima.a47.A47_2$Service3@5fb759d6, com.itheima.a47.A47_2$Service2@4b8d604b, com.itheima.a47.A47_2$Service1@5e7cd6cc]\n```\n\n3. 模拟特殊类型的解析\n\n我们要注入一个特殊的类型`ConfigurableApplicationContext`，打开其类图：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%91%EF%BC%9AOTHER/01.png)\n\n`ConfigurableApplicationContext`其实是`ApplicationContext`的子类型，这种特殊类型并不是容器中的`Bean`。\n\n最终所有的`Bean`会在`DefaultListableBeanFactory`中，打开`DefaultListableBeanFactory`类图：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%91%EF%BC%9AOTHER/02.png)\n\n`DefaultListableBeanFactory`实现了`DefaultSingletonBeanRegistry`，进入`DefaultSingletonBeanRegistry`类中，它有一个`singletonObjects`属性：\n\n```Java\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap(256);\n```\n\n最终所有的`Bean`都会放在`singletonObjects`中，`key`为`Bean`的名称，`value`为`Bean`的实例对象。但这里面没有`ApplicationContext`、`BeanFactory`等特殊类型。\n\n这些特殊类型其实是放在`DefaultListableBeanFactory`中的`resolvableDependencies`属性中：\n\n```Java\nprivate final Map<Class<?>, Object> resolvableDependencies;\n```\n\n`resolvableDependencies`的`key`为对象的类型，`value`为实例对象。这些特殊类型加入`resolvableDependencies`的时机是`ApplicationContext`调用`refresh()`方法。\n\n进入`AbstractApplicationContext`类的`refresh()`方法：\n\n```Java\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized(this.startupShutdownMonitor) {\n        // ...\n        this.prepareBeanFactory(beanFactory);\n        // ...\n}\n```\n\n进入`prepareBeanFactory()`方法：\n\n```Java\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    // ...\n    // 加入特殊类型\n    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n    beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n    beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n    // ...\n}\n```\n\n因此我们需要到`resolvableDependencies`中去取这些特殊类型。\n\n编写测试代码：\n\n```Java\n    private static void testApplicationContext(DefaultListableBeanFactory beanFactory) throws NoSuchFieldException, IllegalAccessException {\n        DependencyDescriptor dd3 = new DependencyDescriptor(Target.class.getDeclaredField(\"applicationContext\"), true);\n        Field resolvableDependencies = DefaultListableBeanFactory.class.getDeclaredField(\"resolvableDependencies\");\n        resolvableDependencies.setAccessible(true);\n        Map<Class<?>, Object> dependencies = (Map<Class<?>, Object>) resolvableDependencies.get(beanFactory);\n        for (Map.Entry<Class<?>, Object> entry : dependencies.entrySet()) {\n            // 左边类型                      右边类型\n            if (entry.getKey().isAssignableFrom(dd3.getDependencyType())) {\n                System.out.println(entry.getValue());\n                break;\n            }\n        }\n    }\n```\n\n编写`main()`调用：\n\n```Java\npublic static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A47_2.class);\n    DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n    System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>> 3. applicationContext\");\n    testApplicationContext(beanFactory);\n}\n```\n\n查看输出：\n\n```Plain\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 3. applicationContext\norg.springframework.context.annotation.AnnotationConfigApplicationContext@2a40cd94, started on Fri Apr 14 21:28:31 CST 2023\n```\n\n4. 模拟泛型的解析\n\n对于泛型的解析，我们不仅要比较外层类型，还要比较内层泛型的类型，编写测试代码：\n\n```Java\nprivate static void testGeneric(DefaultListableBeanFactory beanFactory) throws NoSuchFieldException {\n    DependencyDescriptor dd4 = new DependencyDescriptor(Target.class.getDeclaredField(\"dao\"), true);\n    Class<?> type = dd4.getDependencyType();\n    ContextAnnotationAutowireCandidateResolver resolver = new ContextAnnotationAutowireCandidateResolver();\n    resolver.setBeanFactory(beanFactory);\n    for (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) {\n        BeanDefinition bd = beanFactory.getMergedBeanDefinition(name);\n        // 对比 BeanDefinition 与 DependencyDescriptor 的泛型是否匹配\n        if (resolver.isAutowireCandidate(new BeanDefinitionHolder(bd, name), dd4)) {\n            System.out.println(name);\n            System.out.println(dd4.resolveCandidate(name, type, beanFactory));\n        }\n    }\n}\n```\n\n首先拿到属性的类型，根据属性类型获取所有`Bean`的名称，再根据`Bean`的名称获取`BeanDefinition`，`BeanDefinition`中就有`Bean`的泛型信息，最后使用`ContextAnnotationAutowireCandidateResolver`的`isAutowireCandidate()`方法匹配泛型。\n\n编写`main()`调用：\n\n```Java\npublic static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A47_2.class);\n    DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n    System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>> 4. 泛型\");\n    testGeneric(beanFactory);\n}\n```\n\n查看输出：\n\n```Plain\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 4. 泛型\ndao2\ncom.itheima.a47.A47_2$Dao2@29d80d2b\n```\n\n5. 模拟`@Qualifier`的解析\n\n`ContextAnnotationAutowireCandidateResolver`的`isAutowireCandidate()`方法可以匹配`@Qualifier`注解，我们使用此方法即可。\n\n```Java\nprivate static void testQualifier(DefaultListableBeanFactory beanFactory) throws NoSuchFieldException {\n    DependencyDescriptor dd5 = new DependencyDescriptor(Target.class.getDeclaredField(\"service\"), true);\n    Class<?> type = dd5.getDependencyType();\n    ContextAnnotationAutowireCandidateResolver resolver = new ContextAnnotationAutowireCandidateResolver();\n    resolver.setBeanFactory(beanFactory);\n    for (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) {\n        BeanDefinition bd = beanFactory.getMergedBeanDefinition(name);\n        if (resolver.isAutowireCandidate(new BeanDefinitionHolder(bd, name), dd5)) {\n            System.out.println(name);\n            System.out.println(dd5.resolveCandidate(name, type, beanFactory));\n        }\n    }\n}\n```\n\n编写`main()`调用：\n\n```Java\npublic static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A47_2.class);\n    DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n    System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>> 5. @Qualifier\");\n    testQualifier(beanFactory);\n}\n```\n\n查看输出：\n\n```Plain\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 5. @Qualifier\nservice2\ncom.itheima.a47.A47_2$Service2@4b8d604b\n```\n\n考虑以下场景，有一个接口`Service`:\n\n```Java\ninterface Service {\n}\n```\n\n容器中有3个实现了此接口的`Bean`：\n\n```Java\n@Component(\"service1\")\nstatic class Service1 implements Service {\n\n}\n\n@Component(\"service2\")\nstatic class Service2 implements Service {\n\n}\n\n@Component(\"service3\")\nstatic class Service3 implements Service {\n\n}\n```\n\n我们想依赖注入一个`Service`:\n\n```Java\n@Autowired\nprivate Service service;\n```\n\n在这种情况下，`spring`是不知道具体使用哪一个`Service`的实现，有两种方法可以解决：\n\n1. 在注入的时候加上`@Qualifier`注解指定`Bean`的名称\n\n```Java\n@Autowired\n@Qualifier(\"service2\")\nprivate Service service;\n```\n\n2. 使用`@Primary`注解，加了`@Primary`注解的`Bean`比同类型的`Bean`在注入时优先级更高，因此注入时会优先选择添加了`@Primary`注解的`Bean`\n\n`@Primary`注解是在组件扫描的时候进行解析的，`spring`会将`@Primary`作为一个属性注入到`BeanDefinition`中，即当前`Bean`是否标记了`@Primary`注解，因此在`spring`不确定注入哪个`Bean`时会根据此标记进行筛选。\n\n编写代码测试：\n\n在`Service2`上添加`@Primary`注解：\n\n```Java\n@Primary\n@Component(\"service2\")\nstatic class Service2 implements Service {\n\n}\n```\n\n模拟`@Primary`注解的解析：\n\n```Java\nprivate static void testPrimary(DefaultListableBeanFactory beanFactory) throws NoSuchFieldException {\n    DependencyDescriptor dd = new DependencyDescriptor(Target.class.getDeclaredField(\"service\"), false);\n    Class<?> type = dd.getDependencyType();\n    for (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) {\n        if (beanFactory.getMergedBeanDefinition(name).isPrimary()) {\n            System.out.println(name);\n        }\n    }\n}\n```\n\n编写`main()`调用：\n\n```Java\npublic static void main(String[] args) throws NoSuchFieldException {\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A47_3.class);\n    DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n    testPrimary(beanFactory);\n}\n```\n\n查看输出：\n\n```Plain\nservice2\n```\n\n如果既没有使用`@Qualifier`注解也没有使用`@Primary`注解，还有最后一道防线，也就是根据属性的名称进行区分，`spring`将根据属性的名称进行匹配。\n\n修改属性名称：\n\n```Java\n@Autowired\nprivate Service service3;\n```\n\n模拟根据属性名称的解析：\n\n```Java\nprivate static void testDefault(DefaultListableBeanFactory beanFactory) throws NoSuchFieldException {\n    DependencyDescriptor dd = new DependencyDescriptor(Target.class.getDeclaredField(\"service3\"), false);\n    Class<?> type = dd.getDependencyType();\n    for (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) {\n        if (name.equals(dd.getDependencyName())) {\n            System.out.println(name);\n        }\n    }\n}\n```\n\n编写`main()`调用：\n\n```Java\npublic static void main(String[] args) throws NoSuchFieldException {\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A47_3.class);\n    DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n    testDefault(beanFactory);\n}\n```\n\n查看输出：\n\n```Plain\nservice3\n```\n\n以上三种方式的优先级如下：\n\n1. 使用`@Qualifier`注解进行匹配\n2. 使用`@Primary`注解进行匹配\n3. 使用`Bean`的名称进行匹配\n\n# **事件监听器**\n\n## 实现ApplicationListener接口\n\n`spring`中事件机制，可以实现业务的解耦，这也是观察者模式的典型应用。\n\n下面我们看一段代码：\n\n```Java\n@Component\nstatic class MyService {\n    private static final Logger log = LoggerFactory.getLogger(MyService.class);\n    public void doBusiness() {\n        log.debug(\"主线业务\");\n        // 主线业务完成后需要做一些支线业务\n        log.debug(\"发送短信\");\n        log.debug(\"发送邮件\");\n    }\n}\n```\n\n以上代码有一个问题，就是主线业务与支线业务耦合，我们可以采用事件发布与监听的方式去解耦。\n\n创建一个自定义事件，需要继承`ApplicationEvent`：\n\n```Java\nstatic class MyEvent extends ApplicationEvent {\n    public MyEvent(Object source) {\n        super(source);\n    }\n}\n```\n\n在完成主线业务后发布一个事件：\n\n```Java\n@Component\nstatic class MyService {\n    private static final Logger log = LoggerFactory.getLogger(MyService.class);\n    @Autowired\n    private ApplicationEventPublisher publisher; \n    public void doBusiness() {\n        log.debug(\"主线业务\");\n        // 发布事件\n        publisher.publishEvent(new MyEvent(\"MyService.doBusiness()\"));\n    }\n}\n```\n\n监听事件可以实现`ApplicationListener`接口，同时设置泛型只关注目标类型的事件：\n\n```Java\n@Component\nstatic class SmsApplicationListener implements ApplicationListener<MyEvent> {\n    private static final Logger log = LoggerFactory.getLogger(SmsApplicationListener.class);\n    @Override\n    public void onApplicationEvent(MyEvent event) {\n        log.debug(\"发送短信\");\n    }\n}\n\n@Component\nstatic class EmailApplicationListener implements ApplicationListener<MyEvent> {\n    private static final Logger log = LoggerFactory.getLogger(EmailApplicationListener.class);\n    @Override\n    public void onApplicationEvent(MyEvent event) {\n        log.debug(\"发送邮件\");\n    }\n}\n```\n\n创建`main()`方法测试：\n\n```Java\npublic static void main(String[] args) {\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A48_1.class);\n    context.getBean(MyService.class).doBusiness();\n    context.close();\n}\n```\n\n查看输出：\n\n```Plain\n[DEBUG] 23:09:07.579 [main] com.itheima.a48.A48_1$MyService     - 主线业务 \n[DEBUG] 23:09:07.595 [main] c.i.a.A48_1$EmailApplicationListener - 发送邮件 \n[DEBUG] 23:09:07.595 [main] c.i.a.A48_1$SmsApplicationListener  - 发送短信 \n```\n\n主线业务与支线业务已经解耦，如果不再需要发短信的功能，只需要取消事件监听即可，不需要修改主线业务的代码，这就是解耦的好处。\n\n## 使用@EventListener注解\n\n`spring`还支持通过`@EventListener`注解来监听事件，`@EventListener`注解标注的方法的参数类型就是监听的事件的类型，例如：\n\n```Java\n@Component\nstatic class SmsService {\n    private static final Logger log = LoggerFactory.getLogger(SmsService.class);\n    @EventListener\n    public void listener(MyEvent myEvent) {\n        log.debug(\"发送短信\");\n    }\n}\n\n@Component\nstatic class EmailService {\n    private static final Logger log = LoggerFactory.getLogger(EmailService.class);\n    @EventListener\n    public void listener(MyEvent myEvent) {\n        log.debug(\"发送邮件\");\n    }\n}\n```\n\n运行`main()`方法，查看输出：\n\n```Plain\n[DEBUG] 23:09:07.579 [main] com.itheima.a48.A48_1$MyService     - 主线业务 \n[DEBUG] 23:09:07.595 [main] c.i.a.A48_1$EmailApplicationListener - 发送邮件 \n[DEBUG] 23:09:07.595 [main] c.i.a.A48_1$SmsApplicationListener  - 发送短信 \n```\n\n以上事件的发布与监听是同步的，由一个线程执行，我们可以将其优化异步，通过其他线程来执行支线业务。\n\n`ApplicationEventPublisher`底层是调用了`SimpleApplicationEventMulticaster`真正发事件，默认是单线程发送，我们可以设置用线程池来发送。\n\n我们需要注入自己的`SimpleApplicationEventMulticaster`并设置线程池，注意`Bean`的名称必须为`applicationEventMulticaster`，这样才能覆盖原有实现：\n\n```Java\n/**\n* 创建线程池\n*/\n@Bean\npublic ThreadPoolTaskExecutor executor() {\n    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n    executor.setCorePoolSize(3);\n    executor.setMaxPoolSize(10);\n    executor.setQueueCapacity(100);\n    return executor;\n}\n\n/**\n * 注意名称必须为applicationEventMulticaster，这样才能覆盖原有实现\n * @param executor\n * @return\n */\n@Bean\npublic SimpleApplicationEventMulticaster applicationEventMulticaster(ThreadPoolTaskExecutor executor) {\n    SimpleApplicationEventMulticaster multicaster = new SimpleApplicationEventMulticaster();\n    multicaster.setTaskExecutor(executor);\n    return multicaster;\n}\n```\n\n运行`main()`方法，查看输出：\n\n```Plain\n[DEBUG] 23:20:33.307 [main] com.itheima.a48.A48_2$MyService     - 主线业务 \n[DEBUG] 23:20:33.316 [executor-2] com.itheima.a48.A48_2$SmsService    - 发送短信 \n[DEBUG] 23:20:33.317 [executor-1] com.itheima.a48.A48_2$EmailService  - 发送邮件 \n```\n\n已经是使用线程池中的线程去执行支线业务。\n\n## 模拟事件监听原理\n\n首先自定义一个`Listener`注解：\n\n```Java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface MyListener {\n}\n```\n\n实现逻辑解析我们自定义的注解，主要步骤如下：\n\n1. 获取容器中所有的`Bean`\n2. 获取每个`Bean`中的所有方法\n3. 判断方法上是否有我们自定义的注解\n4. 从方法参数中获取需要监听的事件类型\n5. 实现`ApplicationListener`接口，重写`onApplicationEvent()`方法\n6. 在`onApplicationEvent()`方法中判断发生的事件是否为监听器监听的事件类型\n7. 最后将我们实现的`ApplicationListener`加入`AnnotationConfigApplicationContext`中的`ApplicationListener`中\n\n具体代码如下：\n\n```Java\nfor (String name : context.getBeanDefinitionNames()) {\n    Object bean = context.getBean(name);\n    for (Method method : bean.getClass().getMethods()) {\n        if (method.isAnnotationPresent(MyListener.class)) {\n            context.addApplicationListener((event) -> {\n                System.out.println(event);\n                Class<?> eventType = method.getParameterTypes()[0];// 监听器方法需要的事件类型\n                if (eventType.isAssignableFrom(event.getClass())) {\n                    try {\n                        method.invoke(bean, event);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        }\n    }\n}\n```\n\n我们可以在做一个优化，将以上逻辑写到一个后处理器中，我们可以实现`SmartInitializingSingleton`接口，这个接口会在所有单例对象初始化完毕之后调用。\n\n```Java\n@Bean\npublic SmartInitializingSingleton smartInitializingSingleton(ConfigurableApplicationContext context) {\n    return () -> {\n        for (String name : context.getBeanDefinitionNames()) {\n            Object bean = context.getBean(name);\n            for (Method method : bean.getClass().getMethods()) {\n                if (method.isAnnotationPresent(MyListener.class)) {\n                    context.addApplicationListener((event) -> {\n                        System.out.println(event);\n                        Class<?> eventType = method.getParameterTypes()[0];// 监听器方法需要的事件类型\n                        if (eventType.isAssignableFrom(event.getClass())) {\n                            try {\n                                method.invoke(bean, event);\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    };\n}\n```\n\n运行`main()`方法，查看输出：\n\n```Plain\norg.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@3bd94634, started on Fri Apr 14 23:44:32 CST 2023]\norg.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@3bd94634, started on Fri Apr 14 23:44:32 CST 2023]\n[DEBUG] 23:44:33.068 [main] com.itheima.a48.A48_3$MyService     - 主线业务 \ncom.itheima.a48.A48_3$MyEvent[source=MyService.doBusiness()]\n[DEBUG] 23:44:33.078 [main] com.itheima.a48.A48_3$EmailService  - 发送邮件 \ncom.itheima.a48.A48_3$MyEvent[source=MyService.doBusiness()]\n[DEBUG] 23:44:33.078 [main] com.itheima.a48.A48_3$SmsService    - 发送短信 \norg.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@3bd94634, started on Fri Apr 14 23:44:32 CST 2023]\norg.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@3bd94634, started on Fri Apr 14 23:44:32 CST 2023]\n```\n\n# **事件发布器**\n\n事件发布器对应的接口为`ApplicationEventMulticaster`，`spring`提供了一个比较常用的实现`SimpleApplicationEventMulticaster`，我们也可以自定义实现。\n\n`ApplicationEventMulticaster`接口中有两个重要方法：\n\n1. `addApplicationListenerBean()`：收集所有的监听器\n2. `multicastEvent()`：发布事件时会调用此方法\n\n我们主要实现以上两个方法，其他方法我们可以用抽象类给空实现：\n\n```Java\nabstract static class AbstractApplicationEventMulticaster implements ApplicationEventMulticaster {\n\n    @Override\n    public void addApplicationListener(ApplicationListener<?> listener) {\n\n    }\n\n    @Override\n    public void addApplicationListenerBean(String listenerBeanName) {\n\n    }\n\n    @Override\n    public void removeApplicationListener(ApplicationListener<?> listener) {\n\n    }\n\n    @Override\n    public void removeApplicationListenerBean(String listenerBeanName) {\n\n    }\n\n    @Override\n    public void removeApplicationListeners(Predicate<ApplicationListener<?>> predicate) {\n\n    }\n\n    @Override\n    public void removeApplicationListenerBeans(Predicate<String> predicate) {\n\n    }\n\n    @Override\n    public void removeAllListeners() {\n\n    }\n\n    @Override\n    public void multicastEvent(ApplicationEvent event) {\n\n    }\n\n    @Override\n    public void multicastEvent(ApplicationEvent event, ResolvableType eventType) {\n\n    }\n}\n```\n\n我们实现`AbstractApplicationEventMulticaster`抽象类：\n\n1. 在`addApplicationListenerBean()`方法中，我们获取`listener`的实例加入到`listeners`集合中\n2. 在`multicastEvent()`方法中，我们调用监听器的`onApplicationEvent()`方法\n\n```Java\n    @Bean \n    public ApplicationEventMulticaster applicationEventMulticaster(ConfigurableApplicationContext context) {\n        return new AbstractApplicationEventMulticaster() {\n        \n        private List<ApplicationListener> listeners = new ArrayList<>();\n\n            // 收集监听器\n            public void addApplicationListenerBean(String name) {\n                ApplicationListener listener = context.getBean(name, ApplicationListener.class);\n                System.out.println(listener);\n                listeners.add(listener);\n\n            }\n\n            // 发布事件\n            public void multicastEvent(ApplicationEvent event,ResolvableType eventType) {\n                for (ApplicationListener listener : listeners) {\n                    listener.onApplicationEvent(event);\n                }\n            }\n        };\n    }\n```\n\n使用自定义的监听器，查看输出：\n\n```Plain\nException in thread \"main\" java.lang.ClassCastException: class org.springframework.context.event.ContextRefreshedEvent cannot be cast to class com.itheima.a49.A49$MyEvent (org.springframework.context.event.ContextRefreshedEvent and com.itheima.a49.A49$MyEvent are in unnamed module of loader 'app')\n        at com.itheima.a49.A49$EmailApplicationListener.onApplicationEvent(A49.java:120)\n        at com.itheima.a49.A49$1.multicastEvent(A49.java:84)\n        at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:421)\n        at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:378)\n        at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:938)\n        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:586)\n        at org.springframework.context.annotation.AnnotationConfigApplicationContext.<init>(AnnotationConfigApplicationContext.java:93)\n        at com.itheima.a49.A49.main(A49.java:25)Exception in thread \"main\" java.lang.ClassCastException: class org.springframework.context.event.ContextRefreshedEvent cannot be cast to class com.itheima.a49.A49$MyEvent (org.springframework.context.event.ContextRefreshedEvent and com.itheima.a49.A49$MyEvent are in unnamed module of loader 'app')\n        at com.itheima.a49.A49$EmailApplicationListener.onApplicationEvent(A49.java:120)\n        at com.itheima.a49.A49$1.multicastEvent(A49.java:84)\n        at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:421)\n        at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:378)\n        at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:938)\n        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:586)\n        at org.springframework.context.annotation.AnnotationConfigApplicationContext.<init>(AnnotationConfigApplicationContext.java:93)\n        at com.itheima.a49.A49.main(A49.java:25)\n```\n\n发现报了一个错误，这是因为容器中存在其它的事件类型，例如`ContextRefreshedEvent`，但是我们需要监听的事件为`MyEvent`类型，因此调用`onApplicationEvent()`方法时，`ContextRefreshedEvent`会强制转换为`MyEvent`会抛出异常。\n\n```Java\n@Override\npublic void onApplicationEvent(MyEvent event) {\n    log.debug(\"发送短信\");\n}\n```\n\n我们可以在调用时判断监听器监听的事件类型是否支持`multicastEvent()`方法传入的事件类型。\n\n我们可以使用`ApplicationListener`的子接口`GenericApplicationListener`：\n\n```Java\npublic interface GenericApplicationListener extends SmartApplicationListener {\n    default boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {\n        return this.supportsEventType(ResolvableType.forClass(eventType));\n    }\n\n    boolean supportsEventType(ResolvableType eventType);\n}\n```\n\n`GenericApplicationListener`提供了一个`supportsEventType()`方法，返回一个`boolean`值，表示当前监听器是否支持传入的事件类型。\n\n我们可以使用`GenericApplicationListener`对`ApplicationListener`做一个封装：\n\n```Java\n@Bean\npublic ApplicationEventMulticaster applicationEventMulticaster(ConfigurableApplicationContext context, ThreadPoolTaskExecutor executor) {\n    return new AbstractApplicationEventMulticaster() {\n        private List<GenericApplicationListener> listeners = new ArrayList<>();\n\n        // 收集监听器\n        public void addApplicationListenerBean(String name) {\n            ApplicationListener listener = context.getBean(name, ApplicationListener.class);\n            System.out.println(listener);\n            // 获取该监听器支持的事件类型\n            ResolvableType type = ResolvableType.forClass(listener.getClass()).getInterfaces()[0].getGeneric();\n            System.out.println(type);\n\n            // 将原始的 listener 封装为支持事件类型检查的 listener\n            GenericApplicationListener genericApplicationListener = new GenericApplicationListener() {\n                // 是否支持某事件类型                真实的事件类型\n                public boolean supportsEventType(ResolvableType eventType) {\n                    return type.isAssignableFrom(eventType);\n                }\n\n                public void onApplicationEvent(ApplicationEvent event) {\n                    executor.submit(() -> listener.onApplicationEvent(event));\n                }\n            };\n\n            listeners.add(genericApplicationListener);\n        }\n\n        // 发布事件\n        public void multicastEvent(ApplicationEvent event, ResolvableType eventType) {\n            for (GenericApplicationListener listener : listeners) {\n                // 监听器是否支持event事件类型\n                if (listener.supportsEventType(ResolvableType.forClass(event.getClass()))) {\n                    listener.onApplicationEvent(event);\n                }\n            }\n        }\n    };\n}\n```\n\n完整代码如下：\n\n```Java\n@Configuration\npublic class A49 {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(A49.class);\n        context.getBean(MyService.class).doBusiness();\n        context.close();\n    }\n\n    @Bean\n    public ThreadPoolTaskExecutor executor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(3);\n        executor.setMaxPoolSize(10);\n        executor.setQueueCapacity(100);\n        return executor;\n    }\n\n    static class MyEvent extends ApplicationEvent {\n        public MyEvent(Object source) {\n            super(source);\n        }\n    }\n\n    @Component\n    static class MyService {\n        private static final Logger log = LoggerFactory.getLogger(MyService.class);\n        @Autowired\n        private ApplicationEventPublisher publisher; // applicationContext\n\n        public void doBusiness() {\n            log.debug(\"主线业务\");\n            // 主线业务完成后需要做一些支线业务，下面是问题代码\n            publisher.publishEvent(new MyEvent(\"MyService.doBusiness()\"));\n        }\n    }\n\n    @Component\n    static class SmsApplicationListener implements ApplicationListener<MyEvent> {\n        private static final Logger log = LoggerFactory.getLogger(SmsApplicationListener.class);\n\n        @Override\n        public void onApplicationEvent(MyEvent event) {\n            log.debug(\"发送短信\");\n        }\n    }\n\n    @Component\n    static class EmailApplicationListener implements ApplicationListener<MyEvent> {\n        private static final Logger log = LoggerFactory.getLogger(EmailApplicationListener.class);\n\n        @Override\n        public void onApplicationEvent(MyEvent event) {\n            log.debug(\"发送邮件\");\n        }\n    }\n\n\n    @Bean\n    public ApplicationEventMulticaster applicationEventMulticaster(ConfigurableApplicationContext context, ThreadPoolTaskExecutor executor) {\n        return new AbstractApplicationEventMulticaster() {\n            private List<GenericApplicationListener> listeners = new ArrayList<>();\n\n            // 收集监听器\n            public void addApplicationListenerBean(String name) {\n                ApplicationListener listener = context.getBean(name, ApplicationListener.class);\n                System.out.println(listener);\n                // 获取该监听器支持的事件类型\n                ResolvableType type = ResolvableType.forClass(listener.getClass()).getInterfaces()[0].getGeneric();\n                System.out.println(type);\n\n                // 将原始的 listener 封装为支持事件类型检查的 listener\n                GenericApplicationListener genericApplicationListener = new GenericApplicationListener() {\n                    // 是否支持某事件类型                真实的事件类型\n                    public boolean supportsEventType(ResolvableType eventType) {\n                        return type.isAssignableFrom(eventType);\n                    }\n\n                    public void onApplicationEvent(ApplicationEvent event) {\n                        executor.submit(() -> listener.onApplicationEvent(event));\n                    }\n                };\n\n                listeners.add(genericApplicationListener);\n            }\n\n            // 发布事件\n            public void multicastEvent(ApplicationEvent event, ResolvableType eventType) {\n                for (GenericApplicationListener listener : listeners) {\n                    if (listener.supportsEventType(ResolvableType.forClass(event.getClass()))) {\n                        listener.onApplicationEvent(event);\n                    }\n                }\n            }\n        };\n    }\n\n    abstract static class AbstractApplicationEventMulticaster implements ApplicationEventMulticaster {\n\n        @Override\n        public void addApplicationListener(ApplicationListener<?> listener) {\n\n        }\n\n        @Override\n        public void addApplicationListenerBean(String listenerBeanName) {\n\n        }\n\n        @Override\n        public void removeApplicationListener(ApplicationListener<?> listener) {\n\n        }\n\n        @Override\n        public void removeApplicationListenerBean(String listenerBeanName) {\n\n        }\n\n        @Override\n        public void removeApplicationListeners(Predicate<ApplicationListener<?>> predicate) {\n\n        }\n\n        @Override\n        public void removeApplicationListenerBeans(Predicate<String> predicate) {\n\n        }\n\n        @Override\n        public void removeAllListeners() {\n\n        }\n\n        @Override\n        public void multicastEvent(ApplicationEvent event) {\n\n        }\n\n        @Override\n        public void multicastEvent(ApplicationEvent event, ResolvableType eventType) {\n\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\ncom.itheima.a49.A49$EmailApplicationListener@5c7933ad\ncom.itheima.a49.A49$MyEvent\ncom.itheima.a49.A49$SmsApplicationListener@69c81773\ncom.itheima.a49.A49$MyEvent\n[DEBUG] 13:52:41.808 [main] com.itheima.a49.A49$MyService       - 主线业务 \n[DEBUG] 13:52:41.821 [executor-1] c.i.a.A49$EmailApplicationListener  - 发送邮件 \n[DEBUG] 13:52:41.821 [executor-2] c.i.a49.A49$SmsApplicationListener  - 发送短信 \n```\n","tags":["spring"],"categories":["原理探究"]},{"title":"Spring高级45讲【第五章】：BOOT","url":"/2023/04/15/Spring高级45讲【第五章】：BOOT.html","content":"\n# 构建Boot项目\n\n## 传统方式生成\n\n使用`IntelliJ IDEA`软件，点击文件->新建->项目\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/02.png)\n\n左侧选择`Spring Initializr`，右侧设置项目信息，点击下一步\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/03.png)\n\n选择`Spring Boot`版本，添加依赖\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/04.png)\n\n点击创建\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/05.png)\n\n`SpringBoot`项目构建成功，但是我们发现项目中会有很多额外的文件，例如.mvn文件夹、mvnw、mvnw.cmd等文件。\n\n## 快捷方式生成\n\n使用以下命令获取`pom.xml`：\n\n```Shell\ncurl https://start.spring.io/pom.xml\n```\n\n控制台输出：\n\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>3.0.5</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>com.example</groupId>\n    <artifactId>demo</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>demo</name>\n    <description>Demo project for Spring Boot</description>\n    <properties>\n        <java.version>17</java.version>\n    </properties>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n```\n\n如果需要添加依赖，我们可以使用`-d`选项：\n\n```Shell\ncurl https://start.spring.io/pom.xml -d dependencies=mysql,mybatis,web\n```\n\n如果想要存成文件，可以使用`-o`选项：\n\n```Shell\ncurl https://start.spring.io/pom.xml -d dependencies=mysql,mybatis,web -o pom.xml\n```\n\n如果想要查看更多使用方式，可以访问https://start.spring.io\n\n```Shell\ncurl https://start.spring.io\n .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n:: Spring Initializr ::  https://start.spring.io\n\nThis service generates quickstart projects that can be easily customized.\nPossible customizations include a project's dependencies, Java version, and\nbuild system or build structure. See below for further details.\n\nThe services uses a HAL based hypermedia format to expose a set of resources\nto interact with. If you access this root resource requesting application/json\nas media type the response will contain the following links:\n+-----------------------+--------------------------------------------------------------+\n| Rel                   | Description                                                  |\n+-----------------------+--------------------------------------------------------------+\n| gradle-build          | Generate a Gradle build file.                                |\n|                       |                                                              |\n| gradle-project *      | Generate a Gradle based project archive using the Groovy     |\n|                       | DSL.                                                         |\n|                       |                                                              |\n| gradle-project-kotlin | Generate a Gradle based project archive using the Kotlin     |\n|                       | DSL.                                                         |\n|                       |                                                              |\n| maven-build           | Generate a Maven pom.xml.                                    |\n|                       |                                                              |\n| maven-project         | Generate a Maven based project archive.                      |\n+-----------------------+--------------------------------------------------------------+\n\n\nThe URI templates take a set of parameters to customize the result of a request\nto the linked resource.\n+-----------------+------------------------------------------+------------------------------+\n| Parameter       | Description                              | Default value                |\n+-----------------+------------------------------------------+------------------------------+\n| applicationName | application name                         | DemoApplication              |\n| artifactId      | project coordinates (infer archive name) | demo                         |\n| baseDir         | base directory to create in the archive  | no base dir                  |\n| bootVersion     | spring boot version                      | 3.0.5                        |\n| dependencies    | dependency identifiers (comma-separated) | none                         |\n| description     | project description                      | Demo project for Spring Boot |\n| groupId         | project coordinates                      | com.example                  |\n| javaVersion     | language level                           | 17                           |\n| language        | programming language                     | java                         |\n| name            | project name (infer application name)    | demo                         |\n| packageName     | root package                             | com.example.demo             |\n| packaging       | project packaging                        | jar                          |\n| type            | project type                             | gradle-project               |\n| version         | project version                          | 0.0.1-SNAPSHOT               |\n+-----------------+------------------------------------------+------------------------------+\n\n\nThe following section has a list of supported identifiers for the comma-separated\nlist of \"dependencies\".\n+--------------------------------------+--------------------------------------------------------------+-------------------------------+\n| Id                                   | Description                                                  | Required version              |\n+--------------------------------------+--------------------------------------------------------------+-------------------------------+\n| activemq                             | Spring JMS support with Apache ActiveMQ 'Classic'.           | >=2.0.0.RELEASE and <3.0.0-M1 |\n|                                      |                                                              |                               |\n| actuator                             | Supports built in (or custom) endpoints that let you monitor |                               |\n|                                      | and manage your application - such as application health,    |                               |\n|                                      | metrics, sessions, etc.                                      |                               |\n|                                      |                                                              |                               |\n| amqp                                 | Gives your applications a common platform to send and        |                               |\n|                                      | receive messages, and your messages a safe place to live     |                               |\n|                                      | until received.                                              |                               |\n|                                      |                                                              |                               |\n| artemis                              | Spring JMS support with Apache ActiveMQ Artemis.             |                               |\n|                                      |                                                              |                               |\n| azure-active-directory               | Spring Security integration with Azure Active Directory for  | >=2.5.0-M1 and <3.1.0-M1      |\n|                                      | authentication.                                              |                               |\n|                                      |                                                              |                               |\n| azure-cosmos-db                      | Fully managed NoSQL database service for modern app          | >=2.5.0-M1 and <3.0.0-M1      |\n|                                      | development, including Spring Data support.                  |                               |\n|                                      |                                                              |                               |\n| azure-keyvault                       | All key vault features are supported, e.g. manage            | >=2.5.0-M1 and <3.1.0-M1      |\n|                                      | application secrets and certificates.                        |                               |\n|                                      |                                                              |                               |\n| azure-storage                        | All Storage features are supported, e.g. blob, fileshare and | >=2.5.0-M1 and <3.1.0-M1      |\n|                                      | queue.                                                       |                               |\n|                                      |                                                              |                               |\n| azure-support                        | Auto-configuration for Azure Services (Service Bus, Storage, | >=2.5.0-M1 and <3.1.0-M1      |\n|                                      | Active Directory, Key Vault, and more).                      |                               |\n|                                      |                                                              |                               |\n| batch                                | Batch applications with transactions, retry/skip and chunk   |                               |\n|                                      | based processing.                                            |                               |\n|                                      |                                                              |                               |\n| cache                                | Provides cache-related operations, such as the ability to    |                               |\n|                                      | update the content of the cache, but does not provide the    |                               |\n|                                      | actual data store.                                           |                               |\n|                                      |                                                              |                               |\n| camel                                | Apache Camel is an open source integration framework that    | >=2.0.0.M1 and <3.1.0-M1      |\n|                                      | empowers you to quickly and easily integrate various systems |                               |\n|                                      | consuming or producing data.                                 |                               |\n|                                      |                                                              |                               |\n| cloud-bus                            | Links nodes of a distributed system with a lightweight       | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | message broker which can used to broadcast state changes or  |                               |\n|                                      | other management instructions (requires a binder, e.g.       |                               |\n|                                      | Apache Kafka or RabbitMQ).                                   |                               |\n|                                      |                                                              |                               |\n| cloud-cloudfoundry-discovery         | Service discovery with Cloud Foundry.                        | >=2.3.0.M1 and <3.0.0-M1      |\n|                                      |                                                              |                               |\n| cloud-config-client                  | Client that connects to a Spring Cloud Config Server to      | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | fetch the application's configuration.                       |                               |\n|                                      |                                                              |                               |\n| cloud-config-server                  | Central management for configuration via Git, SVN, or        | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | HashiCorp Vault.                                             |                               |\n|                                      |                                                              |                               |\n| cloud-contract-stub-runner           | Stub Runner for HTTP/Messaging based communication. Allows   | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | creating WireMock stubs from RestDocs tests.                 |                               |\n|                                      |                                                              |                               |\n| cloud-contract-verifier              | Moves TDD to the level of software architecture by enabling  | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | Consumer Driven Contract (CDC) development.                  |                               |\n|                                      |                                                              |                               |\n| cloud-eureka                         | A REST based service for locating services for the purpose   | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | of load balancing and failover of middle-tier servers.       |                               |\n|                                      |                                                              |                               |\n| cloud-eureka-server                  | spring-cloud-netflix Eureka Server.                          | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      |                                                              |                               |\n| cloud-feign                          | Declarative REST Client. OpenFeign creates a dynamic         | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | implementation of an interface decorated with JAX-RS or      |                               |\n|                                      | Spring MVC annotations.                                      |                               |\n|                                      |                                                              |                               |\n| cloud-function                       | Promotes the implementation of business logic via functions  | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | and supports a uniform programming model across serverless   |                               |\n|                                      | providers, as well as the ability to run standalone (locally |                               |\n|                                      | or in a PaaS).                                               |                               |\n|                                      |                                                              |                               |\n| cloud-gateway                        | Provides a simple, yet effective way to route to APIs and    | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | provide cross cutting concerns to them such as security,     |                               |\n|                                      | monitoring/metrics, and resiliency.                          |                               |\n|                                      |                                                              |                               |\n| cloud-gcp                            | Contains auto-configuration support for every Spring Cloud   | >=2.4.0-M1 and <3.1.0-M1      |\n|                                      | GCP integration. Most of the auto-configuration code is only |                               |\n|                                      | enabled if other dependencies are added to the classpath.    |                               |\n|                                      |                                                              |                               |\n| cloud-gcp-pubsub                     | Adds the GCP Support entry and all the required dependencies | >=2.4.0-M1 and <3.1.0-M1      |\n|                                      | so that the Google Cloud Pub/Sub integration work out of the |                               |\n|                                      | box.                                                         |                               |\n|                                      |                                                              |                               |\n| cloud-gcp-storage                    | Adds the GCP Support entry and all the required dependencies | >=2.4.0-M1 and <3.1.0-M1      |\n|                                      | so that the Google Cloud Storage integration work out of the |                               |\n|                                      | box.                                                         |                               |\n|                                      |                                                              |                               |\n| cloud-loadbalancer                   | Client-side load-balancing with Spring Cloud LoadBalancer.   | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      |                                                              |                               |\n| cloud-resilience4j                   | Spring Cloud Circuit breaker with Resilience4j as the        | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | underlying implementation.                                   |                               |\n|                                      |                                                              |                               |\n| cloud-starter                        | Non-specific Spring Cloud features, unrelated to external    | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | libraries or integrations (e.g. Bootstrap context and        |                               |\n|                                      | @RefreshScope).                                              |                               |\n|                                      |                                                              |                               |\n| cloud-starter-consul-config          | Enable and configure the common patterns inside your         | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | application and build large distributed systems with         |                               |\n|                                      | Hashicorp’s Consul. The patterns provided include Service    |                               |\n|                                      | Discovery, Distributed Configuration and Control Bus.        |                               |\n|                                      |                                                              |                               |\n| cloud-starter-consul-discovery       | Service discovery with Hashicorp Consul.                     | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      |                                                              |                               |\n| cloud-starter-vault-config           | Provides client-side support for externalized configuration  | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | in a distributed system. Using HashiCorp's Vault you have a  |                               |\n|                                      | central place to manage external secret properties for       |                               |\n|                                      | applications across all environments.                        |                               |\n|                                      |                                                              |                               |\n| cloud-starter-zookeeper-config       | Enable and configure common patterns inside your application | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | and build large distributed systems with Apache Zookeeper    |                               |\n|                                      | based components. The provided patterns include Service      |                               |\n|                                      | Discovery and Configuration.                                 |                               |\n|                                      |                                                              |                               |\n| cloud-starter-zookeeper-discovery    | Service discovery with Apache Zookeeper.                     | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      |                                                              |                               |\n| cloud-stream                         | Framework for building highly scalable event-driven          | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | microservices connected with shared messaging systems        |                               |\n|                                      | (requires a binder, e.g. Apache Kafka, Apache Pulsar,        |                               |\n|                                      | RabbitMQ, or Solace PubSub+).                                |                               |\n|                                      |                                                              |                               |\n| cloud-task                           | Allows a user to develop and run short lived microservices   | >=2.3.0.M1 and <3.1.0-M1      |\n|                                      | using Spring Cloud. Run them locally, in the cloud, and on   |                               |\n|                                      | Spring Cloud Data Flow.                                      |                               |\n|                                      |                                                              |                               |\n| codecentric-spring-boot-admin-client | Required for your application to register with a             | >=2.0.0.RELEASE and <3.1.0-M1 |\n|                                      | Codecentric's Spring Boot Admin Server instance.             |                               |\n|                                      |                                                              |                               |\n| codecentric-spring-boot-admin-server | A community project to manage and monitor your Spring Boot   | >=2.0.0.RELEASE and <3.1.0-M1 |\n|                                      | applications. Provides a UI on top of the Spring Boot        |                               |\n|                                      | Actuator endpoints.                                          |                               |\n|                                      |                                                              |                               |\n| configuration-processor              | Generate metadata for developers to offer contextual help    |                               |\n|                                      | and \"code completion\" when working with custom configuration |                               |\n|                                      | keys (ex.application.properties/.yml files).                 |                               |\n|                                      |                                                              |                               |\n| data-cassandra                       | A free and open-source, distributed, NoSQL database          |                               |\n|                                      | management system that offers high-scalability and           |                               |\n|                                      | high-performance.                                            |                               |\n|                                      |                                                              |                               |\n| data-cassandra-reactive              | Access Cassandra NoSQL Database in a reactive fashion.       |                               |\n|                                      |                                                              |                               |\n| data-couchbase                       | NoSQL document-oriented database that offers in memory-first |                               |\n|                                      | architecture, geo-distributed deployments, and workload      |                               |\n|                                      | isolation.                                                   |                               |\n|                                      |                                                              |                               |\n| data-couchbase-reactive              | Access Couchbase NoSQL database in a reactive fashion with   |                               |\n|                                      | Spring Data Couchbase.                                       |                               |\n|                                      |                                                              |                               |\n| data-elasticsearch                   | A distributed, RESTful search and analytics engine with      |                               |\n|                                      | Spring Data Elasticsearch.                                   |                               |\n|                                      |                                                              |                               |\n| data-jdbc                            | Persist data in SQL stores with plain JDBC using Spring      |                               |\n|                                      | Data.                                                        |                               |\n|                                      |                                                              |                               |\n| data-jpa                             | Persist data in SQL stores with Java Persistence API using   |                               |\n|                                      | Spring Data and Hibernate.                                   |                               |\n|                                      |                                                              |                               |\n| data-ldap                            | Makes it easier to build Spring based applications that use  |                               |\n|                                      | the Lightweight Directory Access Protocol.                   |                               |\n|                                      |                                                              |                               |\n| data-mongodb                         | Store data in flexible, JSON-like documents, meaning fields  |                               |\n|                                      | can vary from document to document and data structure can be |                               |\n|                                      | changed over time.                                           |                               |\n|                                      |                                                              |                               |\n| data-mongodb-reactive                | Provides asynchronous stream processing with non-blocking    |                               |\n|                                      | back pressure for MongoDB.                                   |                               |\n|                                      |                                                              |                               |\n| data-neo4j                           | An open source NoSQL database that stores data structured as |                               |\n|                                      | graphs consisting of nodes, connected by relationships.      |                               |\n|                                      |                                                              |                               |\n| data-r2dbc                           | Provides Reactive Relational Database Connectivity to        |                               |\n|                                      | persist data in SQL stores using Spring Data in reactive     |                               |\n|                                      | applications.                                                |                               |\n|                                      |                                                              |                               |\n| data-redis                           | Advanced and thread-safe Java Redis client for synchronous,  |                               |\n|                                      | asynchronous, and reactive usage. Supports Cluster,          |                               |\n|                                      | Sentinel, Pipelining, Auto-Reconnect, Codecs and much more.  |                               |\n|                                      |                                                              |                               |\n| data-redis-reactive                  | Access Redis key-value data stores in a reactive fashion     |                               |\n|                                      | with Spring Data Redis.                                      |                               |\n|                                      |                                                              |                               |\n| data-rest                            | Exposing Spring Data repositories over REST via Spring Data  |                               |\n|                                      | REST.                                                        |                               |\n|                                      |                                                              |                               |\n| data-rest-explorer                   | Browsing Spring Data REST repositories in your browser.      |                               |\n|                                      |                                                              |                               |\n| datadog                              | Publish Micrometer metrics to Datadog, a dimensional         |                               |\n|                                      | time-series SaaS with built-in dashboarding and alerting.    |                               |\n|                                      |                                                              |                               |\n| db2                                  | A JDBC driver that provides access to IBM DB2.               | >=2.2.0.M6                    |\n|                                      |                                                              |                               |\n| derby                                | An open source relational database implemented entirely in   |                               |\n|                                      | Java.                                                        |                               |\n|                                      |                                                              |                               |\n| devtools                             | Provides fast application restarts, LiveReload, and          |                               |\n|                                      | configurations for enhanced development experience.          |                               |\n|                                      |                                                              |                               |\n| distributed-tracing                  | Enable span and trace IDs in logs.                           |                               |\n|                                      |                                                              |                               |\n| flapdoodle-mongo                     | Provides a platform neutral way for running MongoDB in unit  | >=2.0.0.RELEASE and <3.0.0-M1 |\n|                                      | tests.                                                       |                               |\n|                                      |                                                              |                               |\n| flyway                               | Version control for your database so you can migrate from    |                               |\n|                                      | any version (incl. an empty database) to the latest version  |                               |\n|                                      | of the schema.                                               |                               |\n|                                      |                                                              |                               |\n| freemarker                           | Java library to generate text output (HTML web pages,        |                               |\n|                                      | e-mails, configuration files, source code, etc.) based on    |                               |\n|                                      | templates and changing data.                                 |                               |\n|                                      |                                                              |                               |\n| graphite                             | Publish Micrometer metrics to Graphite, a hierarchical       |                               |\n|                                      | metrics system backed by a fixed-size database.              |                               |\n|                                      |                                                              |                               |\n| graphql                              | Build GraphQL applications with Spring for GraphQL and       | >=2.7.0.M1                    |\n|                                      | GraphQL Java.                                                |                               |\n|                                      |                                                              |                               |\n| groovy-templates                     | Groovy templating engine.                                    |                               |\n|                                      |                                                              |                               |\n| h2                                   | Provides a fast in-memory database that supports JDBC API    |                               |\n|                                      | and R2DBC access, with a small (2mb) footprint. Supports     |                               |\n|                                      | embedded and server modes as well as a browser based console |                               |\n|                                      | application.                                                 |                               |\n|                                      |                                                              |                               |\n| hateoas                              | Eases the creation of RESTful APIs that follow the HATEOAS   |                               |\n|                                      | principle when working with Spring / Spring MVC.             |                               |\n|                                      |                                                              |                               |\n| hsql                                 | Lightweight 100% Java SQL Database Engine.                   |                               |\n|                                      |                                                              |                               |\n| influx                               | Publish Micrometer metrics to InfluxDB, a dimensional        |                               |\n|                                      | time-series server that support real-time stream processing  |                               |\n|                                      | of data.                                                     |                               |\n|                                      |                                                              |                               |\n| integration                          | Adds support for Enterprise Integration Patterns. Enables    |                               |\n|                                      | lightweight messaging and supports integration with external |                               |\n|                                      | systems via declarative adapters.                            |                               |\n|                                      |                                                              |                               |\n| jdbc                                 | Database Connectivity API that defines how a client may      |                               |\n|                                      | connect and query a database.                                |                               |\n|                                      |                                                              |                               |\n| jersey                               | Framework for developing RESTful Web Services in Java that   |                               |\n|                                      | provides support for JAX-RS APIs.                            |                               |\n|                                      |                                                              |                               |\n| jooq                                 | Generate Java code from your database and build type safe    |                               |\n|                                      | SQL queries through a fluent API.                            |                               |\n|                                      |                                                              |                               |\n| kafka                                | Publish, subscribe, store, and process streams of records.   |                               |\n|                                      |                                                              |                               |\n| kafka-streams                        | Building stream processing applications with Apache Kafka    |                               |\n|                                      | Streams.                                                     |                               |\n|                                      |                                                              |                               |\n| liquibase                            | Liquibase database migration and source control library.     |                               |\n|                                      |                                                              |                               |\n| lombok                               | Java annotation library which helps to reduce boilerplate    |                               |\n|                                      | code.                                                        |                               |\n|                                      |                                                              |                               |\n| mail                                 | Send email using Java Mail and Spring Framework's            |                               |\n|                                      | JavaMailSender.                                              |                               |\n|                                      |                                                              |                               |\n| mariadb                              | MariaDB JDBC and R2DBC driver.                               |                               |\n|                                      |                                                              |                               |\n| mustache                             | Logic-less Templates. There are no if statements, else       |                               |\n|                                      | clauses, or for loops. Instead there are only tags.          |                               |\n|                                      |                                                              |                               |\n| mybatis                              | Persistence framework with support for custom SQL, stored    | >=2.0.0.RELEASE and <3.1.0-M1 |\n|                                      | procedures and advanced mappings. MyBatis couples objects    |                               |\n|                                      | with stored procedures or SQL statements using a XML         |                               |\n|                                      | descriptor or annotations.                                   |                               |\n|                                      |                                                              |                               |\n| mysql                                | MySQL JDBC driver.                                           |                               |\n|                                      |                                                              |                               |\n| native                               | Support for compiling Spring applications to native          | >=3.0.0-M1                    |\n|                                      | executables using the GraalVM native-image compiler.         |                               |\n|                                      |                                                              |                               |\n| new-relic                            | Publish Micrometer metrics to New Relic, a SaaS offering     |                               |\n|                                      | with a full UI and a query language called NRQL.             |                               |\n|                                      |                                                              |                               |\n| oauth2-client                        | Spring Boot integration for Spring Security's OAuth2/OpenID  |                               |\n|                                      | Connect client features.                                     |                               |\n|                                      |                                                              |                               |\n| oauth2-resource-server               | Spring Boot integration for Spring Security's OAuth2         | >=2.1.0.M2                    |\n|                                      | resource server features.                                    |                               |\n|                                      |                                                              |                               |\n| okta                                 | Okta specific configuration for Spring Security/Spring Boot  | >=2.0.0.RELEASE and <3.1.0-M1 |\n|                                      | OAuth2 features. Enable your Spring Boot application to work |                               |\n|                                      | with Okta via OAuth 2.0/OIDC.                                |                               |\n|                                      |                                                              |                               |\n| open-service-broker                  | Framework for building Spring Boot apps that implement the   | >=2.0.0.RELEASE and <2.7.0-M1 |\n|                                      | Open Service Broker API, which can deliver services to       |                               |\n|                                      | applications running within cloud native platforms such as   |                               |\n|                                      | Cloud Foundry, Kubernetes and OpenShift.                     |                               |\n|                                      |                                                              |                               |\n| oracle                               | A JDBC driver that provides access to Oracle.                |                               |\n|                                      |                                                              |                               |\n| picocli                              | Build command line applications with picocli.                | >=2.5.0.RELEASE and <3.1.0-M1 |\n|                                      |                                                              |                               |\n| postgresql                           | A JDBC and R2DBC driver that allows Java programs to connect |                               |\n|                                      | to a PostgreSQL database using standard, database            |                               |\n|                                      | independent Java code.                                       |                               |\n|                                      |                                                              |                               |\n| prometheus                           | Expose Micrometer metrics in Prometheus format, an in-memory |                               |\n|                                      | dimensional time series database with a simple built-in UI,  |                               |\n|                                      | a custom query language, and math operations.                |                               |\n|                                      |                                                              |                               |\n| pulsar                               | Build messaging applications with Apache Pulsar              | >=3.0.0 and <3.1.0-M1         |\n|                                      |                                                              |                               |\n| pulsar-reactive                      | Build reactive messaging applications with Apache Pulsar     | >=3.0.0 and <3.1.0-M1         |\n|                                      |                                                              |                               |\n| quartz                               | Schedule jobs using Quartz.                                  |                               |\n|                                      |                                                              |                               |\n| restdocs                             | Document RESTful services by combining hand-written with     |                               |\n|                                      | Asciidoctor and auto-generated snippets produced with Spring |                               |\n|                                      | MVC Test.                                                    |                               |\n|                                      |                                                              |                               |\n| rsocket                              | RSocket.io applications with Spring Messaging and Netty.     | >=2.2.0.M2                    |\n|                                      |                                                              |                               |\n| scs-config-client                    | Config client on VMware Tanzu Application Service.           | >=2.0.0.RELEASE and <3.0.0-M1 |\n|                                      |                                                              |                               |\n| scs-service-registry                 | Eureka service discovery client on VMware Tanzu Application  | >=2.0.0.RELEASE and <3.0.0-M1 |\n|                                      | Service.                                                     |                               |\n|                                      |                                                              |                               |\n| security                             | Highly customizable authentication and access-control        |                               |\n|                                      | framework for Spring applications.                           |                               |\n|                                      |                                                              |                               |\n| session                              | Provides an API and implementations for managing user        |                               |\n|                                      | session information.                                         |                               |\n|                                      |                                                              |                               |\n| solace                               | Connect to a Solace PubSub+ Advanced Event Broker to         | >=2.2.0.RELEASE and <3.0.0-M1 |\n|                                      | publish, subscribe, request/reply and store/replay messages  |                               |\n|                                      |                                                              |                               |\n| spring-shell                         | Build command line applications with spring.                 | >=2.7.0 and <3.1.0-M1         |\n|                                      |                                                              |                               |\n| sqlserver                            | A JDBC and R2DBC driver that provides access to Microsoft    |                               |\n|                                      | SQL Server and Azure SQL Database from any Java application. |                               |\n|                                      |                                                              |                               |\n| testcontainers                       | Provide lightweight, throwaway instances of common           |                               |\n|                                      | databases, Selenium web browsers, or anything else that can  |                               |\n|                                      | run in a Docker container.                                   |                               |\n|                                      |                                                              |                               |\n| thymeleaf                            | A modern server-side Java template engine for both web and   |                               |\n|                                      | standalone environments. Allows HTML to be correctly         |                               |\n|                                      | displayed in browsers and as static prototypes.              |                               |\n|                                      |                                                              |                               |\n| unboundid-ldap                       | Provides a platform neutral way for running a LDAP server in |                               |\n|                                      | unit tests.                                                  |                               |\n|                                      |                                                              |                               |\n| vaadin                               | A web framework that allows you to write UI in pure Java     | >=2.0.0.RELEASE and <3.1.0-M1 |\n|                                      | without getting bogged down in JS, HTML, and CSS.            |                               |\n|                                      |                                                              |                               |\n| validation                           | Bean Validation with Hibernate validator.                    |                               |\n|                                      |                                                              |                               |\n| wavefront                            | Publish metrics and optionally distributed traces to Tanzu   |                               |\n|                                      | Observability by Wavefront, a SaaS-based metrics monitoring  |                               |\n|                                      | and analytics platform that lets you visualize, query, and   |                               |\n|                                      | alert over data from across your entire stack.               |                               |\n|                                      |                                                              |                               |\n| web                                  | Build web, including RESTful, applications using Spring MVC. |                               |\n|                                      | Uses Apache Tomcat as the default embedded container.        |                               |\n|                                      |                                                              |                               |\n| web-services                         | Facilitates contract-first SOAP development. Allows for the  |                               |\n|                                      | creation of flexible web services using one of the many ways |                               |\n|                                      | to manipulate XML payloads.                                  |                               |\n|                                      |                                                              |                               |\n| webflux                              | Build reactive web applications with Spring WebFlux and      |                               |\n|                                      | Netty.                                                       |                               |\n|                                      |                                                              |                               |\n| websocket                            | Build Servlet-based WebSocket applications with SockJS and   |                               |\n|                                      | STOMP.                                                       |                               |\n|                                      |                                                              |                               |\n| zipkin                               | Enable and expose span and trace IDs to Zipkin.              |                               |\n+--------------------------------------+--------------------------------------------------------------+-------------------------------+\n\nExamples:\n\nTo create a default demo.zip:\n        $ curl -G https://start.spring.io/starter.zip -o demo.zip\n\nTo create a web project using Java 11:\n        $ curl -G https://start.spring.io/starter.zip -d dependencies=web \\\n                        -d javaVersion=11 -o demo.zip\n\nTo create a web/data-jpa gradle project unpacked:\n        $ curl -G https://start.spring.io/starter.tgz -d dependencies=web,data-jpa \\\n                   -d type=gradle-project -d baseDir=my-dir | tar -xzvf -\n\nTo generate a Maven POM with war packaging:\n        $ curl -G https://start.spring.io/pom.xml -d packaging=war -o pom.xml\n```\n\n# Boot War项目\n\n## 创建War项目\n\n创建一个SpringBoot War项目，点击文件->新建->项目，注意选择`War`打包方式\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/06.png)\n\n点击下一步，添加`Spring Web`依赖\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/07.png)\n\n点击创建。\n\n如果想使用`jsp`技术一般以`war`方式打包项目，因为`jsp`是不能配合`jar`方式打包使用的。\n\n`jsp`视图放置的位置是固定的，必须在`main`文件夹下的`webapp`目录下，例如：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/08.png)\n\n`hello.jsp`内容：\n\n```HTML\n<%--\n  Created by IntelliJ IDEA.\n  User: WolfMan\n  Date: 2023/4/9\n  Time: 21:05\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<h1>Hello, World</h1>\n</body>\n</html>\n```\n\n我们创建一个`Controller`进行视图映射：\n\n```Java\npublic class HelloController {\n\n    @RequestMapping(\"/hello\")\n    public String hello(){\n        return \"hello\";\n    }\n\n}\n```\n\n同时在`application.properties`文件中添加视图配置：\n\n```Plain\nspring.mvc.view.prefix=/\nspring.mvc.view.suffix=.jsp\n```\n\n这样一个简单的`war`项目就已经编写完毕\n\n## 测试War项目\n\n### 使用外置tomcat服务器\n\n配置外置`tomcat`服务器，点击编辑配置：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/09.png)\n\n点击+号，添加本地Tomcat服务器：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/10.png)\n\n点击修复：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/11.png)\n\n选择部署的工件，有两种选择：\n\n1. `war`：打包成`war`包进行部署\n2. `war exploded`：不打成`war`包，只是将生成`war`包所在的目录进行部署\n\n测试一般选择第二种方式。\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/12.png)\n\n应用程序上下文一般为`/`：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/13.png)\n\n点击应用。\n\n运行`tomcat`服务器，访问http://localhost:8080/hello网址，浏览器展示：\n\n```Plain\nHello, World\n```\n\n执行流程简单梳理：\n\n1. 浏览器输入http://localhost:8080/hello\n2. 经过`DispatcherServlet`，由`DispatcherServlet`调用`RequestMappingHandlerMapping`找到控制器方法\n3. 使用`RequestMappingHandlerAdapter`调用控制器方法\n4. 方法的返回值由返回值处理器进行解析，对于字符串返回值将会解析成视图名\n5. 由视图解析器拼接成完整视图路径\n6. 最后由`jsp`解析器解析并相应`html`代码\n\n值得注意的是，在骨架中生成了一个`ServletInitializer`类：\n\n```Java\npublic class ServletInitializer extends SpringBootServletInitializer {\n\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n        return application.sources(Test4Application.class);\n    }\n\n}\n```\n\n这个类就是配合外置的`tomcat`进行使用，相当于初始化类在`tomcat`启动的时候找到`SpringBoot`相关的代码并运行。如果缺少此类就没法和外置的`tomcat`配合使用。\n\n### 使用内置tomcat服务器\n\n我们直接运行启动类：\n\n```Plain\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::                (v2.5.2)\n\n2023-04-09 21:35:29.072  INFO 19168 --- [           main] com.example.test4.Test4Application       : Starting Test4Application using Java 1.8.0_152 on LAPTOP-FBCMT03A with PID 19168 (F:\\Java\\java项目\\Spring学习\\springboot\\test4\\test4\\target\\classes started by WolfMan in F:\\Java\\java项目\\Spring学习\\springboot\\test4\\test4)\n2023-04-09 21:35:29.075  INFO 19168 --- [           main] com.example.test4.Test4Application       : No active profile set, falling back to default profiles: default\n2023-04-09 21:35:29.873  INFO 19168 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)\n2023-04-09 21:35:29.879  INFO 19168 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n2023-04-09 21:35:29.880  INFO 19168 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.48]\n2023-04-09 21:35:29.931  INFO 19168 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext\n2023-04-09 21:35:29.931  INFO 19168 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 805 ms\n2023-04-09 21:35:30.180  INFO 19168 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''\n2023-04-09 21:35:30.188  INFO 19168 --- [           main] com.example.test4.Test4Application       : Started Test4Application in 1.467 seconds (JVM running for 2.169)\n```\n\n查看日志发现，服务已经启动并且监听了8080端口。\n\n访问http://localhost:8080/hello，我们发现浏览器直接将`hello.jsp`当成文件下载下来了，并没有解析页面。这是因为内嵌的`tomcat`服务器没有自带`jsp`的解析器。\n\n我们在`pom.xml`中添加`jsp`解析器坐标：\n\n```XML\n<dependency>\n    <groupId>org.apache.tomcat.embed</groupId>\n    <artifactId>tomcat-embed-jasper</artifactId>\n</dependency>\n```\n\n重新运行启动类，访问http://localhost:8080/hello网址，浏览器展示：\n\n```Plain\nHello, World\n```\n\n# Boot启动流程\n\n##  SpringApplication构造分析\n\n创建启动类：\n\n```Java\n@Configuration\npublic class A39_1 {\n\n    public static void main(String[] args) throws Exception {\n        SpringApplication.run(A39_1.class,args);\n    }\n\n}\n```\n\n我们进入`SpringApplication`的`run()`方法：\n\n```Java\npublic static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {\n    return run(new Class[]{primarySource}, args);\n}\n```\n\n进入重载的`run()`方法：\n\n```Java\npublic static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {\n    return (new SpringApplication(primarySources)).run(args);\n}\n```\n\n其中创建了一个`SpringApplication`实例，并调用了实例的`run()`方法。\n\n进入`SpringApplication`的构造方法：\n\n```Java\npublic SpringApplication(Class<?>... primarySources) {\n    this((ResourceLoader)null, primarySources);\n}\n```\n\n进入重载的构造方法：\n\n```Java\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n    this.sources = new LinkedHashSet();\n    this.bannerMode = Mode.CONSOLE;\n    this.logStartupInfo = true;\n    this.addCommandLineProperties = true;\n    this.addConversionService = true;\n    this.headless = true;\n    this.registerShutdownHook = true;\n    this.additionalProfiles = Collections.emptySet();\n    this.isCustomEnvironment = false;\n    this.lazyInitialization = false;\n    this.applicationContextFactory = ApplicationContextFactory.DEFAULT;\n    this.applicationStartup = ApplicationStartup.DEFAULT;\n    this.resourceLoader = resourceLoader;\n    Assert.notNull(primarySources, \"PrimarySources must not be null\");\n    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));\n    this.webApplicationType = WebApplicationType.deduceFromClasspath();\n    this.bootstrapRegistryInitializers = this.getBootstrapRegistryInitializersFromSpringFactories();\n    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));\n    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));\n    this.mainApplicationClass = this.deduceMainApplicationClass();\n}\n```\n\n`SpringApplication`的构造方法主要做了以下五件事：\n\n1. 记录`BeanDefinition`源，配置类或者`xml`配置文件等，根据引导类寻找`BeanDefinition`源\n2. 推断应用类型，非`web`程序、基于`servlet`的`web`程序、基于`reactive`的`web`容器，根据当前类路径下的`jar`包中的关键类推断\n3. 记录`ApplicationContext`初始化器，`ApplicationContext`初始化器可以对`Application`做一些功能上的扩展\n4. 记录监听器与事件，监听`SpringBoot`在启动过程中的一些关键事件\n5. 推断主启动类，推断运行`SpringBoot`项目的类\n\n`SpringApplication`的构造方法主要是做一些准备工作，并没有真正创建`spring`容器，`spring`容器的创建是在`SpringApplication`的`run()`方法中。\n\n1. 演示获取`BeanDefinition`源\n\n编写测试代码：\n\n```Java\n@Configuration\npublic class A39_1 {\n\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"1. 演示获取 Bean Definition 源\");\n        SpringApplication spring = new SpringApplication(A39_1.class);\n        spring.setSources(Set.of(\"classpath:b01.xml\"));\n        ConfigurableApplicationContext context = spring.run(args);\n        for (String name : context.getBeanDefinitionNames()) {\n            System.out.println(\"name: \" + name + \" 来源：\" + context.getBeanFactory().getBeanDefinition(name).getResourceDescription());\n        }\n        context.close();\n    }\n\n    static class Bean1 {\n\n    }\n\n    static class Bean2 {\n\n    }\n\n    static class Bean3 {\n\n    }\n\n    @Bean\n    public Bean2 bean2() {\n        return new Bean2();\n    }\n\n    /**\n    * 需要TomcatServletWebServerFactory\n    */\n    @Bean\n    public TomcatServletWebServerFactory servletWebServerFactory() {\n        return new TomcatServletWebServerFactory();\n    }\n}\n```\n\n编写配置文件：\n\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"bean1\" class=\"com.itheima.a39.A39_1.Bean1\"/>\n\n</beans>\n```\n\n运行启动类，查看控制台：\n\n```Plain\n1. 演示获取 Bean Definition 源\nname: org.springframework.context.annotation.internalConfigurationAnnotationProcessor 来源：null\nname: org.springframework.context.annotation.internalAutowiredAnnotationProcessor 来源：null\nname: org.springframework.context.annotation.internalCommonAnnotationProcessor 来源：null\nname: org.springframework.context.event.internalEventListenerProcessor 来源：null\nname: org.springframework.context.event.internalEventListenerFactory 来源：null\nname: a39_1 来源：null\nname: bean1 来源：class path resource [b01.xml]\nname: org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory 来源：null\nname: bean2 来源：com.itheima.a39.A39_1\nname: servletWebServerFactory 来源：com.itheima.a39.A39_1\n```\n\n发现将我们自定义的`Bean`的来源都已打印，来源为`null`的是`spring`自己添加的`Bean`，并且我们设置的xml的配置文件也已经生效。\n\n2. 演示推断应用类型\n\n进入`SpringApplication`的构造方法：\n\n```Java\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n    this.sources = new LinkedHashSet();\n    this.bannerMode = Mode.CONSOLE;\n    this.logStartupInfo = true;\n    this.addCommandLineProperties = true;\n    this.addConversionService = true;\n    this.headless = true;\n    this.registerShutdownHook = true;\n    this.additionalProfiles = Collections.emptySet();\n    this.isCustomEnvironment = false;\n    this.lazyInitialization = false;\n    this.applicationContextFactory = ApplicationContextFactory.DEFAULT;\n    this.applicationStartup = ApplicationStartup.DEFAULT;\n    this.resourceLoader = resourceLoader;\n    Assert.notNull(primarySources, \"PrimarySources must not be null\");\n    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));\n    this.webApplicationType = WebApplicationType.deduceFromClasspath();\n    this.bootstrapRegistryInitializers = this.getBootstrapRegistryInitializersFromSpringFactories();\n    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));\n    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));\n    this.mainApplicationClass = this.deduceMainApplicationClass();\n}\n```\n\n推断类型的逻辑在`WebApplicationType`的`deduceFromClasspath()`方法中：\n\n```Java\nstatic WebApplicationType deduceFromClasspath() {\n    if (ClassUtils.isPresent(\"org.springframework.web.reactive.DispatcherHandler\", (ClassLoader)null) && !ClassUtils.isPresent(\"org.springframework.web.servlet.DispatcherServlet\", (ClassLoader)null) && !ClassUtils.isPresent(\"org.glassfish.jersey.servlet.ServletContainer\", (ClassLoader)null)) {\n        return REACTIVE;\n    } else {\n        String[] var0 = SERVLET_INDICATOR_CLASSES;\n        int var1 = var0.length;\n\n        for(int var2 = 0; var2 < var1; ++var2) {\n            String className = var0[var2];\n            if (!ClassUtils.isPresent(className, (ClassLoader)null)) {\n                return NONE;\n            }\n        }\n\n        return SERVLET;\n    }\n}\n```\n\n主要判断逻辑为类路径下是否存在某些类，或者不存在某些类。\n\n我们通过反射来调用`WebApplicationType`的`deduceFromClasspath()`方法：\n\n```Java\n@Configuration\npublic class A39_1 {\n\n    public static void main(String[] args) throws Exception {\n        SpringApplication spring = new SpringApplication(A39_1.class);\n        System.out.println(\"2. 演示推断应用类型\");\n        Method deduceFromClasspath = WebApplicationType.class.getDeclaredMethod(\"deduceFromClasspath\");\n        deduceFromClasspath.setAccessible(true);\n        System.out.println(\"应用类型为:\"+deduceFromClasspath.invoke(null));\n        ConfigurableApplicationContext context = spring.run(args);\n        context.close();\n    }\n\n    static class Bean1 {\n\n    }\n\n    static class Bean2 {\n\n    }\n\n    static class Bean3 {\n\n    }\n\n    @Bean\n    public Bean2 bean2() {\n        return new Bean2();\n    }\n\n    @Bean\n    public TomcatServletWebServerFactory servletWebServerFactory() {\n        return new TomcatServletWebServerFactory();\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n2. 演示推断应用类型\n应用类型为:SERVLET\n```\n\n3. 演示`ApplicationContext`初始化器\n\n查看`ApplicationContext`构造方法：\n\n```Java\n//...\nthis.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));\n//...\n```\n\n以上代码就是读取配置文件中的初始化器。\n\n编写测试代码：\n\n```Java\n@Configuration\npublic class A39_1 {\n\n    public static void main(String[] args) throws Exception {\n        SpringApplication spring = new SpringApplication(A39_1.class);\n        System.out.println(\"3. 演示 ApplicationContext 初始化器\");\n        spring.addInitializers(applicationContext -> {\n            if (applicationContext instanceof GenericApplicationContext gac) {\n                gac.registerBean(\"bean3\", Bean3.class);\n            }\n        });\n        ConfigurableApplicationContext context = spring.run(args);\n        for (String name : context.getBeanDefinitionNames()) {\n            System.out.println(\"name: \" + name + \" 来源：\" + context.getBeanFactory().getBeanDefinition(name).getResourceDescription());\n        }\n        context.close();\n    }\n\n    static class Bean1 {\n\n    }\n\n    static class Bean2 {\n\n    }\n\n    static class Bean3 {\n\n    }\n\n    @Bean\n    public Bean2 bean2() {\n        return new Bean2();\n    }\n\n    @Bean\n    public TomcatServletWebServerFactory servletWebServerFactory() {\n        return new TomcatServletWebServerFactory();\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n3. 演示 ApplicationContext 初始化器\nname: org.springframework.context.annotation.internalConfigurationAnnotationProcessor 来源：null\nname: org.springframework.context.annotation.internalAutowiredAnnotationProcessor 来源：null\nname: org.springframework.context.annotation.internalCommonAnnotationProcessor 来源：null\nname: org.springframework.context.event.internalEventListenerProcessor 来源：null\nname: org.springframework.context.event.internalEventListenerFactory 来源：null\nname: bean3 来源：null\nname: a39_1 来源：null\nname: org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory 来源：null\nname: bean2 来源：com.itheima.a39.A39_1\nname: servletWebServerFactory 来源：com.itheima.a39.A39_1\n```\n\n我们发现`bean3`已经注册在容器中。\n\n4. 演示监听器与事件\n\n查看`ApplicationContext`构造方法：\n\n```Java\n//...\nthis.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));\n//...\n```\n\n以上代码就是读取配置文件中的监听器。\n\n编写测试代码：\n\n```Java\n@Configuration\npublic class A39_1 {\n\n    public static void main(String[] args) throws Exception {\n        SpringApplication spring = new SpringApplication(A39_1.class);\n        System.out.println(\"4. 演示监听器与事件\");\n        spring.addListeners(event -> System.out.println(\"\\t事件为:\" + event.getClass()));\n        ConfigurableApplicationContext context = spring.run(args);\n        for (String name : context.getBeanDefinitionNames()) {\n            System.out.println(\"name: \" + name + \" 来源：\" + context.getBeanFactory().getBeanDefinition(name).getResourceDescription());\n        }\n        context.close();\n    }\n\n    static class Bean1 {\n\n    }\n\n    static class Bean2 {\n\n    }\n\n    static class Bean3 {\n\n    }\n\n    @Bean\n    public Bean2 bean2() {\n        return new Bean2();\n    }\n\n    @Bean\n    public TomcatServletWebServerFactory servletWebServerFactory() {\n        return new TomcatServletWebServerFactory();\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n4. 演示监听器与事件\n        事件为:class org.springframework.boot.context.event.ApplicationStartingEvent\n        事件为:class org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::                (v2.5.5)\n\n        事件为:class org.springframework.boot.context.event.ApplicationContextInitializedEvent\n[INFO ] 13:58:33.919 [main] com.itheima.a39.A39_1               - Starting A39_1 using Java 17.0.6 on LAPTOP-FBCMT03A with PID 29512 (F:\\Java\\黑马全套java教程\\第2阶段企业级开发—基础框架\\7、spring高级45讲\\代码\\代码\\show\\target\\classes started by WolfMan in F:\\Java\\黑马全套java教程\\第2阶段企业级开发—基础框架\\7、spring高级45讲\\代码\\代码) \n[DEBUG] 13:58:33.926 [main] com.itheima.a39.A39_1               - Running with Spring Boot v2.5.5, Spring v5.3.10 \n[INFO ] 13:58:33.927 [main] com.itheima.a39.A39_1               - No active profile set, falling back to default profiles: default \n        事件为:class org.springframework.boot.context.event.ApplicationPreparedEvent\n[INFO ] 13:58:34.398 [main] o.s.b.w.e.tomcat.TomcatWebServer    - Tomcat initialized with port(s): 8080 (http) \n[INFO ] 13:58:34.413 [main] o.a.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler [\"http-nio-8080\"] \n[INFO ] 13:58:34.414 [main] o.a.catalina.core.StandardService   - Starting service [Tomcat] \n[INFO ] 13:58:34.414 [main] o.a.catalina.core.StandardEngine    - Starting Servlet engine: [Apache Tomcat/9.0.53] \n[INFO ] 13:58:34.560 [main] o.a.c.c.C.[Tomcat].[localhost].[/]  - Initializing Spring embedded WebApplicationContext \n[INFO ] 13:58:34.560 [main] o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 597 ms \n[INFO ] 13:58:34.617 [main] o.a.coyote.http11.Http11NioProtocol - Starting ProtocolHandler [\"http-nio-8080\"] \n[INFO ] 13:58:34.670 [main] o.s.b.w.e.tomcat.TomcatWebServer    - Tomcat started on port(s): 8080 (http) with context path '' \n        事件为:class org.springframework.boot.web.servlet.context.ServletWebServerInitializedEvent\n        事件为:class org.springframework.context.event.ContextRefreshedEvent\n[INFO ] 13:58:34.678 [main] com.itheima.a39.A39_1               - Started A39_1 in 1.214 seconds (JVM running for 1.692) \n        事件为:class org.springframework.boot.context.event.ApplicationStartedEvent\n        事件为:class org.springframework.boot.availability.AvailabilityChangeEvent\n        事件为:class org.springframework.boot.context.event.ApplicationReadyEvent\n        事件为:class org.springframework.boot.availability.AvailabilityChangeEvent\n        事件为:class org.springframework.boot.availability.AvailabilityChangeEvent\n        事件为:class org.springframework.context.event.ContextClosedEvent\n```\n\n事件被触发时会打印相应的事件名。\n\n5. 演示主类推断\n\n查看`ApplicationContext`构造方法：\n\n```Java\n//...\nthis.mainApplicationClass = this.deduceMainApplicationClass();\n//...\n```\n\n以上代码就是推断主类方法，我们反射调用。\n\n编写测试代码：\n\n```Java\n@Configuration\npublic class A39_1 {\n\n    public static void main(String[] args) throws Exception {\n        SpringApplication spring = new SpringApplication(A39_1.class);\n        System.out.println(\"5. 演示主类推断\");\n        Method deduceMainApplicationClass = SpringApplication.class.getDeclaredMethod(\"deduceMainApplicationClass\");\n        deduceMainApplicationClass.setAccessible(true);\n        System.out.println(\"\\t主类是：\"+deduceMainApplicationClass.invoke(spring));\n\n        ConfigurableApplicationContext context = spring.run(args);\n        context.close();\n    }\n\n    static class Bean1 {\n\n    }\n\n    static class Bean2 {\n\n    }\n\n    static class Bean3 {\n\n    }\n\n    @Bean\n    public Bean2 bean2() {\n        return new Bean2();\n    }\n\n    @Bean\n    public TomcatServletWebServerFactory servletWebServerFactory() {\n        return new TomcatServletWebServerFactory();\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n5. 演示主类推断\n        主类是：class com.itheima.a39.A39_1\n```\n\n## SpringApplication run()方法分析\n\n进入`SpringApplication`的`run()`方法：\n\n```Java\npublic ConfigurableApplicationContext run(String... args) {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start();\n    DefaultBootstrapContext bootstrapContext = this.createBootstrapContext();\n    ConfigurableApplicationContext context = null;\n    this.configureHeadlessProperty();\n    SpringApplicationRunListeners listeners = this.getRunListeners(args);\n    listeners.starting(bootstrapContext, this.mainApplicationClass);\n\n    try {\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);\n        this.configureIgnoreBeanInfo(environment);\n        Banner printedBanner = this.printBanner(environment);\n        context = this.createApplicationContext();\n        context.setApplicationStartup(this.applicationStartup);\n        this.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\n        this.refreshContext(context);\n        this.afterRefresh(context, applicationArguments);\n        stopWatch.stop();\n        if (this.logStartupInfo) {\n            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);\n        }\n\n        listeners.started(context);\n        this.callRunners(context, applicationArguments);\n    } catch (Throwable var10) {\n        this.handleRunFailure(context, var10, listeners);\n        throw new IllegalStateException(var10);\n    }\n\n    try {\n        listeners.running(context);\n        return context;\n    } catch (Throwable var9) {\n        this.handleRunFailure(context, var9, (SpringApplicationRunListeners)null);\n        throw new IllegalStateException(var9);\n    }\n}\n```\n\n`SpringApplication`的`run()`方法步骤：\n\n1. 得到`SpringApplicationRunListeners`，名字取得不好，实际是事件发布器\n    1. 发布`application starting`事件\n2. 封装启动`args`\n3. 准备`Environment`添加命令行参数\n4. `ConfigurationPropertySources`处理\n    1. 发布`application environment`已准备事件\n5. 通过`EnvironmentPostProcessorApplicationListener`进行 `env `后处理\n    1. `application.properties`，由`StandardConfigDataLocationResolver`解析\n    2. `spring.application.json`\n6. 绑定`spring.main`到`SpringApplication`对象\n7. 打印`banner`\n8. 创建容器\n9. 准备容器\n    1. 发布`application context`已初始化事件\n10. 加载`bean`定义\n    1. 发布`application prepared`事件\n11. `refresh`容器\n    1. 发布`application started`事件\n12. 执行`runner`\n    1. 发布`application ready`事件\n    2. 这其中有异常，发布`application failed`事件\n\n演示`SpringApplication`的`run()`方法第1步：\n\n事件发布器的类型为`SpringApplicationRunListener`，`SpringApplicationRunListeners`可以组合多个事件发布器。`SpringApplicationRunListener`有一个实现为`EventPublishingRunListener`，虽然只有一个实现，但`spring`没有写死在代码中，而是将接口与实现写在了`org.springframework.boot:spring-boot:2.5.5`包下的`spring.factories`配置文件中。\n\n```Properties\n# Run Listeners\norg.springframework.boot.SpringApplicationRunListener=\\\norg.springframework.boot.context.event.EventPublishingRunListener\n```\n\n编写代码查看`EventPublishingRunListener`实现类：\n\n```Java\npublic class A39_2 {\n    public static void main(String[] args) throws Exception{\n        // 添加 app 监听器\n        SpringApplication app = new SpringApplication();\n        app.addListeners(e -> System.out.println(e.getClass()));\n        // 获取事件发送器实现类名\n        List<String> names = SpringFactoriesLoader.loadFactoryNames(SpringApplicationRunListener.class, A39_2.class.getClassLoader());\n        for (String name : names) {\n            System.out.println(name);\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\norg.springframework.boot.context.event.EventPublishingRunListener\n```\n\n我们使用`EventPublishingRunListener`来发布各种事件：\n\n1. `class org.springframework.boot.context.event.ApplicationStartingEvent`\n2. `class org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent`\n3. `class org.springframework.boot.context.event.ApplicationContextInitializedEvent`\n4. `class org.springframework.boot.context.event.ApplicationPreparedEvent`\n5. `class org.springframework.boot.context.event.ApplicationStartedEvent`\n6. `class org.springframework.boot.context.event.ApplicationReadyEvent`\n7. `class org.springframework.boot.context.event.ApplicationFailedEvent`\n\n一共有以上七个事件。\n\n```Java\npublic class A39_2 {\n    public static void main(String[] args) throws Exception {\n        // 添加 app 监听器\n        SpringApplication app = new SpringApplication();\n        app.addListeners(e -> System.out.println(e.getClass()));\n        // 获取事件发送器实现类名\n        List<String> names = SpringFactoriesLoader.loadFactoryNames(SpringApplicationRunListener.class, A39_2.class.getClassLoader());\n        for (String name : names) {\n            System.out.println(name);\n            Class<?> clazz = Class.forName(name);\n            Constructor<?> constructor = clazz.getConstructor(SpringApplication.class, String[].class);\n            SpringApplicationRunListener publisher = (SpringApplicationRunListener) constructor.newInstance(app, args);\n            // 发布事件\n            DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();\n            // spring boot 开始启动\n            publisher.starting(bootstrapContext);\n            // 环境信息准备完毕\n            publisher.environmentPrepared(bootstrapContext, new StandardEnvironment());\n            GenericApplicationContext context = new GenericApplicationContext();\n            // 在 spring 容器创建，并调用初始化器之后，发送此事件\n            publisher.contextPrepared(context);\n            // 所有 bean definition 加载完毕\n            publisher.contextLoaded(context);\n            context.refresh();\n            // spring 容器初始化完成(refresh 方法调用完毕)\n            publisher.started(context);\n            // spring boot 启动完毕\n            publisher.running(context);\n            // spring boot 启动出错\n            publisher.failed(context, new Exception(\"出错了\"));\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\norg.springframework.boot.context.event.EventPublishingRunListener\nclass org.springframework.boot.context.event.ApplicationStartingEvent\nclass org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent\nclass org.springframework.boot.context.event.ApplicationContextInitializedEvent\nclass org.springframework.boot.context.event.ApplicationPreparedEvent\nclass org.springframework.context.event.ContextRefreshedEvent\nclass org.springframework.boot.context.event.ApplicationStartedEvent\nclass org.springframework.boot.availability.AvailabilityChangeEvent\nclass org.springframework.boot.context.event.ApplicationReadyEvent\nclass org.springframework.boot.availability.AvailabilityChangeEvent\nclass org.springframework.boot.context.event.ApplicationFailedEvent\n```\n\n发现控制台不止七个事件，其实有些事件是由容器内的事件发布器发布的。\n\n演示`SpringApplication`的`run()`方法第2、8~12步：\n\n```Java\n/**\n * 运行时请添加运行参数 --server.port=8080 debug\n */\npublic class A39_3 {\n    @SuppressWarnings(\"all\")\n    public static void main(String[] args) throws Exception {\n        SpringApplication app = new SpringApplication();\n        app.addInitializers(new ApplicationContextInitializer<ConfigurableApplicationContext>() {\n            @Override\n            public void initialize(ConfigurableApplicationContext applicationContext) {\n                System.out.println(\"执行初始化器增强...\");\n            }\n        });\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>> 2. 封装启动 args\");\n        DefaultApplicationArguments arguments = new DefaultApplicationArguments(args);\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>> 8. 创建容器\");\n        GenericApplicationContext context = createApplicationContext(WebApplicationType.SERVLET);\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>> 9. 准备容器\");\n        for (ApplicationContextInitializer initializer : app.getInitializers()) {\n            initializer.initialize(context);\n        }\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>> 10. 加载 bean 定义\");\n        DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n        AnnotatedBeanDefinitionReader reader1 = new AnnotatedBeanDefinitionReader(beanFactory);\n        XmlBeanDefinitionReader reader2 = new XmlBeanDefinitionReader(beanFactory);\n        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(beanFactory);\n        reader1.register(Config.class);\n        reader2.loadBeanDefinitions(new ClassPathResource(\"b03.xml\"));\n        scanner.scan(\"com.itheima.a39.sub\");\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>> 11. refresh 容器\");\n        context.refresh();\n        for (String name : context.getBeanDefinitionNames()) {\n            System.out.println(\"name:\" + name + \" 来源：\" + beanFactory.getBeanDefinition(name).getResourceDescription());\n        }\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>> 12. 执行 runner\");\n        for (CommandLineRunner runner : context.getBeansOfType(CommandLineRunner.class).values()) {\n            runner.run(args);\n        }\n        for (ApplicationRunner runner : context.getBeansOfType(ApplicationRunner.class).values()) {\n            runner.run(arguments);\n        }\n    }\n\n    private static GenericApplicationContext createApplicationContext(WebApplicationType type) {\n        GenericApplicationContext context = null;\n        switch (type) {\n            case SERVLET -> context = new AnnotationConfigServletWebServerApplicationContext();\n            case REACTIVE -> context = new AnnotationConfigReactiveWebServerApplicationContext();\n            case NONE -> context = new AnnotationConfigApplicationContext();\n        }\n        return context;\n    }\n\n    static class Bean4 {\n\n    }\n\n    static class Bean5 {\n\n    }\n\n    static class Bean6 {\n\n    }\n\n    @Configuration\n    static class Config {\n        @Bean\n        public Bean5 bean5() {\n            return new Bean5();\n        }\n\n        @Bean\n        public ServletWebServerFactory servletWebServerFactory() {\n            return new TomcatServletWebServerFactory();\n        }\n\n        @Bean\n        public CommandLineRunner commandLineRunner() {\n            return new CommandLineRunner() {\n                @Override\n                public void run(String... args) throws Exception {\n                    System.out.println(\"commandLineRunner()...\" + Arrays.toString(args));\n                }\n            };\n        }\n\n        @Bean\n        public ApplicationRunner applicationRunner() {\n            return new ApplicationRunner() {\n                @Override\n                public void run(ApplicationArguments args) throws Exception {\n                    System.out.println(\"applicationRunner()...\" + Arrays.toString(args.getSourceArgs()));\n                    System.out.println(args.getOptionNames());\n                    System.out.println(args.getOptionValues(\"server.port\"));\n                    System.out.println(args.getNonOptionArgs());\n                }\n            };\n        }\n    }\n}\n```\n\n`b03.xml`文件内容为：\n\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <bean id=\"bean4\" class=\"com.itheima.a39.A39_3.Bean4\"/>\n</beans>\n```\n\n`com.itheima.a39.sub`包中内容为：\n\n```Java\n@Component\npublic class Bean7 {\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n>>>>>>>>>>>>>>>>>>>>>>>> 2. 封装启动 args\n>>>>>>>>>>>>>>>>>>>>>>>> 8. 创建容器\n>>>>>>>>>>>>>>>>>>>>>>>> 9. 准备容器\n执行初始化器增强...\n>>>>>>>>>>>>>>>>>>>>>>>> 10. 加载 bean 定义\n>>>>>>>>>>>>>>>>>>>>>>>> 11. refresh 容器\n[INFO ] 16:05:35.122 [main] o.s.b.w.e.tomcat.TomcatWebServer    - Tomcat initialized with port(s): 8080 (http) \n4月 12, 2023 4:05:35 下午 org.apache.coyote.AbstractProtocol init\n信息: Initializing ProtocolHandler [\"http-nio-8080\"]\n4月 12, 2023 4:05:35 下午 org.apache.catalina.core.StandardService startInternal\n信息: Starting service [Tomcat]\n4月 12, 2023 4:05:35 下午 org.apache.catalina.core.StandardEngine startInternal\n信息: Starting Servlet engine: [Apache Tomcat/9.0.53]\n4月 12, 2023 4:05:35 下午 org.apache.catalina.core.ApplicationContext log\n信息: Initializing Spring embedded WebApplicationContext\n[INFO ] 16:05:35.292 [main] o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 652 ms \n4月 12, 2023 4:05:35 下午 org.apache.coyote.AbstractProtocol start\n信息: Starting ProtocolHandler [\"http-nio-8080\"]\n[INFO ] 16:05:35.413 [main] o.s.b.w.e.tomcat.TomcatWebServer    - Tomcat started on port(s): 8080 (http) with context path '' \nname:org.springframework.context.annotation.internalConfigurationAnnotationProcessor 来源：null\nname:org.springframework.context.annotation.internalAutowiredAnnotationProcessor 来源：null\nname:org.springframework.context.annotation.internalCommonAnnotationProcessor 来源：null\nname:org.springframework.context.event.internalEventListenerProcessor 来源：null\nname:org.springframework.context.event.internalEventListenerFactory 来源：null\nname:a39_3.Config 来源：null\nname:bean4 来源：class path resource [b03.xml]\nname:bean7 来源：file [F:\\Java\\黑马全套java教程\\第2阶段企业级开发—基础框架\\7、spring高级45讲\\代码\\代码\\show\\target\\classes\\com\\itheima\\a39\\sub\\Bean7.class]\nname:org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory 来源：null\nname:bean5 来源：com.itheima.a39.A39_3$Config\nname:servletWebServerFactory 来源：com.itheima.a39.A39_3$Config\nname:commandLineRunner 来源：com.itheima.a39.A39_3$Config\nname:applicationRunner 来源：com.itheima.a39.A39_3$Config\n>>>>>>>>>>>>>>>>>>>>>>>> 12. 执行 runner\ncommandLineRunner()...[--server.port=8080, debug]\napplicationRunner()...[--server.port=8080, debug]\n[server.port]\n[8080]\n[debug]\n```\n\n发现我们手动添加的`Bean`都已注入，添加的启动参数也能正常读取。\n\n演示`SpringApplication`的`run()`方法第3步：\n\n`SpringApplication`的`run()`方法的第3~6步都与一个环境对象有关，环境对象即配置信息的抽象。配置信息有多种来源，例如系统环境变量、`properties`文件、`yaml`文件等。环境对象对这些配置信息的整合，将来读取配置时使用此对象即可。\n\n在spring中，环境对象的实现为`StandardEnvironment`，而在`springboot`中，环境对象的实现为`ApplicationEnvironment`类，查看其继承关系：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/14.png)\n\n其主要作用就是根据给定键找到对应的值，默认情况下我们创建的环境对象里只有两个来源：\n\n1. 系统属性\n2. 系统变量\n\n我们可以打印一下：\n\n```Java\npublic class Step3 {\n    public static void main(String[] args) throws IOException {\n        // 系统环境变量, properties, yaml\n        ApplicationEnvironment env = new ApplicationEnvironment(); \n        for (PropertySource<?> ps : env.getPropertySources()) {\n            System.out.println(ps);\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nPropertiesPropertySource {name='systemProperties'}\nSystemEnvironmentPropertySource {name='systemEnvironment'}\n```\n\n在查找键的时候，从上到下会有一个优先级，如果有同名的键，优先使用靠前的来源。\n\n我们测试一下优先级：\n\n```Java\npublic class Step3 {\n    public static void main(String[] args) throws IOException {\n        ApplicationEnvironment env = new ApplicationEnvironment();\n        System.out.println(env.getProperty(\"JAVA_HOME\"));\n    }\n}\n```\n\n控制台输出：\n\n```Plain\nC:\\Path\\jdk-14.0.1\n```\n\n接下来我们在运行时添加系统属性，即添加虚拟机参数：\n\n```Java\n-DJAVA_HOME=abc\n```\n\n再次运行，控制台输出：\n\n```Plain\nabc\n```\n\n因此优先查找的来源是`systemProperties`，其次是`systemEnvironment`。\n\n我们可以自定义来源：\n\n```Java\npublic class Step3 {\n    public static void main(String[] args) throws IOException {\n        ApplicationEnvironment env = new ApplicationEnvironment();\n        env.getPropertySources().addLast(new ResourcePropertySource(new ClassPathResource(\"step3.properties\")));\n        env.getPropertySources().addFirst(new SimpleCommandLinePropertySource(args));\n        System.out.println(env.getProperty(\"server.port\"));\n    }\n}\n```\n\n优先级为`PropertySources`中的顺序，排在最前面的优先级最高。\n\n在以上代码中我们在`PropertySources`添加了配置文件，以及命令行来源，同时配置文件优先级最低，命令行来源优先级最高。\n\n在配置文件中配置`server.port=8080`，运行代码时添加参数`--server.port=8081`，运行代码，查看控制台：\n\n```Plain\n8081\n```\n\n最后输出的是8081，说明命令行来源优先级最高。\n\n`SpringApplication`的`run()`方法第3步做了以下事情：\n\n1. 准备`ApplicationEnvironment`对象\n2. 添加了`SimpleCommandLinePropertySource`来源\n\n> 添加`ResourcePropertySource`来源是后续步骤做的事情。\n\n演示`SpringApplication`的`run()`方法第4步：\n\n我们先看一个例子：\n\n```Java\npublic class Step4 {\n\n    public static void main(String[] args) throws IOException, NoSuchFieldException {\n        ApplicationEnvironment env = new ApplicationEnvironment();\n        env.getPropertySources().addLast(\n                new ResourcePropertySource(\"step4\", new ClassPathResource(\"step4.properties\"))\n        );\n        System.out.println(env.getProperty(\"user.first-name\"));\n        System.out.println(env.getProperty(\"user.middle-name\"));\n        System.out.println(env.getProperty(\"user.last-name\"));\n    }\n}\n```\n\n`step4.properties`配置文件的内容为：\n\n```Properties\nuser.first-name=George\nuser.middle_name=Walker\nuser.lastName=Bush\n```\n\n我们发现代码中读取的键与配置文件中的键是不一样的，因此读取不到：\n\n```Plain\nGeorge\nnull\nnull\n```\n\n第4步加入了一个特殊的`PropertySource`源，这个特殊的源就是将配置文件的命名统一成由`-`号分割的，我们此源：\n\n```Java\npublic class Step4 {\n\n    public static void main(String[] args) throws IOException, NoSuchFieldException {\n        ApplicationEnvironment env = new ApplicationEnvironment();\n        env.getPropertySources().addLast(\n                new ResourcePropertySource(\"step4\", new ClassPathResource(\"step4.properties\"))\n        );\n        ConfigurationPropertySources.attach(env);\n        for (PropertySource<?> ps : env.getPropertySources()) {\n            System.out.println(ps);\n        }\n        System.out.println(env.getProperty(\"user.first-name\"));\n        System.out.println(env.getProperty(\"user.middle-name\"));\n        System.out.println(env.getProperty(\"user.last-name\"));\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nConfigurationPropertySourcesPropertySource {name='configurationProperties'}\nPropertiesPropertySource {name='systemProperties'}\nSystemEnvironmentPropertySource {name='systemEnvironment'}\nResourcePropertySource {name='step4'}\nGeorge\nWalker\nBush\n```\n\n发现一共有四个来源，并且配置文件也能正确读取。\n\n演示`SpringApplication`的`run()`方法第5步：\n\n第5步是对`ApplicationEnvironment`再做进一步的增强处理，在给其补充一些新的`PropertySource`。它是通过`Environment`后处理器来完成的，因此它具备一定的扩展性，可以由我们自己补充新的实现。\n\n值得提到的是，读取`application.properties`的源就是在第5步被加入的。\n\n我们查看对应的接口：\n\n```Java\n@FunctionalInterface\npublic interface EnvironmentPostProcessor {\n    void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application);\n}\n```\n\n`EnvironmentPostProcessor`有一个重要实现`ConfigDataEnvironmentPostProcessor`，其作用就是读取`application.properties`中的内容。\n\n演示`ConfigDataEnvironmentPostProcessor`的作用：\n\n```Java\npublic class Step5 {\n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication();\n        ApplicationEnvironment env = new ApplicationEnvironment();\n\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>> 增强前\");\n        for (PropertySource<?> ps : env.getPropertySources()) {\n            System.out.println(ps);\n        }\n        ConfigDataEnvironmentPostProcessor postProcessor1 = new ConfigDataEnvironmentPostProcessor(new DeferredLogs(), new DefaultBootstrapContext());\n        postProcessor1.postProcessEnvironment(env,app);\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>> 增强后\");\n        for (PropertySource<?> ps : env.getPropertySources()) {\n            System.out.println(ps);\n        }\n        System.out.println(env.getProperty(\"server.port\"));\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n>>>>>>>>>>>>>>>>>>>>>>>>> 增强前\nPropertiesPropertySource {name='systemProperties'}\nSystemEnvironmentPropertySource {name='systemEnvironment'}\n>>>>>>>>>>>>>>>>>>>>>>>>> 增强后\nPropertiesPropertySource {name='systemProperties'}\nSystemEnvironmentPropertySource {name='systemEnvironment'}\nOriginTrackedMapPropertySource {name='Config resource 'class path resource [application.properties]' via location 'optional:classpath:/''}\n8080\n```\n\n增强后多了一个`PropertySource`源，同时也能读取配置文件中的内容。\n\n我们也可以测试另一个实现`RandomValuePropertySourceEnvironmentPostProcessor`，这个实现可以随机产生值，我们只需要读取`random`开头的键即可。\n\n```Java\npublic class Step5 {\n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication();\n        ApplicationEnvironment env = new ApplicationEnvironment();\n\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>> 增强前\");\n        for (PropertySource<?> ps : env.getPropertySources()) {\n            System.out.println(ps);\n        }\n        RandomValuePropertySourceEnvironmentPostProcessor postProcessor2 = new RandomValuePropertySourceEnvironmentPostProcessor(new DeferredLog());\n        postProcessor2.postProcessEnvironment(env, app);\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>> 增强后\");\n        for (PropertySource<?> ps : env.getPropertySources()) {\n            System.out.println(ps);\n        }\n        System.out.println(env.getProperty(\"random.int\"));\n        System.out.println(env.getProperty(\"random.int\"));\n        System.out.println(env.getProperty(\"random.int\"));\n        System.out.println(env.getProperty(\"random.uuid\"));\n        System.out.println(env.getProperty(\"random.uuid\"));\n        System.out.println(env.getProperty(\"random.uuid\"));\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n>>>>>>>>>>>>>>>>>>>>>>>>> 增强前\nPropertiesPropertySource {name='systemProperties'}\nSystemEnvironmentPropertySource {name='systemEnvironment'}\n>>>>>>>>>>>>>>>>>>>>>>>>> 增强后\nPropertiesPropertySource {name='systemProperties'}\nSystemEnvironmentPropertySource {name='systemEnvironment'}\nRandomValuePropertySource {name='random'}\n2112811766\n-176261027\n1122993668\n115cf977-b2c4-4853-bd79-1ce543ace40c\n173de9ff-b916-4bfb-b426-eed474e518ee\nff051847-0940-4664-89b4-41bc9f042dde\n```\n\n`springboot`会在`spring.factories`配置文件中读取所有的`EnvironmentPostProcessor`：\n\n```Bash\n# Environment Post Processors\norg.springframework.boot.env.EnvironmentPostProcessor=\\\norg.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\\norg.springframework.boot.context.config.ConfigDataEnvironmentPostProcessor,\\\norg.springframework.boot.env.RandomValuePropertySourceEnvironmentPostProcessor,\\\norg.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\\\norg.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\\\norg.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor\n```\n\n我们手动获取这些`EnvironmentPostProcessor`：\n\n```Java\npublic class Step5 {\n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication();\n        List<String> names = SpringFactoriesLoader.loadFactoryNames(EnvironmentPostProcessor.class, Step5.class.getClassLoader());\n        for (String name : names) {\n            System.out.println(name);\n        }\n\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\norg.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor\norg.springframework.boot.context.config.ConfigDataEnvironmentPostProcessor\norg.springframework.boot.env.RandomValuePropertySourceEnvironmentPostProcessor\norg.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor\norg.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor\norg.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor\norg.springframework.boot.autoconfigure.integration.IntegrationPropertiesEnvironmentPostProcessor\n```\n\n这些`EnvironmentPostProcessor`的增强方法是通过监听器的方式来调用的。同样，监听器的实现也在`spring.factories`配置文件中：\n\n```Plain\n# Application Listeners\norg.springframework.context.ApplicationListener=\\\norg.springframework.boot.ClearCachesApplicationListener,\\\norg.springframework.boot.builder.ParentContextCloserApplicationListener,\\\norg.springframework.boot.context.FileEncodingApplicationListener,\\\norg.springframework.boot.context.config.AnsiOutputApplicationListener,\\\norg.springframework.boot.context.config.DelegatingApplicationListener,\\\norg.springframework.boot.context.logging.LoggingApplicationListener,\\\norg.springframework.boot.env.EnvironmentPostProcessorApplicationListener\n```\n\n其中`EnvironmentPostProcessorApplicationListener`就是去调用各个`EnvironmentPostProcessor`的`postProcessEnvironment()`增强方法。\n\n我们使用`EnvironmentPostProcessorApplicationListener`手动去增加`PropertySource`源：\n\n```Java\npublic class Step5 {\n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication();\n        app.addListeners(new EnvironmentPostProcessorApplicationListener());\n        EventPublishingRunListener publisher = new EventPublishingRunListener(app, args);\n        ApplicationEnvironment env = new ApplicationEnvironment();\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>> 增强前\");\n        for (PropertySource<?> ps : env.getPropertySources()) {\n            System.out.println(ps);\n        }\n        publisher.environmentPrepared(new DefaultBootstrapContext(), env);\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>> 增强后\");\n        for (PropertySource<?> ps : env.getPropertySources()) {\n            System.out.println(ps);\n        }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n>>>>>>>>>>>>>>>>>>>>>>>>> 增强前\nPropertiesPropertySource {name='systemProperties'}\nSystemEnvironmentPropertySource {name='systemEnvironment'}\n>>>>>>>>>>>>>>>>>>>>>>>>> 增强后\nPropertiesPropertySource {name='systemProperties'}\nOriginAwareSystemEnvironmentPropertySource {name='systemEnvironment'}\nRandomValuePropertySource {name='random'}\nOriginTrackedMapPropertySource {name='Config resource 'class path resource [application.properties]' via location 'optional:classpath:/''}\n```\n\n发现增强后有些`PropertySource`源不生效，是与初始化环境有关。\n\n演示`SpringApplication`的`run()`方法第6步：\n\n`@ConfigurationProperties`注解的原理是使用`Binder`进行绑定：\n\n```Java\npublic class Step6 {\n    public static void main(String[] args) throws IOException {\n        ApplicationEnvironment env = new ApplicationEnvironment();\n        env.getPropertySources().addLast(new ResourcePropertySource(\"step4\", new ClassPathResource(\"step4.properties\")));\n        User user = Binder.get(env).bind(\"user\", User.class).get();\n        System.out.println(user);\n    }\n\n    static class User {\n        private String firstName;\n        private String middleName;\n        private String lastName;\n        public String getFirstName() {\n            return firstName;\n        }\n        public void setFirstName(String firstName) {\n            this.firstName = firstName;\n        }\n        public String getMiddleName() {\n            return middleName;\n        }\n        public void setMiddleName(String middleName) {\n            this.middleName = middleName;\n        }\n        public String getLastName() {\n            return lastName;\n        }\n        public void setLastName(String lastName) {\n            this.lastName = lastName;\n        }\n        @Override\n        public String toString() {\n            return \"User{\" +\n                   \"firstName='\" + firstName + '\\'' +\n                   \", middleName='\" + middleName + '\\'' +\n                   \", lastName='\" + lastName + '\\'' +\n                   '}';\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nUser{firstName='George', middleName='Walker', lastName='Bush'}\n```\n\n`step4.properties`配置文件中的信息已经成功绑定到`User`对象上\n\n也可以使用另一种方式绑定数据到已有的对象上\n\n```Java\nUser user = new User();\nBinder.get(env).bind(\"user\", Bindable.ofInstance(user));\nSystem.out.println(user);\n```\n\n`SpringApplication`的`run()`方法第6步的作用就是将配置文件或者环境变量中的这些键值绑定到`SpringApplication`属性中。\n\n演示示例，准备配置文件，这些属性在`SpringApplication`都有对应值：\n\n```Properties\nspring.main.banner-mode=off\nspring.main.lazy-initialization=true\n```\n\n编写代码绑定数据：\n\n```Java\npublic class Step6 {\n    public static void main(String[] args) throws IOException {\n        SpringApplication application = new SpringApplication();\n        ApplicationEnvironment env = new ApplicationEnvironment();\n        env.getPropertySources().addLast(new ResourcePropertySource(\"step6\", new ClassPathResource(\"step6.properties\")));\n        System.out.println(application);\n        Binder.get(env).bind(\"spring.main\", Bindable.ofInstance(application));\n        System.out.println(application);\n    }\n\n}\n```\n\n绑定之前的值：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/15.png)\n\n绑定之后的值：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%91%EF%BC%9ABOOT/16.png)\n\n演示`SpringApplication`的`run()`方法第7步：\n\n`SpringApplication`的`run()`方法第7步主要是输出`Banner`信息，`springboot`中有默认的实现`SpringBootBanner`，我们也可以配置自己的`Banner`信息：\n\n1. 配置文字`Banner`：指定`spring.banner.location`值，即新的`Banner`\n2. 配置图片`Banner`：指定`spring.banner.image.location`值，最终图片会转换为文字。\n\n```Java\npublic class Step7 {\n    public static void main(String[] args) {\n        ApplicationEnvironment env = new ApplicationEnvironment();\n        SpringApplicationBannerPrinter printer = new SpringApplicationBannerPrinter(\n                new DefaultResourceLoader(),\n                new SpringBootBanner()\n        );\n        // 测试文字 banner\n        env.getPropertySources().addLast(new MapPropertySource(\"custom\", Map.of(\"spring.banner.location\",\"banner1.txt\")));\n        // 测试图片 banner\n        env.getPropertySources().addLast(new MapPropertySource(\"custom\", Map.of(\"spring.banner.image.location\",\"banner2.png\")));\n        // 版本号的获取\n        System.out.println(SpringBootVersion.getVersion());\n        printer.print(env, Step7.class, System.out);\n    }\n}\n```\n\n最后回顾一下`SpringApplication`的`run()`方法：\n\n```Java\npublic ConfigurableApplicationContext run(String... args) {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start();\n    DefaultBootstrapContext bootstrapContext = this.createBootstrapContext();\n    ConfigurableApplicationContext context = null;\n    this.configureHeadlessProperty();\n    // 1.获取事件发布器对象\n    SpringApplicationRunListeners listeners = this.getRunListeners(args);\n    // 发布starting事件\n    listeners.starting(bootstrapContext, this.mainApplicationClass);\n\n    try {\n        // 2.将main方法传入的args参数封装为ApplicationArguments，分为选项参数(以--开头)与非选项参数\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n        // 3. 创建Environment并添加基于命令行的源 \n        // 4.统一命名配置文件中的键\n        // 5.通过事件发布与响应为Environment添加了更多的源\n        // 6.将所有以spring.main开头的配置与SpringApplication对象进行绑定\n        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);\n        this.configureIgnoreBeanInfo(environment);\n        // 7.打印Banner信息\n        Banner printedBanner = this.printBanner(environment);\n        // 8.创建spring容器\n        context = this.createApplicationContext();\n        context.setApplicationStartup(this.applicationStartup);\n        // 9.应用初始化器，对context进行增强\n        // 10.得到所有的BeanDefinition源，例如xml配置文件、注解配置\n        this.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\n        // 11.调用ApplicationContext的refresh方法，refresh()中就会调用各种BeanFactory后处理器、Bean后处理器、初始化单例\n        this.refreshContext(context);\n        this.afterRefresh(context, applicationArguments);\n        stopWatch.stop();\n        if (this.logStartupInfo) {\n            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);\n        }\n        // 发布started事件\n        listeners.started(context);\n        // 调用所有实现了ApplicationRunner或CommandLineRunner的Runner\n        this.callRunners(context, applicationArguments);\n    } catch (Throwable var10) {\n        // 如果有异常，在handleRunFailure方法中发布failed事件\n        this.handleRunFailure(context, var10, listeners);\n        throw new IllegalStateException(var10);\n    }\n\n    try {\n        // 发布running事件\n        listeners.running(context);\n        return context;\n    } catch (Throwable var9) {\n        this.handleRunFailure(context, var9, (SpringApplicationRunListeners)null);\n        throw new IllegalStateException(var9);\n    }\n}\n```\n\n`prepareEnvironment()`方法详情：\n\n```Java\nprivate ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments) {\n    ConfigurableEnvironment environment = this.getOrCreateEnvironment();\n    // 3.创建Environment并添加基于命令行的源\n    this.configureEnvironment((ConfigurableEnvironment)environment, applicationArguments.getSourceArgs());\n    // 4.统一命名配置文件中的键，转换为以-分割的格式\n    ConfigurationPropertySources.attach((Environment)environment);\n    // 5.通过事件发布与响应为Environment添加了更多的源\n    listeners.environmentPrepared(bootstrapContext, (ConfigurableEnvironment)environment);\n    DefaultPropertiesPropertySource.moveToEnd((ConfigurableEnvironment)environment);\n    Assert.state(!((ConfigurableEnvironment)environment).containsProperty(\"spring.main.environment-prefix\"), \"Environment prefix cannot be set via properties.\");\n    // 6.将所有以spring.main开头的配置与SpringApplication对象进行绑定\n    this.bindToSpringApplication((ConfigurableEnvironment)environment);\n    if (!this.isCustomEnvironment) {\n        environment = (new EnvironmentConverter(this.getClassLoader())).convertEnvironmentIfNecessary((ConfigurableEnvironment)environment, this.deduceEnvironmentClass());\n    }\n\n    ConfigurationPropertySources.attach((Environment)environment);\n    return (ConfigurableEnvironment)environment;\n}\n```\n\n`prepareContext()`方法详情：\n\n```Java\nprivate void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {\n    context.setEnvironment(environment);\n    this.postProcessApplicationContext(context);\n    // 9.应用初始化器，对context进行增强\n    this.applyInitializers(context);\n    // 发布contextPrepared事件\n    listeners.contextPrepared(context);\n    bootstrapContext.close(context);\n    if (this.logStartupInfo) {\n        this.logStartupInfo(context.getParent() == null);\n        this.logStartupProfileInfo(context);\n    }\n\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n    beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);\n    if (printedBanner != null) {\n        beanFactory.registerSingleton(\"springBootBanner\", printedBanner);\n    }\n\n    if (beanFactory instanceof DefaultListableBeanFactory) {\n        ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n    }\n\n    if (this.lazyInitialization) {\n        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());\n    }\n    // 10.得到所有的BeanDefinition源，例如xml配置文件、注解配置\n    Set<Object> sources = this.getAllSources();\n    Assert.notEmpty(sources, \"Sources must not be empty\");\n    // 加载BeanDefinition到ApplicationContext容器中\n    this.load(context, sources.toArray(new Object[0]));\n    // 发布contextLoaded事件\n    listeners.contextLoaded(context);\n}\n```\n\n# **Tomcat内嵌容器**\n\n## Tomcat内嵌容器\n\n`Tomcat`基本结构：\n\n```Plain\nServer\n└───Service\n    ├───Connector (协议, 端口)\n    └───Engine\n        └───Host(虚拟主机 localhost)\n            ├───Context1 (应用1, 可以设置虚拟路径, / 即 url 起始路径; 项目磁盘路径, 即 docBase )\n            │   │   index.html\n            │   └───WEB-INF\n            │       │   web.xml (servlet, filter, listener) 3.0之后不需要web.xml，可以通过编程的方式实现\n            │       ├───classes (servlet, controller, service ...)\n            │       ├───jsp\n            │       └───lib (第三方 jar 包)\n            └───Context2 (应用2)\n                │   index.html\n                └───WEB-INF\n                        web.xml\n```\n\n创建内嵌的`Tomcat`：\n\n```Java\npublic class HelloServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.setContentType(\"text/html;charset=utf-8\");\n        resp.getWriter().print(\"\"\"\n                <h3>hello</h3>\n                \"\"\");\n    }\n}\n\npublic class TestTomcat {\n    @SuppressWarnings(\"all\")\n    public static void main(String[] args) throws LifecycleException, IOException {\n        // 1.创建 Tomcat 对象\n        Tomcat tomcat = new Tomcat();\n        tomcat.setBaseDir(\"tomcat\");\n\n        // 2.创建项目文件夹, 即 docBase 文件夹\n        File docBase = Files.createTempDirectory(\"boot.\").toFile();\n        docBase.deleteOnExit();\n\n        // 3.创建 Tomcat 项目, 在 Tomcat 中称为 Context\n        Context context = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        // 4.编程添加 Servlet\n        context.addServletContainerInitializer(new ServletContainerInitializer() {\n            @Override\n            public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException {\n                HelloServlet helloServlet = new HelloServlet();\n                ctx.addServlet(\"aaa\", helloServlet).addMapping(\"/hello\");\n            }\n        }, Collections.emptySet());\n\n        // 5.启动 Tomcat\n        tomcat.start();\n\n        // 6.创建连接器, 设置监听端口\n        Connector connector = new Connector(new Http11Nio2Protocol());\n        connector.setPort(8080);\n        tomcat.setConnector(connector);\n    }\n}\n```\n\n启动`Tomcat`容器，访问http://localhost:8080/hello，浏览器输出：\n\n```Plain\nhello\n```\n\n## **Spring集成内嵌Tomcat**\n\n```Java\npublic class HelloServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.setContentType(\"text/html;charset=utf-8\");\n        resp.getWriter().print(\"\"\"\n                <h3>hello</h3>\n                \"\"\");\n    }\n}\n\npublic class TestTomcat {\n    @SuppressWarnings(\"all\")\n    public static void main(String[] args) throws LifecycleException, IOException {\n        // 1.创建 Tomcat 对象\n        Tomcat tomcat = new Tomcat();\n        tomcat.setBaseDir(\"tomcat\");\n\n        // 2.创建项目文件夹, 即 docBase 文件夹\n        File docBase = Files.createTempDirectory(\"boot.\").toFile();\n        docBase.deleteOnExit();\n\n        // 3.创建 Tomcat 项目, 在 Tomcat 中称为 Context\n        Context context = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        WebApplicationContext springContext = getApplicationContext();\n\n        // 4.编程添加 Servlet\n        context.addServletContainerInitializer(new ServletContainerInitializer() {\n            @Override\n            public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException {\n                HelloServlet helloServlet = new HelloServlet();\n                ctx.addServlet(\"aaa\", helloServlet).addMapping(\"/hello\");\n                // 首先匹配\"/hello\"路径，如果匹配不上，则进入\"/\"匹配\n                DispatcherServlet dispatcherServlet = springContext.getBean(DispatcherServlet.class);\n                ctx.addServlet(\"dispatcherServlet\", dispatcherServlet).addMapping(\"/\");\n            }\n        }, Collections.emptySet());\n\n        // 5.启动 Tomcat\n        tomcat.start();\n\n        // 6.创建连接器, 设置监听端口\n        Connector connector = new Connector(new Http11Nio2Protocol());\n        connector.setPort(8080);\n        tomcat.setConnector(connector);\n    }\n\n    public static WebApplicationContext getApplicationContext() {\n        // AnnotationConfigServletWebServerApplicationContext已经内嵌了Tomcat因此不用\n        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\n        context.register(Config.class);\n        context.refresh();\n        return context;\n    }\n\n    @Configuration\n    static class Config {\n        @Bean\n        public DispatcherServletRegistrationBean registrationBean(DispatcherServlet dispatcherServlet) {\n            return new DispatcherServletRegistrationBean(dispatcherServlet, \"/\");\n        }\n\n        @Bean\n        // 这个例子中必须为 DispatcherServlet 提供 AnnotationConfigWebApplicationContext, 否则会选择 XmlWebApplicationContext 实现\n        public DispatcherServlet dispatcherServlet(WebApplicationContext applicationContext) {\n            return new DispatcherServlet(applicationContext);\n        }\n\n        @Bean\n        public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {\n            RequestMappingHandlerAdapter handlerAdapter = new RequestMappingHandlerAdapter();\n            handlerAdapter.setMessageConverters(List.of(new MappingJackson2HttpMessageConverter()));\n            return handlerAdapter;\n        }\n\n        @RestController\n        static class MyController {\n            @GetMapping(\"hello2\")\n            public Map<String,Object> hello() {\n                return Map.of(\"hello2\", \"hello2, spring!\");\n            }\n        }\n    }\n}\n```\n\n启动`Tomcat`容器，访问http://localhost:8080/hello2，浏览器输出：\n\n```JSON\n{\n    \"hello2\": \"hello2, spring!\"\n}\n```\n\n在`context`的`addServletContainerInitializer()`方法我们注册`Servlet`不够通用，应该交由`ServletRegistrationBean`进行注册：\n\n```Java\ncontext.addServletContainerInitializer(new ServletContainerInitializer() {\n    @Override\n    public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException {\n        HelloServlet helloServlet = new HelloServlet();\n        ctx.addServlet(\"aaa\", helloServlet).addMapping(\"/hello\");\n        for (ServletRegistrationBean registrationBean : springContext.getBeansOfType(ServletRegistrationBean.class).values()) {\n            registrationBean.onStartup(ctx);\n        }\n    }\n}, Collections.emptySet());\n```\n\n`springboot`在整合`tomcat`时，先创建`spring`容器，在调用`refresh()`方法；`refresh()`方法中的`onRefresh()`就是以上演示的1~4步，最后在`finishRefresh()`方法中启动`tomcat`。\n\n```Java\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized(this.startupShutdownMonitor) {\n        StartupStep contextRefresh = this.applicationStartup.start(\"spring.context.refresh\");\n        this.prepareRefresh();\n        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();\n        this.prepareBeanFactory(beanFactory);\n\n        try {\n            this.postProcessBeanFactory(beanFactory);\n            StartupStep beanPostProcess = this.applicationStartup.start(\"spring.context.beans.post-process\");\n            this.invokeBeanFactoryPostProcessors(beanFactory);\n            this.registerBeanPostProcessors(beanFactory);\n            beanPostProcess.end();\n            this.initMessageSource();\n            this.initApplicationEventMulticaster();\n            this.onRefresh();\n            this.registerListeners();\n            this.finishBeanFactoryInitialization(beanFactory);\n            this.finishRefresh();\n        } catch (BeansException var10) {\n            if (this.logger.isWarnEnabled()) {\n                this.logger.warn(\"Exception encountered during context initialization - cancelling refresh attempt: \" + var10);\n            }\n\n            this.destroyBeans();\n            this.cancelRefresh(var10);\n            throw var10;\n        } finally {\n            this.resetCommonCaches();\n            contextRefresh.end();\n        }\n\n    }\n}\n```\n\n# **Boot自动配置原理**\n\n## Boot自动配置原理\n\n手动导入第三方配置类的通用方法，可以使用`@Import`注解：\n\n```Java\npublic class A41_1 {\n\n    @SuppressWarnings(\"all\")\n    public static void main(String[] args) throws IOException {\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"config\", Config.class);\n        context.registerBean(ConfigurationClassPostProcessor.class);\n        context.refresh();\n        for (String name : context.getBeanDefinitionNames()) {\n            System.out.println(name);\n        }\n    }\n\n    @Configuration // 本项目的配置类\n    @Import({AutoConfiguration1.class,AutoConfiguration2.class})\n    static class Config {\n    }\n\n    @Configuration // 第三方的配置类\n    static class AutoConfiguration1 {\n        @Bean\n        public Bean1 bean1() {\n            return new Bean1();\n        }\n    }\n\n    static class Bean1 {\n        private String name;\n\n        public Bean1() {\n        }\n\n        public Bean1(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"Bean1{\" +\n                   \"name='\" + name + '\\'' +\n                   '}';\n        }\n    }\n\n    @Configuration // 第三方的配置类\n    static class AutoConfiguration2 {\n        @Bean\n        public Bean2 bean2() {\n            return new Bean2();\n        }\n    }\n\n    static class Bean2 {\n\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nconfig\norg.springframework.context.annotation.ConfigurationClassPostProcessor\ncom.itheima.a41.A41_1$AutoConfiguration1\nbean1\ncom.itheima.a41.A41_1$AutoConfiguration2\nbean2\n```\n\n第三方的配置类也已经加入容器中。\n\n以上代码有一定的局限性，因为第三方的配置可能很多，写在代码中不方便管理，希望写在配置中，我们可以实现一个`ImportSelector`接口：\n\n```Java\n    static class MyImportSelector implements ImportSelector {\n\n        /**\n         * 返回值为配置类的类名\n         *\n         * @param importingClassMetadata\n         * @return\n         */\n        @Override\n        public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n            return new String[]{AutoConfiguration1.class.getName(), AutoConfiguration2.class.getName()};\n        }\n    }\n```\n\n再`Config`类上添加`@Import(MyImportSelector.class)`注解，此注解会读取`MyImportSelector`的返回值，并解析返回的配置类。\n\n运行启动类，查看控制台：\n\n```Plain\nconfig\norg.springframework.context.annotation.ConfigurationClassPostProcessor\ncom.itheima.a41.A41_1$AutoConfiguration1\nbean1\ncom.itheima.a41.A41_1$AutoConfiguration2\nbean2\n```\n\n效果和最初的一样。\n\n以上代码还可以进一步改进，我们希望配置不写在代码中，而是写在配置文件中。这些配置必须在`resources`下的名为`META-INF`目录下的名叫`spring.factories`的配置文件中。\n\n编写`spring.factories`配置文件：\n\n```Properties\ncom.itheima.a41.A41_1$MyImportSelector=\\\ncom.itheima.a41.A41_1.AutoConfiguration1,\\\ncom.itheima.a41.A41_1.AutoConfiguration2\n```\n\n修改`MyImportSelector`的实现：\n\n```Java\n    static class MyImportSelector implements ImportSelector {\n\n        /**\n         * 返回值为配置类的类名\n         *\n         * @param importingClassMetadata\n         * @return\n         */\n        @Override\n        public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n            List<String> names = SpringFactoriesLoader.loadFactoryNames(MyImportSelector.class, null);\n            return names.toArray(new String[0]);\n        }\n    }\n```\n\n运行启动类，查看控制台：\n\n```Plain\nconfig\norg.springframework.context.annotation.ConfigurationClassPostProcessor\ncom.itheima.a41.A41_1$AutoConfiguration1\nbean1\ncom.itheima.a41.A41_1$AutoConfiguration2\nbean2\n```\n\n也能成功解析第三方配置。\n\n`SpringFactoriesLoader`的扫描范围非常广，不仅扫描当前项目下的`spring.factories`配置文件，也会扫描依赖包中的`spring.factories`配置文件。\n\n我们可以打印一下`spring`的`spring.factories`配置文件中的部分类：\n\n```Java\n    static class MyImportSelector implements ImportSelector {\n\n        /**\n         * 返回值为配置类的类名\n         *\n         * @param importingClassMetadata\n         * @return\n         */\n        @Override\n        public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n            for (String name : SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, null)) {\n                System.out.println(name);\n            }\n            List<String> names = SpringFactoriesLoader.loadFactoryNames(MyImportSelector.class, null);\n            return names.toArray(new String[0]);\n        }\n    }\n```\n\n运行启动类，查看控制台：\n\n```Plain\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration\norg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration\norg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration\norg.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration\norg.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration\norg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration\norg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration\norg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration\norg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration\norg.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveDataAutoConfiguration\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration\norg.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration\norg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration\norg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration\norg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration\norg.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration\norg.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration\norg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration\norg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration\norg.springframework.boot.autoconfigure.gson.GsonAutoConfiguration\norg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration\norg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration\norg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration\norg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration\norg.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration\norg.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration\norg.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration\norg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration\norg.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration\norg.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration\norg.springframework.boot.autoconfigure.jms.JmsAutoConfiguration\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration\norg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration\norg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration\norg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration\norg.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration\norg.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration\norg.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration\norg.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration\norg.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration\norg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration\norg.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration\norg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration\norg.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration\norg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration\norg.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration\norg.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration\norg.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration\norg.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration\norg.springframework.boot.autoconfigure.neo4j.Neo4jAutoConfiguration\norg.springframework.boot.autoconfigure.netty.NettyAutoConfiguration\norg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration\norg.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration\norg.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration\norg.springframework.boot.autoconfigure.r2dbc.R2dbcTransactionManagerAutoConfiguration\norg.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration\norg.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration\norg.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration\norg.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration\norg.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration\norg.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration\norg.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration\norg.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration\norg.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration\norg.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration\norg.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration\norg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration\norg.springframework.boot.autoconfigure.session.SessionAutoConfiguration\norg.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration\norg.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration\norg.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration\norg.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration\norg.springframework.boot.autoconfigure.solr.SolrAutoConfiguration\norg.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration\norg.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration\norg.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration\norg.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration\norg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration\norg.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration\norg.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration\norg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration\norg.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration\norg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration\norg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration\norg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration\norg.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration\norg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration\norg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration\norg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration\norg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration\norg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration\norg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration\norg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration\norg.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration\norg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration\norg.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration\norg.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\ncom.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure\n```\n\n如果本项目的配置类和第三方的配置类冲突了会怎么样？\n\n我们在本项目中添加一个`Bean1`：\n\n```Java\nstatic class Config {\n    @Bean\n    public Bean1 bean1() {\n        return new Bean1(\"本项目\");\n    }\n}\n```\n\n在第三方配置中也添加一个`Bean1`：\n\n```Java\n@Configuration // 第三方的配置类\nstatic class AutoConfiguration1 {\n    @Bean\n    public Bean1 bean1() {\n        return new Bean1(\"第三方\");\n    }\n}\n```\n\n我们打印一下`Bean1`的名称：\n\n```Java\nSystem.out.println(context.getBean(Bean1.class));\n```\n\n运行启动类，查看控制台：\n\n```Plain\nBean1{name='本项目'}\n```\n\n发现是本项目中的`Bean`优先生效。\n\n由于`@Import()`首先解析第三方配置，再解析本项目配置，而`spring`中默认的`BeanFactory`支持同类型的`Bean`覆盖，因此最终是本项目中的`Bean`优先生效。\n\n但`springboot`中默认是不允许同名的`Bean`覆盖的，但可以进行设置：\n\n```Java\ncontext.getDefaultListableBeanFactory().setAllowBeanDefinitionOverriding(false);\n```\n\n我们先设置为`false`，即不允许覆盖，查看控制台，发现报错：\n\n```Plain\nException in thread \"main\" org.springframework.beans.factory.support.BeanDefinitionOverrideException: Invalid bean definition with name 'bean1' defined in com.itheima.a41.A41_1$Config: Cannot register bean definition [Root bean: class [null]; scope=; abstract=false; lazyInit=null; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=config; factoryMethodName=bean1; initMethodName=null; destroyMethodName=(inferred); defined in com.itheima.a41.A41_1$Config] for bean 'bean1': There is already [Root bean: class [null]; scope=; abstract=false; lazyInit=null; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=com.itheima.a41.A41_1$AutoConfiguration1; factoryMethodName=bean1; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/itheima/a41/A41_1$AutoConfiguration1.class]] bound.\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition(DefaultListableBeanFactory.java:995)\n        at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForBeanMethod(ConfigurationClassBeanDefinitionReader.java:295)\n        at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForConfigurationClass(ConfigurationClassBeanDefinitionReader.java:153)\n        at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(ConfigurationClassBeanDefinitionReader.java:129)\n        at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:343)\n        at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:247)\n        at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:311)\n        at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:112)\n        at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:746)\n        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:564)\n        at com.itheima.a41.A41_1.main(A41_1.java:20)\n```\n\n在`AllowBeanDefinitionOverriding`为`false`的情况下，如果本项目的配置类和第三方的配置类冲突，我们更希望使用本项目的配置，因此我们可以调整`@Import()`注解解析的顺序，我们可以实现`DeferredImportSelector`接口。这是一个延迟解析接口，它的解析顺序是先解析本项目的`Bean`，再去解析第三方的`Bean`。\n\n```Java\nstatic class MyImportSelector implements DeferredImportSelector {\n\n    /**\n     * 返回值为配置类的类名\n     *\n     * @param importingClassMetadata\n     * @return\n     */\n    @Override\n    public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n        List<String> names = SpringFactoriesLoader.loadFactoryNames(MyImportSelector.class, null);\n        return names.toArray(new String[0]);\n    }\n}\n```\n\n再次运行，发现报错：\n\n```Plain\nException in thread \"main\" org.springframework.beans.factory.support.BeanDefinitionOverrideException: Invalid bean definition with name 'bean1' defined in class path resource [com/itheima/a41/A41_1$AutoConfiguration1.class]: Cannot register bean definition [Root bean: class [null]; scope=; abstract=false; lazyInit=null; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=com.itheima.a41.A41_1$AutoConfiguration1; factoryMethodName=bean1; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/itheima/a41/A41_1$AutoConfiguration1.class]] for bean 'bean1': There is already [Root bean: class [null]; scope=; abstract=false; lazyInit=null; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=config; factoryMethodName=bean1; initMethodName=null; destroyMethodName=(inferred); defined in com.itheima.a41.A41_1$Config] bound.\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition(DefaultListableBeanFactory.java:995)\n        at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForBeanMethod(ConfigurationClassBeanDefinitionReader.java:295)\n        at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForConfigurationClass(ConfigurationClassBeanDefinitionReader.java:153)\n        at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(ConfigurationClassBeanDefinitionReader.java:129)\n        at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:343)\n        at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:247)\n        at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:311)\n        at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:112)\n        at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:746)\n        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:564)\n        at com.itheima.a41.A41_1.main(A41_1.java:20)\n```\n\n观察报错，发现首先加载的是本项目中的`Bean`。\n\n我们可以在第三方配置中添加`@ConditionalOnMissingBean`注解，也就是本项目没有此类型，才添加。\n\n```Java\n@Configuration // 第三方的配置类\nstatic class AutoConfiguration1 {\n    @Bean\n    @ConditionalOnMissingBean\n    public Bean1 bean1() {\n        return new Bean1(\"第三方\");\n    }\n}\n```\n\n## 经典自动配置实现\n\n1. **AopAutoConfiguration**\n\n我们先看一个示例：\n\n```Java\npublic class TestAopAuto {\n    public static void main(String[] args) {\n        GenericApplicationContext context = new GenericApplicationContext();\n        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());\n        context.registerBean(Config.class);\n        context.refresh();\n        for (String name : context.getBeanDefinitionNames()) {\n            System.out.println(name);\n        }\n    }\n\n    @Configuration\n    @Import(MyImportSelector.class)\n    static class Config {\n\n    }\n\n    static class MyImportSelector implements DeferredImportSelector {\n        @Override\n        public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n            return new String[]{AopAutoConfiguration.class.getName()};\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\norg.springframework.context.event.internalEventListenerProcessor\norg.springframework.context.event.internalEventListenerFactory\ncom.itheima.a41.TestAopAuto$Config\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration$AspectJAutoProxyingConfiguration$CglibAutoProxyConfiguration\norg.springframework.aop.config.internalAutoProxyCreator\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration$AspectJAutoProxyingConfiguration\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration\n```\n\n其中：\n\n```Plain\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration$AspectJAutoProxyingConfiguration$CglibAutoProxyConfiguration\norg.springframework.aop.config.internalAutoProxyCreator\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration$AspectJAutoProxyingConfiguration\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration\n```\n\n都是`AopAutoConfiguration`帮我们添加的`Bean`，接下来我们学习一下这四个`Bean`是如何添加进容器中的，分别有什么作用。\n\n我们进入`AopAutoConfiguration`源码：\n\n```Java\n@Configuration(\n    proxyBeanMethods = false\n)\n// 在配置文件中找一对键值，键前缀为\"spring.aop\"，名称为\"auto\"，值必须为\"true\"，满足这个条件此配置才生效\n// 或者项目中缺失了这个键值也视为生效，对应matchIfMissing = true\n@ConditionalOnProperty(\n    prefix = \"spring.aop\",\n    name = {\"auto\"},\n    havingValue = \"true\",\n    matchIfMissing = true\n)\npublic class AopAutoConfiguration {\n    public AopAutoConfiguration() {\n    }\n\n    @Configuration(\n        proxyBeanMethods = false\n    )\n    // 类路径下是否缺失org.aspectj.weaver.Advice类\n    @ConditionalOnMissingClass({\"org.aspectj.weaver.Advice\"})\n    @ConditionalOnProperty(\n        prefix = \"spring.aop\",\n        name = {\"proxy-target-class\"},\n        havingValue = \"true\",\n        matchIfMissing = true\n    )\n    static class ClassProxyingConfiguration {\n        ClassProxyingConfiguration() {\n        }\n\n        @Bean\n        static BeanFactoryPostProcessor forceAutoProxyCreatorToUseClassProxying() {\n            return (beanFactory) -> {\n                if (beanFactory instanceof BeanDefinitionRegistry) {\n                    BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;\n                    AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);\n                    AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);\n                }\n\n            };\n        }\n    }\n\n    @Configuration(\n        proxyBeanMethods = false\n    )\n    // 类路径下是否存在Advice类，一般使用spring时类路径下都会有此类\n    @ConditionalOnClass({Advice.class})\n    static class AspectJAutoProxyingConfiguration {\n        AspectJAutoProxyingConfiguration() {\n        }\n\n        @Configuration(\n            proxyBeanMethods = false\n        )\n        // proxyTargetClass为true表示不管类是否实现了接口都采用Cglib的方式创建代理\n        // proxyTargetClass为false表示类实现了接口优先使用jdk代理，否则使用Cglib的方式创建代理\n        @EnableAspectJAutoProxy(\n            proxyTargetClass = true\n        )\n        // 在配置文件中找一对键值，键前缀为\"spring.aop\"，名称为\"proxy-target-class\"，值必须为\"true\"\n        @ConditionalOnProperty(\n            prefix = \"spring.aop\",\n            name = {\"proxy-target-class\"},\n            havingValue = \"true\",\n            matchIfMissing = true\n        )\n        static class CglibAutoProxyConfiguration {\n            CglibAutoProxyConfiguration() {\n            }\n        }\n\n        @Configuration(\n            proxyBeanMethods = false\n        )\n        // 本质上是使用@Import的方式导入配置\n        @EnableAspectJAutoProxy(\n            proxyTargetClass = false\n        )\n        // 在配置文件中找一对键值，键前缀为\"spring.aop\"，名称为\"proxy-target-class\"，值必须为\"false\"\n        @ConditionalOnProperty(\n            prefix = \"spring.aop\",\n            name = {\"proxy-target-class\"},\n            havingValue = \"false\"\n        )\n        static class JdkDynamicAutoProxyConfiguration {\n            JdkDynamicAutoProxyConfiguration() {\n            }\n        }\n    }\n}\n```\n\n我们可以尝试手动添加配置，将`spring.aop.auto`置为`false`：\n\n```Java\nStandardEnvironment env = new StandardEnvironment();\nenv.getPropertySources().addLast(new SimpleCommandLinePropertySource(\"--spring.aop.auto=false\"));\ncontext.setEnvironment(env);\n```\n\n查看控制台：\n\n```Plain\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\norg.springframework.context.event.internalEventListenerProcessor\norg.springframework.context.event.internalEventListenerFactory\ncom.itheima.a41.TestAopAuto$Config\n```\n\n发现`AopAutoConfiguration`配置已经不生效了。\n\n进入`@EnableAspectJAutoProxy`注解：\n\n```Java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import({AspectJAutoProxyRegistrar.class})\npublic @interface EnableAspectJAutoProxy {\n    boolean proxyTargetClass() default false;\n\n    boolean exposeProxy() default false;\n}\n```\n\n`@Import`注解导入`AspectJAutoProxyRegistrar`类型的配置类，继续进入`AspectJAutoProxyRegistrar`源码：\n\n```Java\n/**\n* ImportBeanDefinitionRegistrar接口是以编程方式将BeanDefinition加入容器\n*/\nclass AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {\n    AspectJAutoProxyRegistrar() {\n    }\n\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n        // 添加ProxyCreator\n        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);\n        AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);\n        if (enableAspectJAutoProxy != null) {\n            if (enableAspectJAutoProxy.getBoolean(\"proxyTargetClass\")) {\n                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);\n            }\n\n            if (enableAspectJAutoProxy.getBoolean(\"exposeProxy\")) {\n                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);\n            }\n        }\n\n    }\n}\n```\n\n我们进入`registerAspectJAnnotationAutoProxyCreatorIfNecessary()`方法：\n\n```Java\n@Nullable\npublic static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry) {\n    return registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, (Object)null);\n}\n```\n\n再进入重载的`registerAspectJAnnotationAutoProxyCreatorIfNecessary()`方法：\n\n```Java\n@Nullable\npublic static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry, @Nullable Object source) {\n    return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);\n}\n```\n\n此方法加入了`AnnotationAwareAspectJAutoProxyCreator`，这是一个`Bean`的后处理器，主要作用就是为了创建代理。\n\n我们可以查看一下本项目使用的代理方式：\n\n```Java\nAnnotationAwareAspectJAutoProxyCreator creator = context.getBean(\n        \"org.springframework.aop.config.internalAutoProxyCreator\", AnnotationAwareAspectJAutoProxyCreator.class);\nSystem.out.println(creator.isProxyTargetClass());\n```\n\n控制台输出：\n\n```Plain\ntrue\n```\n\n**AopAutoConfiguration总结：**\n\n- AOP 自动配置类为 `org.springframework.boot.autoconfigure.aop.AopAutoConfiguration`\n- 可以通过 `spring.aop.auto=false` 禁用 aop 自动配置\n- AOP 自动配置的本质是通过 `@EnableAspectJAutoProxy` 来开启了自动代理，如果在引导类上自己添加了 `@EnableAspectJAutoProxy` 那么以自己添加的为准\n- `@EnableAspectJAutoProxy` 的本质是向容器中添加了 `AnnotationAwareAspectJAutoProxyCreator` 这个`bean`后处理器，它能够找到容器中所有切面，并为匹配切点的目标类创建代理，创建代理的工作一般是在 `bean`的初始化阶段完成的\n\n2. **DataSourceAutoConfiguration**\n\n编写以下代码，添加`DataSourceAutoConfiguration`、`MybatisAutoConfiguration`、`DataSourceTransactionManagerAutoConfiguration`、`TransactionAutoConfiguration`等第三方配置。\n\n```Java\npublic class TestDataSourceAuto {\n    @SuppressWarnings(\"all\")\n    public static void main(String[] args) {\n        GenericApplicationContext context = new GenericApplicationContext();\n        StandardEnvironment env = new StandardEnvironment();\n        env.getPropertySources().addLast(new SimpleCommandLinePropertySource(\n                \"--spring.datasource.url=jdbc:mysql://localhost:3306/secondhandtradingplatform\",\n                \"--spring.datasource.username=root\",\n                \"--spring.datasource.password=2001\"\n        ));\n        context.setEnvironment(env);\n        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());\n        context.registerBean(Config.class);\n        context.refresh();\n        for (String name : context.getBeanDefinitionNames()) {\n            String resourceDescription = context.getBeanDefinition(name).getResourceDescription();\n            if (resourceDescription != null)\n                System.out.println(name + \" 来源:\" + resourceDescription);\n        }\n    }\n\n    @Configuration\n    @Import(MyImportSelector.class)\n    static class Config {\n\n    }\n\n    static class MyImportSelector implements DeferredImportSelector {\n        @Override\n        public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n            return new String[]{\n                    DataSourceAutoConfiguration.class.getName(),\n                    MybatisAutoConfiguration.class.getName(),\n                    DataSourceTransactionManagerAutoConfiguration.class.getName(),\n                    TransactionAutoConfiguration.class.getName()\n            };\n        }\n    }\n}\n```\n\n查看输出：\n\n```Plain\ndataSource 来源:class path resource [org/springframework/boot/autoconfigure/jdbc/DataSourceConfiguration$Hikari.class]\nhikariPoolDataSourceMetadataProvider 来源:class path resource [org/springframework/boot/autoconfigure/jdbc/metadata/DataSourcePoolMetadataProvidersConfiguration$HikariPoolDataSourceMetadataProviderConfiguration.class]\nsqlSessionFactory 来源:class path resource [org/mybatis/spring/boot/autoconfigure/MybatisAutoConfiguration.class]\nsqlSessionTemplate 来源:class path resource [org/mybatis/spring/boot/autoconfigure/MybatisAutoConfiguration.class]\ntransactionManager 来源:class path resource [org/springframework/boot/autoconfigure/jdbc/DataSourceTransactionManagerAutoConfiguration$JdbcTransactionManagerConfiguration.class]\norg.springframework.transaction.config.internalTransactionAdvisor 来源:class path resource [org/springframework/transaction/annotation/ProxyTransactionManagementConfiguration.class]\ntransactionAttributeSource 来源:class path resource [org/springframework/transaction/annotation/ProxyTransactionManagementConfiguration.class]\ntransactionInterceptor 来源:class path resource [org/springframework/transaction/annotation/ProxyTransactionManagementConfiguration.class]\norg.springframework.transaction.config.internalTransactionalEventListenerFactory 来源:class path resource [org/springframework/transaction/annotation/ProxyTransactionManagementConfiguration.class]\ntransactionTemplate 来源:class path resource [org/springframework/boot/autoconfigure/transaction/TransactionAutoConfiguration$TransactionTemplateConfiguration.class]\nplatformTransactionManagerCustomizers 来源:class path resource [org/springframework/boot/autoconfigure/transaction/TransactionAutoConfiguration.class]\n```\n\n这些第三方配置给我们添加了很多`Bean`。\n\n进入`DataSourceAutoConfiguration`中：\n\n```Java\n@Configuration(\n    proxyBeanMethods = false\n)\n@ConditionalOnClass({DataSource.class, EmbeddedDatabaseType.class})\n@ConditionalOnMissingBean(\n    type = {\"io.r2dbc.spi.ConnectionFactory\"}\n)\n// 绑定环境中以spring.datasource为前缀的键值信息\n@EnableConfigurationProperties({DataSourceProperties.class})\n@Import({DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.InitializationSpecificCredentialsDataSourceInitializationConfiguration.class, DataSourceInitializationConfiguration.SharedCredentialsDataSourceInitializationConfiguration.class})\npublic class DataSourceAutoConfiguration {\n    public DataSourceAutoConfiguration() {\n    }\n\n    static class EmbeddedDatabaseCondition extends SpringBootCondition {\n        private static final String DATASOURCE_URL_PROPERTY = \"spring.datasource.url\";\n        private final SpringBootCondition pooledCondition = new PooledDataSourceCondition();\n\n        EmbeddedDatabaseCondition() {\n        }\n\n        public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {\n            ConditionMessage.Builder message = ConditionMessage.forCondition(\"EmbeddedDataSource\", new Object[0]);\n            if (this.hasDataSourceUrlProperty(context)) {\n                return ConditionOutcome.noMatch(message.because(\"spring.datasource.url is set\"));\n            } else if (this.anyMatches(context, metadata, new Condition[]{this.pooledCondition})) {\n                return ConditionOutcome.noMatch(message.foundExactly(\"supported pooled data source\"));\n            } else {\n                EmbeddedDatabaseType type = EmbeddedDatabaseConnection.get(context.getClassLoader()).getType();\n                return type == null ? ConditionOutcome.noMatch(message.didNotFind(\"embedded database\").atAll()) : ConditionOutcome.match(message.found(\"embedded database\").items(new Object[]{type}));\n            }\n        }\n\n        private boolean hasDataSourceUrlProperty(ConditionContext context) {\n            Environment environment = context.getEnvironment();\n            if (environment.containsProperty(\"spring.datasource.url\")) {\n                try {\n                    return StringUtils.hasText(environment.getProperty(\"spring.datasource.url\"));\n                } catch (IllegalArgumentException var4) {\n                }\n            }\n\n            return false;\n        }\n    }\n\n    static class PooledDataSourceAvailableCondition extends SpringBootCondition {\n        PooledDataSourceAvailableCondition() {\n        }\n\n        public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {\n            ConditionMessage.Builder message = ConditionMessage.forCondition(\"PooledDataSource\", new Object[0]);\n            return DataSourceBuilder.findType(context.getClassLoader()) != null ? ConditionOutcome.match(message.foundExactly(\"supported DataSource\")) : ConditionOutcome.noMatch(message.didNotFind(\"supported DataSource\").atAll());\n        }\n    }\n\n    static class PooledDataSourceCondition extends AnyNestedCondition {\n        PooledDataSourceCondition() {\n            super(ConfigurationPhase.PARSE_CONFIGURATION);\n        }\n\n        @Conditional({PooledDataSourceAvailableCondition.class})\n        static class PooledDataSourceAvailable {\n            PooledDataSourceAvailable() {\n            }\n        }\n\n        @ConditionalOnProperty(\n            prefix = \"spring.datasource\",\n            name = {\"type\"}\n        )\n        static class ExplicitType {\n            ExplicitType() {\n            }\n        }\n    }\n\n    @Configuration(\n        proxyBeanMethods = false\n    )\n     // 是否支持连接池数据源\n    @Conditional({PooledDataSourceCondition.class})\n    @ConditionalOnMissingBean({DataSource.class, XADataSource.class})\n    // 导入以下数据源配置\n    @Import({DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class, DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class, DataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class})\n    protected static class PooledDataSourceConfiguration {\n        protected PooledDataSourceConfiguration() {\n        }\n    }\n\n    @Configuration(\n        proxyBeanMethods = false\n    )\n    // 是否支持内嵌数据源\n    @Conditional({EmbeddedDatabaseCondition.class})\n    @ConditionalOnMissingBean({DataSource.class, XADataSource.class})\n    @Import({EmbeddedDataSourceConfiguration.class})\n    protected static class EmbeddedDatabaseConfiguration {\n        protected EmbeddedDatabaseConfiguration() {\n        }\n    }\n}\n```\n\n在`spring`容器创建时候`DataSourceProperties`会绑定以`spring.datasource`为前缀的键值信息，我们这里可以打印一下：\n\n```Java\nDataSourceProperties dataSourceProperties = context.getBean(DataSourceProperties.class);\nSystem.out.println(dataSourceProperties.getUrl());\nSystem.out.println(dataSourceProperties.getUsername());\nSystem.out.println(dataSourceProperties.getPassword());\n```\n\n查看输出：\n\n```Plain\njdbc:mysql://localhost:3306/secondhandtradingplatform\nroot\n2001\n```\n\n我们可以查看`DataSourceConfiguration.Hikari.class`类：\n\n```Java\nstatic class Hikari {\n    Hikari() {\n    }\n\n    @Bean\n    @ConfigurationProperties(\n        prefix = \"spring.datasource.hikari\"\n    )\n    HikariDataSource dataSource(DataSourceProperties properties) {\n        HikariDataSource dataSource = (HikariDataSource)DataSourceConfiguration.createDataSource(properties, HikariDataSource.class);\n        if (StringUtils.hasText(properties.getName())) {\n            dataSource.setPoolName(properties.getName());\n        }\n\n        return dataSource;\n    }\n}\n```\n\n`dataSource()`方法上标注了`@Bean`注解，参数依赖注入了`DataSourceProperties`，在`createDataSource()`方法中会使用到`DataSourceProperties`。\n\n```Java\nprotected static <T> T createDataSource(DataSourceProperties properties, Class<? extends DataSource> type) {\n    return properties.initializeDataSourceBuilder().type(type).build();\n}\n```\n\n**DataSourceAutoConfiguration总结：**\n\n- 对应的自动配置类为：`org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration`\n- 它内部采用了条件装配，通过检查容器的`bean`，以及类路径下的`class`，来决定该`@Bean`是否生效\n\n`Spring Boot`支持两大类数据源：\n\n- `EmbeddedDatabase `- 内嵌数据库连接池\n- `PooledDataSource `- 非内嵌数据库连接池\n\n`PooledDataSource`又支持如下数据源\n\n- `hikari`提供的`HikariDataSource`\n- `tomcat-jdbc`提供的`DataSource`\n- `dbcp2`提供的`BasicDataSource`\n- `oracle`提供的`PoolDataSourceImpl`\n\n如果知道数据源的实现类类型，即指定了 `spring.datasource.type`，理论上可以支持所有数据源，但这样做的一个最大问题是无法订制每种数据源的详细配置（如最大、最小连接数等）\n\n3. **MybatisAutoConfiguration**\n\n进入`MybatisAutoConfiguration`类：\n\n```Java\n@Configuration\n// 必须在类路径下找到SqlSessionFactory类、SqlSessionFactoryBean类\n@ConditionalOnClass({SqlSessionFactory.class, SqlSessionFactoryBean.class})\n// 在类路径下必须找到有且仅有一个的DataSource类型\n@ConditionalOnSingleCandidate(DataSource.class)\n// 绑定环境中以\"mybatis\"为前缀的键值信息\n@EnableConfigurationProperties({MybatisProperties.class})\n// 控制多个配置类的解析顺序，必须在DataSourceAutoConfiguration类与MybatisLanguageDriverAutoConfiguration类解析之后\n@AutoConfigureAfter({DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class})\npublic class MybatisAutoConfiguration implements InitializingBean {\n    private static final Logger logger = LoggerFactory.getLogger(MybatisAutoConfiguration.class);\n    private final MybatisProperties properties;\n    private final Interceptor[] interceptors;\n    private final TypeHandler[] typeHandlers;\n    private final LanguageDriver[] languageDrivers;\n    private final ResourceLoader resourceLoader;\n    private final DatabaseIdProvider databaseIdProvider;\n    private final List<ConfigurationCustomizer> configurationCustomizers;\n\n    public MybatisAutoConfiguration(MybatisProperties properties, ObjectProvider<Interceptor[]> interceptorsProvider, ObjectProvider<TypeHandler[]> typeHandlersProvider, ObjectProvider<LanguageDriver[]> languageDriversProvider, ResourceLoader resourceLoader, ObjectProvider<DatabaseIdProvider> databaseIdProvider, ObjectProvider<List<ConfigurationCustomizer>> configurationCustomizersProvider) {\n        this.properties = properties;\n        this.interceptors = (Interceptor[])interceptorsProvider.getIfAvailable();\n        this.typeHandlers = (TypeHandler[])typeHandlersProvider.getIfAvailable();\n        this.languageDrivers = (LanguageDriver[])languageDriversProvider.getIfAvailable();\n        this.resourceLoader = resourceLoader;\n        this.databaseIdProvider = (DatabaseIdProvider)databaseIdProvider.getIfAvailable();\n        this.configurationCustomizers = (List)configurationCustomizersProvider.getIfAvailable();\n    }\n\n    public void afterPropertiesSet() {\n        this.checkConfigFileExists();\n    }\n\n    private void checkConfigFileExists() {\n        if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {\n            Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());\n            Assert.state(resource.exists(), \"Cannot find config location: \" + resource + \" (please add config file or check your Mybatis configuration)\");\n        }\n\n    }\n\n    @Bean\n    // 当容器中没有SqlSessionFactory类时生效\n    @ConditionalOnMissingBean\n    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n        SqlSessionFactoryBean factory = new SqlSessionFactoryBean();\n        factory.setDataSource(dataSource);\n        factory.setVfs(SpringBootVFS.class);\n        if (StringUtils.hasText(this.properties.getConfigLocation())) {\n            factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));\n        }\n\n        this.applyConfiguration(factory);\n        if (this.properties.getConfigurationProperties() != null) {\n            factory.setConfigurationProperties(this.properties.getConfigurationProperties());\n        }\n\n        if (!ObjectUtils.isEmpty(this.interceptors)) {\n            factory.setPlugins(this.interceptors);\n        }\n\n        if (this.databaseIdProvider != null) {\n            factory.setDatabaseIdProvider(this.databaseIdProvider);\n        }\n\n        if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {\n            factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());\n        }\n\n        if (this.properties.getTypeAliasesSuperType() != null) {\n            factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());\n        }\n\n        if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {\n            factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());\n        }\n\n        if (!ObjectUtils.isEmpty(this.typeHandlers)) {\n            factory.setTypeHandlers(this.typeHandlers);\n        }\n\n        if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {\n            factory.setMapperLocations(this.properties.resolveMapperLocations());\n        }\n\n        Set<String> factoryPropertyNames = (Set)Stream.of((new BeanWrapperImpl(SqlSessionFactoryBean.class)).getPropertyDescriptors()).map(FeatureDescriptor::getName).collect(Collectors.toSet());\n        Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();\n        if (factoryPropertyNames.contains(\"scriptingLanguageDrivers\") && !ObjectUtils.isEmpty(this.languageDrivers)) {\n            factory.setScriptingLanguageDrivers(this.languageDrivers);\n            if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {\n                defaultLanguageDriver = this.languageDrivers[0].getClass();\n            }\n        }\n\n        if (factoryPropertyNames.contains(\"defaultScriptingLanguageDriver\")) {\n            factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);\n        }\n\n        return factory.getObject();\n    }\n\n    private void applyConfiguration(SqlSessionFactoryBean factory) {\n        org.apache.ibatis.session.Configuration configuration = this.properties.getConfiguration();\n        if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {\n            configuration = new org.apache.ibatis.session.Configuration();\n        }\n\n        if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {\n            Iterator var3 = this.configurationCustomizers.iterator();\n\n            while(var3.hasNext()) {\n                ConfigurationCustomizer customizer = (ConfigurationCustomizer)var3.next();\n                customizer.customize(configuration);\n            }\n        }\n\n        factory.setConfiguration(configuration);\n    }\n\n    @Bean\n    // 提供SqlSessionTemplate Bean\n    @ConditionalOnMissingBean\n    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {\n        ExecutorType executorType = this.properties.getExecutorType();\n        return executorType != null ? new SqlSessionTemplate(sqlSessionFactory, executorType) : new SqlSessionTemplate(sqlSessionFactory);\n    }\n\n    @Configuration\n    @Import({AutoConfiguredMapperScannerRegistrar.class})\n    // 容器中必须缺失MapperFactoryBean类、MapperScannerConfigurer类，此配置才生效\n    @ConditionalOnMissingBean({MapperFactoryBean.class, MapperScannerConfigurer.class})\n    public static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean {\n        public MapperScannerRegistrarNotFoundConfiguration() {\n        }\n\n        public void afterPropertiesSet() {\n            MybatisAutoConfiguration.logger.debug(\"Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.\");\n        }\n    }\n\n    public static class AutoConfiguredMapperScannerRegistrar implements BeanFactoryAware, ImportBeanDefinitionRegistrar {\n        private BeanFactory beanFactory;\n\n        public AutoConfiguredMapperScannerRegistrar() {\n        }\n\n        public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n            if (!AutoConfigurationPackages.has(this.beanFactory)) {\n                MybatisAutoConfiguration.logger.debug(\"Could not determine auto-configuration package, automatic mapper scanning disabled.\");\n            } else {\n                MybatisAutoConfiguration.logger.debug(\"Searching for mappers annotated with @Mapper\");\n                List<String> packages = AutoConfigurationPackages.get(this.beanFactory);\n                if (MybatisAutoConfiguration.logger.isDebugEnabled()) {\n                    packages.forEach((pkg) -> {\n                        MybatisAutoConfiguration.logger.debug(\"Using auto-configuration base package '{}'\", pkg);\n                    });\n                }\n\n                BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);\n                builder.addPropertyValue(\"processPropertyPlaceHolders\", true);\n                builder.addPropertyValue(\"annotationClass\", Mapper.class);\n                builder.addPropertyValue(\"basePackage\", StringUtils.collectionToCommaDelimitedString(packages));\n                BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);\n                Set<String> propertyNames = (Set)Stream.of(beanWrapper.getPropertyDescriptors()).map(FeatureDescriptor::getName).collect(Collectors.toSet());\n                if (propertyNames.contains(\"lazyInitialization\")) {\n                    builder.addPropertyValue(\"lazyInitialization\", \"${mybatis.lazy-initialization:false}\");\n                }\n\n                if (propertyNames.contains(\"defaultScope\")) {\n                    builder.addPropertyValue(\"defaultScope\", \"${mybatis.mapper-default-scope:}\");\n                }\n\n                registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());\n            }\n        }\n\n        public void setBeanFactory(BeanFactory beanFactory) {\n            this.beanFactory = beanFactory;\n        }\n    }\n}\n```\n\n我们添加`mybatis`的包扫描：\n\n```Java\nString packageName = TestDataSourceAuto.class.getPackageName();\nAutoConfigurationPackages.register(context.getDefaultListableBeanFactory(),\n        packageName);\n```\n\n查看控制台输出：\n\n```Plain\nmapper1 来源:file [F:\\Java\\黑马全套java教程\\第2阶段企业级开发—基础框架\\7、spring高级45讲\\代码\\代码\\show\\target\\classes\\com\\itheima\\a41\\mapper\\Mapper1.class]\nmapper2 来源:file [F:\\Java\\黑马全套java教程\\第2阶段企业级开发—基础框架\\7、spring高级45讲\\代码\\代码\\show\\target\\classes\\com\\itheima\\a41\\mapper\\Mapper2.class]\n```\n\n发现能将我们的自定义mapper加入到容器中。\n\n`SpringBoot`在启动时也会将报名进行注册，查看`@SpringBootApplication`注解：\n\n```Java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\n    excludeFilters = {@Filter(\n    type = FilterType.CUSTOM,\n    classes = {TypeExcludeFilter.class}\n), @Filter(\n    type = FilterType.CUSTOM,\n    classes = {AutoConfigurationExcludeFilter.class}\n)}\n)\npublic @interface SpringBootApplication {\n    //...\n}\n```\n\n进入`@EnableAutoConfiguration`注解中：\n\n```Java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import({AutoConfigurationImportSelector.class})\npublic @interface EnableAutoConfiguration {\n    String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n\n    Class<?>[] exclude() default {};\n\n    String[] excludeName() default {};\n}\n```\n\n再进入`@AutoConfigurationPackage`注解：\n\n```Java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Import({AutoConfigurationPackages.Registrar.class})\npublic @interface AutoConfigurationPackage {\n    String[] basePackages() default {};\n\n    Class<?>[] basePackageClasses() default {};\n}\n```\n\n再进入`AutoConfigurationPackages.Registrar.class`中：\n\n```Java\nstatic class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {\n    Registrar() {\n    }\n\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n        AutoConfigurationPackages.register(registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0]));\n    }\n\n    public Set<Object> determineImports(AnnotationMetadata metadata) {\n        return Collections.singleton(new PackageImports(metadata));\n    }\n}\n```\n\n我们可以发现在`registerBeanDefinitions()`方法中注册了包名。\n\n**MybatisAutoConfiguration总结：**\n\n- MyBatis 自动配置类为 `org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration`\n- 它主要配置了两个`bean`\n    - `SqlSessionFactory`：`MyBatis`核心对象，用来创建`SqlSession`\n    - `SqlSessionTemplate`：`SqlSession`的实现，此实现会与当前线程绑定\n    - 用`ImportBeanDefinitionRegistrar`的方式扫描所有标注了`@Mapper`注解的接口\n    - 用`AutoConfigurationPackages`来确定扫描的包\n- 还有一个相关的`bean`：`MybatisProperties`，它会读取配置文件中带 `mybatis.` 前缀的配置项进行定制配置\n\n`@MapperScan`注解的作用与`MybatisAutoConfiguration`类似，和`MapperScannerConfigurer`有如下区别：\n\n- `@MapperScan`扫描具体包（当然也可以配置关注哪个注解）\n- `@MapperScan`如果不指定扫描具体包，则会把引导类范围内，所有接口当做Mapper接口\n- `MybatisAutoConfiguration`关注的是所有标注`@Mapper`注解的接口，会忽略掉非`@Mapper`标注的接口\n\n4. **DataSourceTransactionManagerAutoConfiguration**\n\n`TransactionManager`是事务管理器，其作用是去执行底层事务的相关方法。\n\n进入`DataSourceTransactionManagerAutoConfiguration`类：\n\n```Java\n@Configuration(\n    proxyBeanMethods = false\n)\n@ConditionalOnClass({JdbcTemplate.class, TransactionManager.class})\n@AutoConfigureOrder(Integer.MAX_VALUE)\n@EnableConfigurationProperties({DataSourceProperties.class})\npublic class DataSourceTransactionManagerAutoConfiguration {\n    public DataSourceTransactionManagerAutoConfiguration() {\n    }\n\n    @Configuration(\n        proxyBeanMethods = false\n    )\n    @ConditionalOnSingleCandidate(DataSource.class)\n    static class JdbcTransactionManagerConfiguration {\n        JdbcTransactionManagerConfiguration() {\n        }\n\n        @Bean\n        // 当缺失了TransactionManager才进行注入\n        @ConditionalOnMissingBean({TransactionManager.class})\n        DataSourceTransactionManager transactionManager(Environment environment, DataSource dataSource, ObjectProvider<TransactionManagerCustomizers> transactionManagerCustomizers) {\n            DataSourceTransactionManager transactionManager = this.createTransactionManager(environment, dataSource);\n            transactionManagerCustomizers.ifAvailable((customizers) -> {\n                customizers.customize(transactionManager);\n            });\n            return transactionManager;\n        }\n\n        private DataSourceTransactionManager createTransactionManager(Environment environment, DataSource dataSource) {\n            return (DataSourceTransactionManager)((Boolean)environment.getProperty(\"spring.dao.exceptiontranslation.enabled\", Boolean.class, Boolean.TRUE) ? new JdbcTransactionManager(dataSource) : new DataSourceTransactionManager(dataSource));\n        }\n    }\n}\n```\n\n5. **TransactionAutoConfiguration**\n\n- 事务自动配置类有两个：\n    - `org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration`\n    - `org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration`\n- 前者配置了`DataSourceTransactionManager`用来执行事务的提交、回滚操作\n- 后者功能上对标`@EnableTransactionManagement`，包含以下三个`bean`\n    - `BeanFactoryTransactionAttributeSourceAdvisor`事务切面类，包含通知和切点\n    - `TransactionInterceptor`事务通知类，由它在目标方法调用前后加入事务操作\n    - `AnnotationTransactionAttributeSource`会解析`@Transactional`及事务属性，也包含了切点功能\n- 如果自己配置了`DataSourceTransactionManager`或是在引导类加了`@EnableTransactionManagement`，则以自己配置的为准\n\n6. **ServletWebServerFactoryAutoConfiguration**\n\n编写测试代码，添加`ServletWebServerFactoryAutoConfiguration`、`DispatcherServletAutoConfiguration`、`WebMvcAutoConfiguration`、`ErrorMvcAutoConfiguration`等第三方配置\n\n```Java\npublic class TestMvcAuto {\n    @SuppressWarnings(\"all\")\n    public static void main(String[] args) {\n        AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext();\n        context.registerBean(Config.class);\n        context.refresh();\n        for (String name : context.getBeanDefinitionNames()) {\n            String source = context.getBeanDefinition(name).getResourceDescription();\n            if (source != null) {\n                System.out.println(name + \" 来源:\" + source);\n            }\n        }\n        context.close();\n    }\n\n    @Configuration\n    @Import(MyImportSelector.class)\n    static class Config {\n\n    }\n\n    static class MyImportSelector implements DeferredImportSelector {\n        @Override\n        public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n            return new String[]{\n                    ServletWebServerFactoryAutoConfiguration.class.getName(),\n                    DispatcherServletAutoConfiguration.class.getName(),\n                    WebMvcAutoConfiguration.class.getName(),\n                    ErrorMvcAutoConfiguration.class.getName()\n            };\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\ntomcatServletWebServerFactory 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/ServletWebServerFactoryConfiguration$EmbeddedTomcat.class]\nservletWebServerFactoryCustomizer 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/ServletWebServerFactoryAutoConfiguration.class]\ntomcatServletWebServerFactoryCustomizer 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/ServletWebServerFactoryAutoConfiguration.class]\ndispatcherServlet 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/DispatcherServletAutoConfiguration$DispatcherServletConfiguration.class]\ndispatcherServletRegistration 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/DispatcherServletAutoConfiguration$DispatcherServletRegistrationConfiguration.class]\nrequestMappingHandlerAdapter 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nrequestMappingHandlerMapping 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nwelcomePageHandlerMapping 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nlocaleResolver 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nthemeResolver 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nflashMapManager 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nmvcConversionService 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nmvcValidator 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nmvcContentNegotiationManager 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nmvcPatternParser 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nmvcUrlPathHelper 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nmvcPathMatcher 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nviewControllerHandlerMapping 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nbeanNameHandlerMapping 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nrouterFunctionMapping 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nresourceHandlerMapping 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nmvcResourceUrlProvider 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\ndefaultServletHandlerMapping 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nhandlerFunctionAdapter 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nmvcUriComponentsContributor 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nhttpRequestHandlerAdapter 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nsimpleControllerHandlerAdapter 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nhandlerExceptionResolver 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nmvcViewResolver 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nmvcHandlerMappingIntrospector 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\nviewNameTranslator 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]\ndefaultViewResolver 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter.class]\nviewResolver 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter.class]\nrequestContextFilter 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter.class]\nformContentFilter 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.class]\nerror 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/error/ErrorMvcAutoConfiguration$WhitelabelErrorViewConfiguration.class]\nbeanNameViewResolver 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/error/ErrorMvcAutoConfiguration$WhitelabelErrorViewConfiguration.class]\nconventionErrorViewResolver 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/error/ErrorMvcAutoConfiguration$DefaultErrorViewResolverConfiguration.class]\nerrorAttributes 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/error/ErrorMvcAutoConfiguration.class]\nbasicErrorController 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/error/ErrorMvcAutoConfiguration.class]\nerrorPageCustomizer 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/error/ErrorMvcAutoConfiguration.class]\npreserveErrorControllerTargetClassPostProcessor 来源:class path resource [org/springframework/boot/autoconfigure/web/servlet/error/ErrorMvcAutoConfiguration.class]\ntomcatServletWebServerFactory`来源为`class path resource [org/springframework/boot/autoconfigure/web/servlet/ServletWebServerFactoryConfiguration$EmbeddedTomcat.class]\n```\n\n进入`ServletWebServerFactoryConfiguration`，其中支持多种内嵌服务器：\n\n```Java\n@Configuration(\n    proxyBeanMethods = false\n)\nclass ServletWebServerFactoryConfiguration {\n    ServletWebServerFactoryConfiguration() {\n    }\n\n    @Configuration(\n        proxyBeanMethods = false\n    )\n    @ConditionalOnClass({Servlet.class, Undertow.class, SslClientAuthMode.class})\n    @ConditionalOnMissingBean(\n        value = {ServletWebServerFactory.class},\n        search = SearchStrategy.CURRENT\n    )\n    static class EmbeddedUndertow {\n        EmbeddedUndertow() {\n        }\n\n        @Bean\n        UndertowServletWebServerFactory undertowServletWebServerFactory(ObjectProvider<UndertowDeploymentInfoCustomizer> deploymentInfoCustomizers, ObjectProvider<UndertowBuilderCustomizer> builderCustomizers) {\n            UndertowServletWebServerFactory factory = new UndertowServletWebServerFactory();\n            factory.getDeploymentInfoCustomizers().addAll((Collection)deploymentInfoCustomizers.orderedStream().collect(Collectors.toList()));\n            factory.getBuilderCustomizers().addAll((Collection)builderCustomizers.orderedStream().collect(Collectors.toList()));\n            return factory;\n        }\n\n        @Bean\n        UndertowServletWebServerFactoryCustomizer undertowServletWebServerFactoryCustomizer(ServerProperties serverProperties) {\n            return new UndertowServletWebServerFactoryCustomizer(serverProperties);\n        }\n    }\n\n    @Configuration(\n        proxyBeanMethods = false\n    )\n    @ConditionalOnClass({Servlet.class, Server.class, Loader.class, WebAppContext.class})\n    @ConditionalOnMissingBean(\n        value = {ServletWebServerFactory.class},\n        search = SearchStrategy.CURRENT\n    )\n    static class EmbeddedJetty {\n        EmbeddedJetty() {\n        }\n\n        @Bean\n        JettyServletWebServerFactory JettyServletWebServerFactory(ObjectProvider<JettyServerCustomizer> serverCustomizers) {\n            JettyServletWebServerFactory factory = new JettyServletWebServerFactory();\n            factory.getServerCustomizers().addAll((Collection)serverCustomizers.orderedStream().collect(Collectors.toList()));\n            return factory;\n        }\n    }\n\n    @Configuration(\n        proxyBeanMethods = false\n    )\n    @ConditionalOnClass({Servlet.class, Tomcat.class, UpgradeProtocol.class})\n    @ConditionalOnMissingBean(\n        value = {ServletWebServerFactory.class},\n        search = SearchStrategy.CURRENT\n    )\n    static class EmbeddedTomcat {\n        EmbeddedTomcat() {\n        }\n\n        @Bean\n        TomcatServletWebServerFactory tomcatServletWebServerFactory(ObjectProvider<TomcatConnectorCustomizer> connectorCustomizers, ObjectProvider<TomcatContextCustomizer> contextCustomizers, ObjectProvider<TomcatProtocolHandlerCustomizer<?>> protocolHandlerCustomizers) {\n            TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();\n            factory.getTomcatConnectorCustomizers().addAll((Collection)connectorCustomizers.orderedStream().collect(Collectors.toList()));\n            factory.getTomcatContextCustomizers().addAll((Collection)contextCustomizers.orderedStream().collect(Collectors.toList()));\n            factory.getTomcatProtocolHandlerCustomizers().addAll((Collection)protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));\n            return factory;\n        }\n    }\n}\n```\n\n**ServletWebServerFactoryAutoConfiguration总结：**\n\n- 提供`ServletWebServerFactory`\n\n7. **DispatcherServletAutoConfiguration**\n\n```\ndispatcherServlet`来源为`class path resource [org/springframework/boot/autoconfigure/web/servlet/DispatcherServletAutoConfiguration$DispatcherServletConfiguration.class]\n```\n\n我们进入`DispatcherServletConfiguration`：\n\n```Java\n@AutoConfigureOrder(Integer.MIN_VALUE)\n@Configuration(\n    proxyBeanMethods = false\n)\n@ConditionalOnWebApplication(\n    type = Type.SERVLET\n)\n@ConditionalOnClass({DispatcherServlet.class})\n@AutoConfigureAfter({ServletWebServerFactoryAutoConfiguration.class})\npublic class DispatcherServletAutoConfiguration {\n    \n    // ...\n    \n    @Configuration(\n        proxyBeanMethods = false\n    )\n    @Conditional({DefaultDispatcherServletCondition.class})\n    @ConditionalOnClass({ServletRegistration.class})\n    @EnableConfigurationProperties({WebMvcProperties.class})\n    protected static class DispatcherServletConfiguration {\n        protected DispatcherServletConfiguration() {\n        }\n\n        @Bean(\n            name = {\"dispatcherServlet\"}\n        )\n        public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) {\n            DispatcherServlet dispatcherServlet = new DispatcherServlet();\n            dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());\n            dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());\n            dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound());\n            dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());\n            dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails());\n            return dispatcherServlet;\n        }\n\n        @Bean\n        @ConditionalOnBean({MultipartResolver.class})\n        @ConditionalOnMissingBean(\n            name = {\"multipartResolver\"}\n        )\n        public MultipartResolver multipartResolver(MultipartResolver resolver) {\n            return resolver;\n        }\n    }\n    \n    // ...\n}\n```\n\n**DispatcherServletAutoConfiguration总结：**\n\n- 提供`DispatcherServlet`\n- 提供`DispatcherServletRegistrationBean`\n\n8. **WebMvcAutoConfiguration**\n\n**WebMvcAutoConfiguration总结：**\n\n- 配置`DispatcherServlet`的各项组件，提供的`bean`见过的有\n    - 多项`HandlerMapping`\n    - 多项`HandlerAdapter`\n    - `HandlerExceptionResolver`\n\n9. **ErrorMvcAutoConfiguration**\n\n**ErrorMvcAutoConfiguration总结：**\n\n- 提供的`bean`有`BasicErrorController`\n\n10. **MultipartAutoConfiguration**\n\n**MultipartAutoConfiguration总结：**\n\n- 它提供了`org.springframework.web.multipart.support.StandardServletMultipartResolver`\n- 该`bean`用来解析`multipart/form-data`格式的数据\n\n11. **HttpEncodingAutoConfiguration**\n\n- `POST`请求参数如果有中文，无需特殊设置，这是因为`Spring Boot`已经配置了 `org.springframework.boot.web.servlet.filter.OrderedCharacterEncodingFilter`\n- 对应配置`server.servlet.encoding.charset=UTF-8`，默认就是`UTF-8`\n- 当然，它只影响非`json`格式的数据\n\n## 自定义自动配置类\n\n`springboot`的`EnableAutoConfiguration`原理也是基于`@Import`注解，只是读取的类型不一样，我们进入\n\n`EnableAutoConfiguration`中：\n\n```Java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import({AutoConfigurationImportSelector.class})\npublic @interface EnableAutoConfiguration {\n    String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n\n    Class<?>[] exclude() default {};\n\n    String[] excludeName() default {};\n}\n```\n\n进入`@Import()`注解中的类`AutoConfigurationImportSelector`：\n\n```Java\npublic class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {\n\n    public String[] selectImports(AnnotationMetadata annotationMetadata) {\n        if (!this.isEnabled(annotationMetadata)) {\n            return NO_IMPORTS;\n        } else {\n            AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata);\n            return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());\n        }\n    }\n\n}\n```\n\n进入`getAutoConfigurationEntry()`方法：\n\n```Java\nprotected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {\n    if (!this.isEnabled(annotationMetadata)) {\n        return EMPTY_ENTRY;\n    } else {\n        AnnotationAttributes attributes = this.getAttributes(annotationMetadata);\n        List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);\n        configurations = this.removeDuplicates(configurations);\n        Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);\n        this.checkExcludedClasses(configurations, exclusions);\n        configurations.removeAll(exclusions);\n        configurations = this.getConfigurationClassFilter().filter(configurations);\n        this.fireAutoConfigurationImportEvents(configurations, exclusions);\n        return new AutoConfigurationEntry(configurations, exclusions);\n    }\n}\n```\n\n再进入`getCandidateConfigurations()`方法：\n\n```Java\nprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());\n    Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\");\n    return configurations;\n}\n```\n\n这个方法调用了`SpringFactoriesLoader`的`loadFactoryNames()`方法，第一个参数为加载类型，我们进入`getSpringFactoriesLoaderFactoryClass()`方法：\n\n```Java\nprotected Class<?> getSpringFactoriesLoaderFactoryClass() {\n    return EnableAutoConfiguration.class;\n}\n```\n\n返回的是一个`EnableAutoConfiguration`类型。\n\n因此我们只需要在配置中的键更改为`org.springframework.boot.autoconfigure.EnableAutoConfiguration`即可：\n\n```Properties\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.itheima.a41.A41_2.AutoConfiguration1,\\\ncom.itheima.a41.A41_2.AutoConfiguration2\n```\n\n再使用`@EnableAutoConfiguration`即可。\n\n```Java\npublic class A41_2 {\n\n    @SuppressWarnings(\"all\")\n    public static void main(String[] args) throws IOException {\n        AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext();\n        StandardEnvironment env = new StandardEnvironment();\n        env.getPropertySources().addLast(new SimpleCommandLinePropertySource(\n                \"--spring.datasource.url=jdbc:mysql://localhost:3306/secondhandtradingplatform\",\n                \"--spring.datasource.username=root\",\n                \"--spring.datasource.password=2001\"\n        ));\n        context.setEnvironment(env);\n        context.registerBean(\"config\", Config.class);\n        context.refresh();\n\n        for (String name : context.getBeanDefinitionNames()) {\n            String resourceDescription = context.getBeanDefinition(name).getResourceDescription();\n            if (resourceDescription != null)\n                System.out.println(name + \" 来源:\" + resourceDescription);\n        }\n        context.close();\n    }\n\n    @Configuration // 本项目的配置类\n    @EnableAutoConfiguration\n    static class Config {\n        @Bean\n        public TomcatServletWebServerFactory tomcatServletWebServerFactory() {\n            return new TomcatServletWebServerFactory();\n        }\n    }\n\n    static class MyImportSelector implements DeferredImportSelector {\n        @Override\n        public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n            return SpringFactoriesLoader.loadFactoryNames(MyImportSelector.class, null).toArray(new String[0]);\n        }\n    }\n\n    @Configuration // 第三方的配置类\n    static class AutoConfiguration1 {\n        @Bean\n        public Bean1 bean1() {\n            return new Bean1();\n        }\n    }\n\n    @Configuration // 第三方的配置类\n    static class AutoConfiguration2 {\n        @Bean\n        public Bean2 bean2() {\n            return new Bean2();\n        }\n    }\n\n    static class Bean1 {\n\n    }\n    static class Bean2 {\n\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nbean1 来源:class path resource [com/itheima/a41/A41_2$AutoConfiguration1.class]\nbean2 来源:class path resource [com/itheima/a41/A41_2$AutoConfiguration2.class]\n```\n\n第三方的配置也已经生效。\n\n# **条件装配底层**\n\n`@Conditional()`注解是`spring`提供的注入`Bean`时的条件，我们来看看它的原理。`@Conditional()`注解本身没有判断的逻辑，判断逻辑是实现了`Condition`接口的类。\n\n我们自定义一个实现了`Condition`接口的类：\n\n```Java\npublic class A42_1 {\n\n    @SuppressWarnings(\"all\")\n    public static void main(String[] args) throws IOException {\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"config\", Config.class);\n        context.registerBean(ConfigurationClassPostProcessor.class);\n        context.refresh();\n\n        for (String name : context.getBeanDefinitionNames()) {\n            System.out.println(name);\n        }\n    }\n\n    @Configuration // 本项目的配置类\n    @Import(MyImportSelector.class)\n    static class Config {\n    }\n\n    static class MyImportSelector implements DeferredImportSelector {\n        @Override\n        public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n            return new String[]{AutoConfiguration1.class.getName(), AutoConfiguration2.class.getName()};\n        }\n    }\n\n    static class MyCondition1 implements Condition { // 存在 Druid 依赖\n        @Override\n        public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n            return ClassUtils.isPresent(\"com.alibaba.druid.pool.DruidDataSource\", null);\n        }\n    }\n\n    static class MyCondition2 implements Condition { // 不存在 Druid 依赖\n        @Override\n        public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n            return !ClassUtils.isPresent(\"com.alibaba.druid.pool.DruidDataSource\", null);\n        }\n    }\n\n    @Configuration // 第三方的配置类\n    @Conditional(MyCondition1.class)\n    static class AutoConfiguration1 {\n        @Bean\n        public Bean1 bean1() {\n            return new Bean1();\n        }\n    }\n\n    @Configuration // 第三方的配置类\n    @Conditional(MyCondition2.class)\n    static class AutoConfiguration2 {\n        @Bean\n        public Bean2 bean2() {\n            return new Bean2();\n        }\n    }\n\n    static class Bean1 {\n\n    }\n\n    static class Bean2 {\n\n    }\n}\n```\n\n`MyCondition1`的逻辑是只有`com.alibaba.druid.pool.DruidDataSource`存在才注入`Bean`，`MyCondition2`的逻辑是只有`com.alibaba.druid.pool.DruidDataSource`不存在才注入`Bean`。\n\n以上代码有几个缺点：\n\n1. 判断的类型写死在了代码中，我们更希望能作为参数传入\n2. 相似的逻辑写了两套，我们希望能统一成一套\n\n其实`Spring`中的条件注解例如`@ConditionalOnProperty`组合了`@Conditional()`注解，实现了一些扩展功能。\n\n```Java\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Documented\n@Conditional({OnPropertyCondition.class})\npublic @interface ConditionalOnProperty {\n    String[] value() default {};\n\n    String prefix() default \"\";\n\n    String[] name() default {};\n\n    String havingValue() default \"\";\n\n    boolean matchIfMissing() default false;\n}\n```\n\n我们可以自定义注解组合`@Conditional()`注解更优雅地实现：\n\n```Java\npublic class A42_2 {\n\n    @SuppressWarnings(\"all\")\n    public static void main(String[] args) throws IOException {\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"config\", Config.class);\n        context.registerBean(ConfigurationClassPostProcessor.class);\n        context.refresh();\n\n        for (String name : context.getBeanDefinitionNames()) {\n            System.out.println(name);\n        }\n    }\n\n    @Configuration // 本项目的配置类\n    @Import(MyImportSelector.class)\n    static class Config {\n    }\n\n    static class MyImportSelector implements DeferredImportSelector {\n        @Override\n        public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n            return new String[]{AutoConfiguration1.class.getName(), AutoConfiguration2.class.getName()};\n        }\n    }\n\n    static class MyCondition implements Condition { // 存在 Druid 依赖\n        @Override\n        public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n            Map<String, Object> attributes = metadata.getAnnotationAttributes(ConditionalOnClass.class.getName());\n            String className = attributes.get(\"className\").toString();\n            boolean exists = (boolean) attributes.get(\"exists\");\n            boolean present = ClassUtils.isPresent(className, null);\n            return exists ? present : !present;\n        }\n    }\n\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target({ElementType.METHOD, ElementType.TYPE})\n    @Conditional(MyCondition.class)\n    @interface ConditionalOnClass {\n        boolean exists(); // true 判断存在 false 判断不存在\n\n        String className(); // 要判断的类名\n    }\n\n    @Configuration // 第三方的配置类\n    @ConditionalOnClass(className = \"com.alibaba.druid.pool.DruidDataSource\", exists = false)\n    static class AutoConfiguration1 {\n        @Bean\n        public Bean1 bean1() {\n            return new Bean1();\n        }\n    }\n\n    @Configuration // 第三方的配置类\n    @ConditionalOnClass(className = \"com.alibaba.druid.pool.DruidDataSource\", exists = true)\n    static class AutoConfiguration2 {\n        @Bean\n        public Bean2 bean2() {\n            return new Bean2();\n        }\n    }\n\n    static class Bean1 {\n\n    }\n\n    static class Bean2 {\n\n    }\n}\n```\n\n以上代码就是通过注解传参地方式优雅地实现了条件判断。\n","tags":["spring"],"categories":["原理探究"]},{"title":"Spring高级45讲【第四章】：WEB","url":"/2023/04/15/Spring高级45讲【第四章】：WEB.html","content":"\n# DispatcherServlet及其重要组件\n\n## DispatcherServlet初始化\n\n我们使用可支持内嵌web服务器的容器实现`AnnotationConfigServletWebServerApplicationContext`，这个容器不仅支持内嵌web服务器，也支持注解配置。\n\n演示代码：\n\n```Java\npublic class A20 {\n    private static final Logger log = LoggerFactory.getLogger(A20.class);\n\n    public static void main(String[] args) throws Exception {\n        AnnotationConfigServletWebServerApplicationContext context =\n                new AnnotationConfigServletWebServerApplicationContext(WebConfig.class);\n    }\n}\n\n@Configuration\n@ComponentScan\npublic class WebConfig {\n    \n    @Bean\n    public TomcatServletWebServerFactory tomcatServletWebServerFactory() {\n        return new TomcatServletWebServerFactory();\n    }\n\n    @Bean\n    public DispatcherServlet dispatcherServlet() {\n        return new DispatcherServlet();\n    }\n\n    @Bean\n    public DispatcherServletRegistrationBean dispatcherServletRegistrationBean() {\n        return new DispatcherServletRegistrationBean(dispatcherServlet, \"/\");\n    }\n\n}\n```\n\n如果需要支持内嵌web容器的功能，配置类中有三项是必须配置的：\n\n1. 内嵌的`web`容器工厂，例如`tomcat`、`jetty`\n2. `DispatcherServlet`，负责拦截请求\n3. 注册器，注册`DispatcherServlet`,`Spring MVC`的入口\n\n运行启动类，查看控制台：\n\n```Plain\n[INFO ] 20:48:27.603 [main] o.s.b.w.e.tomcat.TomcatWebServer    - Tomcat initialized with port(s): 8080 (http) \n4月 02, 2023 8:48:27 下午 org.apache.coyote.AbstractProtocol init\n信息: Initializing ProtocolHandler [\"http-nio-8080\"]\n4月 02, 2023 8:48:27 下午 org.apache.catalina.core.StandardService startInternal\n信息: Starting service [Tomcat]\n4月 02, 2023 8:48:27 下午 org.apache.catalina.core.StandardEngine startInternal\n信息: Starting Servlet engine: [Apache Tomcat/9.0.53]\n4月 02, 2023 8:48:27 下午 org.apache.catalina.core.ApplicationContext log\n信息: Initializing Spring embedded WebApplicationContext\n[INFO ] 20:48:27.805 [main] o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 856 ms \n4月 02, 2023 8:48:27 下午 org.apache.coyote.AbstractProtocol start\n信息: Starting ProtocolHandler [\"http-nio-8080\"]\n[INFO ] 20:48:27.959 [main] o.s.b.w.e.tomcat.TomcatWebServer    - Tomcat started on port(s): 8080 (http) with context path ''\n```\n\n我们发现`tomcat`容器和`spring`容器都已经初始化完毕。\n\n`DispatcherServlet`是由`spring`容器创建的，但是它的初始化是由tomcat来管理的，当用户首次访问tomcat服务器时，将会初始化`DispatcherServlet`。\n\n清理一下控制台，访问`tomcat`服务器，查看打印日志：\n\n```Plain\n[INFO ] 20:55:07.911 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - Initializing Servlet 'dispatcherServlet' \n[TRACE] 20:55:07.912 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - No MultipartResolver 'multipartResolver' declared \n[TRACE] 20:55:07.916 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - No LocaleResolver 'localeResolver': using default [AcceptHeaderLocaleResolver] \n[TRACE] 20:55:07.917 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - No ThemeResolver 'themeResolver': using default [FixedThemeResolver] \n[TRACE] 20:55:08.243 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - No HandlerMappings declared for servlet 'dispatcherServlet': using default strategies from DispatcherServlet.properties \n[TRACE] 20:55:08.303 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - No HandlerAdapters declared for servlet 'dispatcherServlet': using default strategies from DispatcherServlet.properties \n[TRACE] 20:55:08.312 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - No HandlerExceptionResolvers declared in servlet 'dispatcherServlet': using default strategies from DispatcherServlet.properties \n[TRACE] 20:55:08.314 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - No RequestToViewNameTranslator 'viewNameTranslator': using default [DefaultRequestToViewNameTranslator] \n[TRACE] 20:55:08.326 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - No ViewResolvers declared for servlet 'dispatcherServlet': using default strategies from DispatcherServlet.properties \n[TRACE] 20:55:08.328 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - No FlashMapManager 'flashMapManager': using default [SessionFlashMapManager] \n[DEBUG] 20:55:08.329 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - enableLoggingRequestDetails='false': request parameters and headers will be masked to prevent unsafe logging of potentially sensitive data \n[INFO ] 20:55:08.329 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - Completed initialization in 418 ms \n[TRACE] 20:55:08.339 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - GET \"/\", parameters={}, headers={masked} in DispatcherServlet 'dispatcherServlet' \n[WARN ] 20:55:08.344 [http-nio-8080-exec-1] o.s.web.servlet.PageNotFound        - No mapping for GET / \n[DEBUG] 20:55:08.346 [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet   - Completed 404 NOT_FOUND, headers={} \n[TRACE] 20:55:08.771 [http-nio-8080-exec-2] o.s.web.servlet.DispatcherServlet   - GET \"/favicon.ico\", parameters={}, headers={masked} in DispatcherServlet 'dispatcherServlet' \n[WARN ] 20:55:08.772 [http-nio-8080-exec-2] o.s.web.servlet.PageNotFound        - No mapping for GET /favicon.ico \n[DEBUG] 20:55:08.772 [http-nio-8080-exec-2] o.s.web.servlet.DispatcherServlet   - Completed 404 NOT_FOUND, headers={} \n```\n\n我们发现，第一行正在初始化`DispatcherServlet`，第2~10行是初始化组件，第12行表示已经完成了`DispatcherServlet`的初始化。\n\n我们可以将断点打在`DispatcherServlet`中的`onRefresh()`方法上，启动服务器，发现一开始并没有停在断点处，当我们`tomcat`服务器：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%91%EF%BC%9AWEB/1.png)\n\n查看调用链，我们发现`DispatcherServlet`的`onRefresh()`方法是在执行`Servlet`的`init()`方法时调用的，因此`DispatcherServlet`走的是`Servlet`的初始化流程。\n\n目前是在首次访问tomcat服务器时，`DispatcherServlet`才会去初始化，我们可以通过`DispatcherServletRegistrationBean`的`setLoadOnStartup()`方法去更改。`setLoadOnStartup()`方法的默认值为-1，即首次访问tomcat服务器时才初始化`DispatcherServlet`，如果值大于0，则启动时就会初始化`DispatcherServlet`。如果有多个`Servlet`，此值代表初始化的优先级，值越小优先级越高。\n\n修改`setLoadOnStartup()`方法的值：\n\n```Java\n@Bean\npublic DispatcherServletRegistrationBean dispatcherServletRegistrationBean(DispatcherServlet dispatcherServlet) {\n    DispatcherServletRegistrationBean registrationBean = new DispatcherServletRegistrationBean(dispatcherServlet, \"/\");\n    registrationBean.setLoadOnStartup(1);\n    return registrationBean;\n}\n```\n\n重新运行启动类，查看控制台：\n\n```Plain\n[INFO ] 21:09:59.471 [main] o.s.b.w.e.tomcat.TomcatWebServer    - Tomcat initialized with port(s): 8080 (http) \n4月 02, 2023 9:09:59 下午 org.apache.coyote.AbstractProtocol init\n信息: Initializing ProtocolHandler [\"http-nio-8080\"]\n4月 02, 2023 9:09:59 下午 org.apache.catalina.core.StandardService startInternal\n信息: Starting service [Tomcat]\n4月 02, 2023 9:09:59 下午 org.apache.catalina.core.StandardEngine startInternal\n信息: Starting Servlet engine: [Apache Tomcat/9.0.53]\n4月 02, 2023 9:09:59 下午 org.apache.catalina.core.ApplicationContext log\n信息: Initializing Spring embedded WebApplicationContext\n[INFO ] 21:09:59.686 [main] o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 888 ms \n4月 02, 2023 9:09:59 下午 org.apache.coyote.AbstractProtocol start\n信息: Starting ProtocolHandler [\"http-nio-8080\"]\n4月 02, 2023 9:09:59 下午 org.apache.catalina.core.ApplicationContext log\n信息: Initializing Spring DispatcherServlet 'dispatcherServlet'\n[INFO ] 21:09:59.838 [main] o.s.web.servlet.DispatcherServlet   - Initializing Servlet 'dispatcherServlet' \n[TRACE] 21:09:59.838 [main] o.s.web.servlet.DispatcherServlet   - No MultipartResolver 'multipartResolver' declared \n[TRACE] 21:09:59.841 [main] o.s.web.servlet.DispatcherServlet   - No LocaleResolver 'localeResolver': using default [AcceptHeaderLocaleResolver] \n[TRACE] 21:09:59.843 [main] o.s.web.servlet.DispatcherServlet   - No ThemeResolver 'themeResolver': using default [FixedThemeResolver] \n[TRACE] 21:10:00.337 [main] o.s.web.servlet.DispatcherServlet   - No HandlerMappings declared for servlet 'dispatcherServlet': using default strategies from DispatcherServlet.properties \n[TRACE] 21:10:00.393 [main] o.s.web.servlet.DispatcherServlet   - No HandlerAdapters declared for servlet 'dispatcherServlet': using default strategies from DispatcherServlet.properties \n[TRACE] 21:10:00.402 [main] o.s.web.servlet.DispatcherServlet   - No HandlerExceptionResolvers declared in servlet 'dispatcherServlet': using default strategies from DispatcherServlet.properties \n[TRACE] 21:10:00.403 [main] o.s.web.servlet.DispatcherServlet   - No RequestToViewNameTranslator 'viewNameTranslator': using default [DefaultRequestToViewNameTranslator] \n[TRACE] 21:10:00.410 [main] o.s.web.servlet.DispatcherServlet   - No ViewResolvers declared for servlet 'dispatcherServlet': using default strategies from DispatcherServlet.properties \n[TRACE] 21:10:00.412 [main] o.s.web.servlet.DispatcherServlet   - No FlashMapManager 'flashMapManager': using default [SessionFlashMapManager] \n[DEBUG] 21:10:00.412 [main] o.s.web.servlet.DispatcherServlet   - enableLoggingRequestDetails='false': request parameters and headers will be masked to prevent unsafe logging of potentially sensitive data \n[INFO ] 21:10:00.412 [main] o.s.web.servlet.DispatcherServlet   - Completed initialization in 574 ms \n[INFO ] 21:10:00.414 [main] o.s.b.w.e.tomcat.TomcatWebServer    - Tomcat started on port(s): 8080 (http) with context path '' \n```\n\n我们发现容器启动时，`DispatcherServlet`就已经初始化完毕。\n\n在实际情况下，一般将配置放在配置文件中，而不是写入代码，因此我们将配置抽取成配置文件。我们可以使用`@PropertySource`注解来读取类路径下的配置文件：\n\n```Java\n@PropertySource(\"classpath:application.properties\")\n```\n\n`@EnableConfigurationProperties`注解提供将配置进行批量绑定的功能：\n\n```Java\n@EnableConfigurationProperties({WebMvcProperties.class, ServerProperties.class})\n```\n\n例如`WebMvcProperties.class`可以绑定以`spring.mvc`的配置项，查看`WebMvcProperties.class`源码：\n\n```Java\n@ConfigurationProperties(\n    prefix = \"spring.mvc\"\n)\npublic class WebMvcProperties {\n    //...\n}\n```\n\n绑定的对象会作为Bean注入到容器中，我们直接使用即可，更改后的`WebConfig`类如下：\n\n```Java\n@Configuration\n@ComponentScan\n@PropertySource(\"classpath:application.properties\")\n@EnableConfigurationProperties({WebMvcProperties.class, ServerProperties.class})\npublic class WebConfig {\n\n    // ⬅️内嵌 web 容器工厂\n    @Bean\n    public TomcatServletWebServerFactory tomcatServletWebServerFactory(ServerProperties serverProperties) {\n        return new TomcatServletWebServerFactory(serverProperties.getPort());\n    }\n\n    // ⬅️创建 DispatcherServlet\n    @Bean\n    public DispatcherServlet dispatcherServlet() {\n        return new DispatcherServlet();\n    }\n\n    // ⬅️注册 DispatcherServlet, Spring MVC 的入口\n    @Bean\n    public DispatcherServletRegistrationBean dispatcherServletRegistrationBean(\n            DispatcherServlet dispatcherServlet, WebMvcProperties webMvcProperties) {\n        DispatcherServletRegistrationBean registrationBean = new DispatcherServletRegistrationBean(dispatcherServlet, \"/\");\n        registrationBean.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());\n        return registrationBean;\n    }\n\n}\n```\n\n重新运行启动类，查看控制台：\n\n```Plain\n[INFO ] 21:21:23.218 [main] o.s.b.w.e.tomcat.TomcatWebServer    - Tomcat initialized with port(s): 8080 (http) \n4月 02, 2023 9:21:23 下午 org.apache.coyote.AbstractProtocol init\n信息: Initializing ProtocolHandler [\"http-nio-8080\"]\n4月 02, 2023 9:21:23 下午 org.apache.catalina.core.StandardService startInternal\n信息: Starting service [Tomcat]\n4月 02, 2023 9:21:23 下午 org.apache.catalina.core.StandardEngine startInternal\n信息: Starting Servlet engine: [Apache Tomcat/9.0.53]\n4月 02, 2023 9:21:23 下午 org.apache.catalina.core.ApplicationContext log\n信息: Initializing Spring embedded WebApplicationContext\n[INFO ] 21:21:23.412 [main] o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 1279 ms \n4月 02, 2023 9:21:23 下午 org.apache.coyote.AbstractProtocol start\n信息: Starting ProtocolHandler [\"http-nio-8080\"]\n4月 02, 2023 9:21:23 下午 org.apache.catalina.core.ApplicationContext log\n信息: Initializing Spring DispatcherServlet 'dispatcherServlet'\n[INFO ] 21:21:23.552 [main] o.s.web.servlet.DispatcherServlet   - Initializing Servlet 'dispatcherServlet' \n[TRACE] 21:21:23.553 [main] o.s.web.servlet.DispatcherServlet   - No MultipartResolver 'multipartResolver' declared \n[TRACE] 21:21:23.556 [main] o.s.web.servlet.DispatcherServlet   - No LocaleResolver 'localeResolver': using default [AcceptHeaderLocaleResolver] \n[TRACE] 21:21:23.558 [main] o.s.web.servlet.DispatcherServlet   - No ThemeResolver 'themeResolver': using default [FixedThemeResolver] \n[TRACE] 21:21:23.894 [main] o.s.web.servlet.DispatcherServlet   - No HandlerMappings declared for servlet 'dispatcherServlet': using default strategies from DispatcherServlet.properties \n[TRACE] 21:21:23.944 [main] o.s.web.servlet.DispatcherServlet   - No HandlerAdapters declared for servlet 'dispatcherServlet': using default strategies from DispatcherServlet.properties \n[TRACE] 21:21:23.955 [main] o.s.web.servlet.DispatcherServlet   - No HandlerExceptionResolvers declared in servlet 'dispatcherServlet': using default strategies from DispatcherServlet.properties \n[TRACE] 21:21:23.957 [main] o.s.web.servlet.DispatcherServlet   - No RequestToViewNameTranslator 'viewNameTranslator': using default [DefaultRequestToViewNameTranslator] \n[TRACE] 21:21:23.965 [main] o.s.web.servlet.DispatcherServlet   - No ViewResolvers declared for servlet 'dispatcherServlet': using default strategies from DispatcherServlet.properties \n[TRACE] 21:21:23.968 [main] o.s.web.servlet.DispatcherServlet   - No FlashMapManager 'flashMapManager': using default [SessionFlashMapManager] \n[DEBUG] 21:21:23.968 [main] o.s.web.servlet.DispatcherServlet   - enableLoggingRequestDetails='false': request parameters and headers will be masked to prevent unsafe logging of potentially sensitive data \n[INFO ] 21:21:23.968 [main] o.s.web.servlet.DispatcherServlet   - Completed initialization in 416 ms \n[INFO ] 21:21:23.969 [main] o.s.b.w.e.tomcat.TomcatWebServer    - Tomcat started on port(s): 8080 (http) with context path '' \n```\n\n发现我们的配置文件已经生效。\n\n## DispatcherServlet初始化过程\n\n`DispatcherServlet`初始化过程主要在`onRefresh()`方法中：\n\n```Java\nprotected void onRefresh(ApplicationContext context) {\n    this.initStrategies(context);\n}\n```\n\n进入initStrategies()方法：\n\n```Java\n// 此方法初始化了多种组件\nprotected void initStrategies(ApplicationContext context) {\n    // 初始化文件解析器\n    this.initMultipartResolver(context);\n    // 初始化本地化信息，初始化语言、地区\n    this.initLocaleResolver(context);\n    this.initThemeResolver(context);\n    // 初始化路径映射器\n    this.initHandlerMappings(context);\n    // 初始化控制器适配器\n    this.initHandlerAdapters(context);\n    // 初始化异常解析器\n    this.initHandlerExceptionResolvers(context);\n    this.initRequestToViewNameTranslator(context);\n    this.initViewResolvers(context);\n    this.initFlashMapManager(context);\n}\n```\n\n1. **RequestMappingHandlerMapping**\n\n`RequestMappingHandlerMapping`的主要作用是建立请求路径与控制器的映射关系，它的主要工作流程如下：\n\n1. 扫描启动类下所有带有`@Controller`注解的类\n2. 解析类中带有`@GetMapping`、`@PostMapping`等注解的方法并建立请求路径与方法的映射。\n\n由于`RequestMappingHandlerMapping`是由`tomcat`服务器管理的，并没有加入`spring`容器中，为了方便演示，我们添加自己创建的`RequestMappingHandlerMapping`，在`WebConfig`类中添加`Bean`：\n\n```Java\n@Bean\npublic RequestMappingHandlerMapping requestMappingHandlerMapping() {\n    return new RequestMappingHandlerMapping();\n}\n```\n\n添加`Controller1`类：\n\n```Java\n@Controller\npublic class Controller1 {\n\n    private static final Logger log = LoggerFactory.getLogger(Controller1.class);\n\n    @GetMapping(\"/test1\")\n    public ModelAndView test1() throws Exception {\n        log.debug(\"test1()\");\n        return null;\n    }\n\n    @PostMapping(\"/test2\")\n    public ModelAndView test2(@RequestParam(\"name\") String name) {\n        log.debug(\"test2({})\", name);\n        return null;\n    }\n\n    @PutMapping(\"/test3\")\n    public ModelAndView test3(@Token String token) {\n        log.debug(\"test3({})\", token);\n        return null;\n    }\n\n    @RequestMapping(\"/test4\")\n//    @ResponseBody\n    @Yml\n    public User test4() {\n        log.debug(\"test4\");\n        return new User(\"张三\", 18);\n    }\n\n    public static class User {\n        private String name;\n        private int age;\n\n        public User(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public void setAge(int age) {\n            this.age = age;\n        }\n    }\n\n    public static void main(String[] args) {\n        String str = new Yaml().dump(new User(\"张三\", 18));\n        System.out.println(str);\n    }\n}\n```\n\n在启动类中获取`RequestMappingHandlerMapping`实例，并打印映射：\n\n```Java\n// 作用 解析 @RequestMapping 以及派生注解，生成路径与控制器方法的映射关系, 在初始化时就生成\nRequestMappingHandlerMapping handlerMapping = context.getBean(RequestMappingHandlerMapping.class);\n\n// 获取映射结果 RequestMappingInfo为请求方法与路径信息，HandlerMethod为映射的方法\nMap<RequestMappingInfo, HandlerMethod> handlerMethods = handlerMapping.getHandlerMethods();\nhandlerMethods.forEach((k, v) -> {\n    System.out.println(k + \"=\" + v);\n});\n```\n\n运行启动类，查看控制台：\n\n```Plain\n{GET [/test1]}=com.itheima.a20.Controller1#test1()\n{PUT [/test3]}=com.itheima.a20.Controller1#test3(String)\n{ [/test4]}=com.itheima.a20.Controller1#test4()\n{POST [/test2]}=com.itheima.a20.Controller1#test2(String)\n```\n\n发现所有的映射都已经被打印出来。\n\n我们可以模拟一个请求，并打印其信息：\n\n```Java\n// 返回值是一个执行器链，包含拦截器\nHandlerExecutionChain chain = handlerMapping.getHandler(new MockHttpServletRequest(\"GET\", \"/test4\"));\nSystem.out.println(chain);\n```\n\n控制台输出：\n\n```Plain\nHandlerExecutionChain with [com.itheima.a20.Controller1#test4()] and 0 interceptors\n```\n\n我们可以发现最终执行地方法逻辑为`com.itheima.a20.Controller1#test4()`，并且拦截器数量为0。\n\n2. **RequestMappingHandlerAdapter**\n\n`RequestMappingHandlerAdapter`的主要作用是调用控制器的方法。\n\n由于`RequestMappingHandlerAdapter`是由`tomcat`服务器管理的，并没有加入`spring`容器中，为了方便演示，我们添加自己创建的`RequestMappingHandlerAdapter`，在`WebConfig`类中添加`Bean`：\n\n```Java\n@Bean\npublic RequestMappingHandlerAdapter requestMappingHandlerAdapter() {\n    return new RequestMappingHandlerAdapter();\n}\n```\n\n由于`RequestMappingHandlerAdapter`中的重要方法`invokeHandlerMethod()`被`protected`关键字修饰，不能调用，因此我们创建一个子类去更改它的访问修饰符：\n\n```Java\npublic class MyRequestMappingHandlerAdapter extends RequestMappingHandlerAdapter {\n    @Override\n    public ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n        return super.invokeHandlerMethod(request, response, handlerMethod);\n    }\n}\n```\n\n修改`WebConfig`类中`RequestMappingHandlerAdapter`类型的`Bean`注入：\n\n```Java\n@Bean\npublic MyRequestMappingHandlerAdapter requestMappingHandlerAdapter() {\n    return new MyRequestMappingHandlerAdapter();\n}\n```\n\n在启动类中添加测试代码：\n\n```Java\nMockHttpServletRequest request = new MockHttpServletRequest(\"POST\", \"/test2\");\nrequest.setParameter(\"name\", \"张三\");\nMockHttpServletResponse response = new MockHttpServletResponse();\nHandlerExecutionChain chain = handlerMapping.getHandler(request);\nSystem.out.println(chain);\n\nSystem.out.println(\">>>>>>>>>>>>>>>>>>>>>\");\n// HandlerAdapter 作用: 调用控制器方法\nMyRequestMappingHandlerAdapter handlerAdapter = context.getBean(MyRequestMappingHandlerAdapter.class);\nhandlerAdapter.invokeHandlerMethod(request, response, (HandlerMethod) chain.getHandler());\n```\n\n运行启动类，查看控制台：\n\n```Java\nHandlerExecutionChain with [com.itheima.a20.Controller1#test2(String)] and 0 interceptors\n>>>>>>>>>>>>>>>>>>>>>\n[DEBUG] 22:07:38.394 [main] com.itheima.a20.Controller1         - test2(张三) \n```\n\n我们发现`RequestMappingHandlerAdapter`正常调用了方法，并且成功解析了参数，说明`@RequestParam`成功被解析了，实际上`@RequestParam`注解的解析是由`RequestMappingHandlerAdapter`中的其他组件来实现的。\n\n实际上`RequestMappingHandlerAdapter`中有很多的参数解析器，解析`@RequestParam`、`@RequestBody`等注解，我们可以打印一下：\n\n```Java\nfor (HandlerMethodArgumentResolver resolver : handlerAdapter.getArgumentResolvers()) {\n    System.out.println(resolver);\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\norg.springframework.web.method.annotation.RequestParamMethodArgumentResolver@58516c91\norg.springframework.web.method.annotation.RequestParamMapMethodArgumentResolver@7c129ef6\norg.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver@42d73c61\norg.springframework.web.servlet.mvc.method.annotation.PathVariableMapMethodArgumentResolver@5a8cbffe\norg.springframework.web.servlet.mvc.method.annotation.MatrixVariableMethodArgumentResolver@96a75da\norg.springframework.web.servlet.mvc.method.annotation.MatrixVariableMapMethodArgumentResolver@61e7bf2f\norg.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor@1a28b346\norg.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor@25e49cb2\norg.springframework.web.servlet.mvc.method.annotation.RequestPartMethodArgumentResolver@7f7af971\norg.springframework.web.method.annotation.RequestHeaderMethodArgumentResolver@23382f76\norg.springframework.web.method.annotation.RequestHeaderMapMethodArgumentResolver@7c551ad4\norg.springframework.web.servlet.mvc.method.annotation.ServletCookieValueMethodArgumentResolver@7d5508e0\norg.springframework.web.method.annotation.ExpressionValueMethodArgumentResolver@554cd74a\norg.springframework.web.servlet.mvc.method.annotation.SessionAttributeMethodArgumentResolver@37ed010a\norg.springframework.web.servlet.mvc.method.annotation.RequestAttributeMethodArgumentResolver@633a2e99\norg.springframework.web.servlet.mvc.method.annotation.ServletRequestMethodArgumentResolver@367d2816\norg.springframework.web.servlet.mvc.method.annotation.ServletResponseMethodArgumentResolver@5b84f14\norg.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor@5a82ebf8\norg.springframework.web.servlet.mvc.method.annotation.RedirectAttributesMethodArgumentResolver@68fe48d7\norg.springframework.web.method.annotation.ModelMethodProcessor@379ce046\norg.springframework.web.method.annotation.MapMethodProcessor@701bc94e\norg.springframework.web.method.annotation.ErrorsMethodArgumentResolver@3d8b319e\norg.springframework.web.method.annotation.SessionStatusMethodArgumentResolver@27a97e08\norg.springframework.web.servlet.mvc.method.annotation.UriComponentsBuilderMethodArgumentResolver@77e7246b\norg.springframework.web.servlet.mvc.method.annotation.PrincipalMethodArgumentResolver@5918c260\norg.springframework.web.method.annotation.RequestParamMethodArgumentResolver@3d7b1f1c\norg.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor@51ce6f85\n```\n\n我们可以发现有很多的参数解析器，其中就有解析`@RequestParam`注解的`RequestParamMethodArgumentResolver`。\n\n除了参数解析器，还有返回值处理器，用来解析不同类型的返回值，比如字符串、对象、`ModelAndView`...最终返回值会被统一转换为`ModelAndView`。我们可以打印一下返回值处理器：\n\n```Java\nfor (HandlerMethodReturnValueHandler handler : handlerAdapter.getReturnValueHandlers()) {\n    System.out.println(handler);\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\norg.springframework.web.servlet.mvc.method.annotation.ModelAndViewMethodReturnValueHandler@1f44ddab\norg.springframework.web.method.annotation.ModelMethodProcessor@5017e1\norg.springframework.web.servlet.mvc.method.annotation.ViewMethodReturnValueHandler@65b66b08\norg.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler@4726927c\norg.springframework.web.servlet.mvc.method.annotation.StreamingResponseBodyReturnValueHandler@7eb6b6b6\norg.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor@7ed9499e\norg.springframework.web.servlet.mvc.method.annotation.HttpHeadersReturnValueHandler@28e19366\norg.springframework.web.servlet.mvc.method.annotation.CallableMethodReturnValueHandler@5b275174\norg.springframework.web.servlet.mvc.method.annotation.DeferredResultMethodReturnValueHandler@10ef5fa0\norg.springframework.web.servlet.mvc.method.annotation.AsyncTaskMethodReturnValueHandler@244e619a\norg.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor@10acd6\norg.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor@61dde151\norg.springframework.web.servlet.mvc.method.annotation.ViewNameMethodReturnValueHandler@b25b095\norg.springframework.web.method.annotation.MapMethodProcessor@5cb042da\norg.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor@59c33386\n```\n\n**自定义参数解析器**\n\n在`Controller`中定义方法：\n\n```Java\n@PutMapping(\"/test3\")\npublic ModelAndView test3(@Token String token) {\n    log.debug(\"test3({})\", token);\n    return null;\n}\n```\n\n`@Token`是我们自定义的注解：\n\n```Java\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Token {\n}\n```\n\n实现自定义的`TokenArgumentResolver`，需要实现`HandlerMethodArgumentResolver`接口：\n\n```Java\npublic class TokenArgumentResolver implements HandlerMethodArgumentResolver {\n    \n    /**\n    * 是否支持某个参数，参数上是否有目标注解\n    */\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        Token token = parameter.getParameterAnnotation(Token.class);\n        return token != null;\n    }\n\n    /**\n    * 解析参数\n    */\n    @Override\n    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n        return webRequest.getHeader(\"token\");\n    }\n}\n```\n\n接下来需要将`TokenArgumentResolver`加入到`RequestMappingHandlerAdapter`中：\n\n```Java\n@Bean\npublic MyRequestMappingHandlerAdapter requestMappingHandlerAdapter() {\n    TokenArgumentResolver tokenArgumentResolver = new TokenArgumentResolver();\n    MyRequestMappingHandlerAdapter handlerAdapter = new MyRequestMappingHandlerAdapter();\n    handlerAdapter.setCustomArgumentResolvers(List.of(tokenArgumentResolver));\n    return handlerAdapter;\n}\n```\n\n模拟请求，进行测试：\n\n```Java\nMockHttpServletRequest request = new MockHttpServletRequest(\"PUT\", \"/test3\");\nrequest.setParameter(\"name\", \"张三\");\nrequest.addHeader(\"token\", \"某个令牌\");\nMockHttpServletResponse response = new MockHttpServletResponse();\nHandlerExecutionChain chain = handlerMapping.getHandler(request);\nSystem.out.println(chain);\n```\n\n运行启动类，查看控制台输出：\n\n```Plain\n[DEBUG] 11:03:10.307 [main] com.itheima.a20.Controller1         - test3(某个令牌) \n```\n\n发现能正常解析我们的`@Token`注解。\n\n**自定义返回值处理器**\n\n返回值处理器可以解析不同类型的返回值，比如字符串、对象、`ModelAndView`...除此之外还可以解析方法的注解，比如解析`@ResponseBody`。\n\n在`Controller`中定义方法：\n\n```Java\n@RequestMapping(\"/test4\")\n@Yml\npublic User test4() {\n    log.debug(\"test4\");\n    return new User(\"张三\", 18);\n}\n```\n\n`@Yml`是我们自定义的注解：\n\n```Java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Yml {\n}\n```\n\n`@Yml`注解将返回值转换为`Yml`格式，我们可以使用`org.yaml.snakeyaml.Yaml`工具类进行转换：\n\n```Java\npublic static class User {\n    private String name;\n    private int age;\n\n    public User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n\npublic static void main(String[] args) {\n    String str = new Yaml().dump(new User(\"张三\", 18));\n    System.out.println(str);\n}\n```\n\n控制台输出：\n\n```Plain\n!!com.itheima.a20.Controller1$User {age: 18, name: 张三}\n```\n\n实现自定义的`YmlReturnValueHandler`，需要实现`HandlerMethodReturnValueHandler`接口：\n\n```Java\npublic class YmlReturnValueHandler implements HandlerMethodReturnValueHandler {\n    \n    /**\n    * 是否支持某个参数，参数上是否有目标注解\n    */\n    @Override\n    public boolean supportsReturnType(MethodParameter returnType) {\n        Yml yml = returnType.getMethodAnnotation(Yml.class);\n        return yml != null;\n    }\n\n    /**\n    * 处理返回值\n    */\n    @Override\n    public void handleReturnValue(Object returnValue, MethodParameter returnType,\n                                  ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n        // 1. 转换返回结果为 yaml 字符串\n        String str = new Yaml().dump(returnValue);\n\n        // 2. 将 yaml 字符串写入响应\n        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n        response.setContentType(\"text/plain;charset=utf-8\");\n        response.getWriter().print(str);\n\n        // 3. 设置请求已经处理完毕\n        mavContainer.setRequestHandled(true);\n    }\n}\n```\n\n接下来需要将`YmlReturnValueHandler`加入到`RequestMappingHandlerAdapter`中：\n\n```Java\n@Bean\npublic MyRequestMappingHandlerAdapter requestMappingHandlerAdapter() {\n    TokenArgumentResolver tokenArgumentResolver = new TokenArgumentResolver();\n    YmlReturnValueHandler ymlReturnValueHandler = new YmlReturnValueHandler();\n    MyRequestMappingHandlerAdapter handlerAdapter = new MyRequestMappingHandlerAdapter();\n    handlerAdapter.setCustomArgumentResolvers(List.of(tokenArgumentResolver));\n    handlerAdapter.setCustomReturnValueHandlers(List.of(ymlReturnValueHandler));\n    return handlerAdapter;\n}\n```\n\n模拟请求，进行测试：\n\n```Java\nMockHttpServletRequest request = new MockHttpServletRequest(\"GET\", \"/test4\");\nMockHttpServletResponse response = new MockHttpServletResponse();\nHandlerExecutionChain chain = handlerMapping.getHandler(request);\n// HandlerAdapter 作用: 调用控制器方法\nMyRequestMappingHandlerAdapter handlerAdapter = context.getBean(MyRequestMappingHandlerAdapter.class);\nhandlerAdapter.invokeHandlerMethod(request, response, (HandlerMethod) chain.getHandler());\n// 检查响应\nbyte[] content = response.getContentAsByteArray();\nSystem.out.println(new String(content, StandardCharsets.UTF_8));\n```\n\n运行启动类，查看控制台输出：\n\n```Plain\n!!com.itheima.a20.Controller1$User {age: 18, name: 张三}\n```\n\n发现能正常解析我们的`@Yml`注解。\n\n# 参数解析器\n\n`RequestMappingHandlerAdapter`自带的参数解析器：\n\n```Plain\norg.springframework.web.method.annotation.RequestParamMethodArgumentResolver@abbc908\norg.springframework.web.method.annotation.RequestParamMapMethodArgumentResolver@44afefd5\norg.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver@9a7a808\norg.springframework.web.servlet.mvc.method.annotation.PathVariableMapMethodArgumentResolver@72209d93\norg.springframework.web.servlet.mvc.method.annotation.MatrixVariableMethodArgumentResolver@2687f956\norg.springframework.web.servlet.mvc.method.annotation.MatrixVariableMapMethodArgumentResolver@1ded7b14\norg.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor@29be7749\norg.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor@5f84abe8\norg.springframework.web.servlet.mvc.method.annotation.RequestPartMethodArgumentResolver@4650a407\norg.springframework.web.method.annotation.RequestHeaderMethodArgumentResolver@30135202\norg.springframework.web.method.annotation.RequestHeaderMapMethodArgumentResolver@6a4d7f76\norg.springframework.web.servlet.mvc.method.annotation.ServletCookieValueMethodArgumentResolver@10ec523c\norg.springframework.web.method.annotation.ExpressionValueMethodArgumentResolver@53dfacba\norg.springframework.web.servlet.mvc.method.annotation.SessionAttributeMethodArgumentResolver@79767781\norg.springframework.web.servlet.mvc.method.annotation.RequestAttributeMethodArgumentResolver@78411116\norg.springframework.web.servlet.mvc.method.annotation.ServletRequestMethodArgumentResolver@aced190\norg.springframework.web.servlet.mvc.method.annotation.ServletResponseMethodArgumentResolver@245a060f\norg.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor@6edaa77a\norg.springframework.web.servlet.mvc.method.annotation.RedirectAttributesMethodArgumentResolver@1e63d216\norg.springframework.web.method.annotation.ModelMethodProcessor@62ddd21b\norg.springframework.web.method.annotation.MapMethodProcessor@16c3ca31\norg.springframework.web.method.annotation.ErrorsMethodArgumentResolver@2d195ee4\norg.springframework.web.method.annotation.SessionStatusMethodArgumentResolver@2d6aca33\norg.springframework.web.servlet.mvc.method.annotation.UriComponentsBuilderMethodArgumentResolver@21ab988f\norg.springframework.web.servlet.mvc.method.annotation.PrincipalMethodArgumentResolver@29314cc9\norg.springframework.web.method.annotation.RequestParamMethodArgumentResolver@4e38d975\norg.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor@35f8a9d3\n```\n\n准备测试代码：\n\n```Java\npublic class A21 {\n\n    public static void main(String[] args) throws Exception {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);\n        DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\n        // 准备测试 Request\n        HttpServletRequest request = mockRequest();\n\n        // 要点1. 控制器方法被封装为 HandlerMethod\n        HandlerMethod handlerMethod = new HandlerMethod(new Controller(), Controller.class.getMethod(\"test\", String.class, String.class, int.class, String.class, MultipartFile.class, int.class, String.class, String.class, String.class, HttpServletRequest.class, User.class, User.class, User.class));\n\n        // 要点2. 准备对象绑定与类型转换\n        ServletRequestDataBinderFactory factory = new ServletRequestDataBinderFactory(null, null);\n\n        // 要点3. 准备 ModelAndViewContainer 用来存储中间 Model 结果\n        ModelAndViewContainer container = new ModelAndViewContainer();\n\n        // 要点4. 解析每个参数值\n        for (MethodParameter parameter : handlerMethod.getMethodParameters()) {\n            String annotation = Arrays.stream(parameter.getParameterAnnotations()).map(a -> a.annotationType().getSimpleName()).collect(Collectors.joining());\n            String str = annotation.equals(\"\") ? \"\" : \"@\" + annotation + \" \";\n            parameter.initParameterNameDiscovery(new DefaultParameterNameDiscoverer());\n            System.out.println(\"[\" + parameter.getParameterIndex() + \"] \" + str + parameter.getParameterType().getSimpleName() + \" \" + parameter.getParameterName());\n        }\n\n    }\n\n\n    private static HttpServletRequest mockRequest() {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setParameter(\"name1\", \"zhangsan\");\n        request.setParameter(\"name2\", \"lisi\");\n        request.addPart(new MockPart(\"file\", \"abc\", \"hello\".getBytes(StandardCharsets.UTF_8)));\n        Map<String, String> map = new AntPathMatcher().extractUriTemplateVariables(\"/test/{id}\", \"/test/123\");\n        request.setAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, map);\n        request.setContentType(\"application/json\");\n        request.setCookies(new Cookie(\"token\", \"123456\"));\n        request.setParameter(\"name\", \"张三\");\n        request.setParameter(\"age\", \"18\");\n        request.setContent(\"\"\"\n                    {\n                        \"name\":\"李四\",\n                        \"age\":20\n                    }\n                \"\"\".getBytes(StandardCharsets.UTF_8));\n\n        return new StandardServletMultipartResolver().resolveMultipart(request);\n    }\n\n\n    static class Controller {\n        public void test(\n                @RequestParam(\"name1\") String name1, // name1=张三\n                String name2,                        // name2=李四\n                @RequestParam(\"age\") int age,        // age=18\n                @RequestParam(name = \"home\", defaultValue = \"${JAVA_HOME}\") String home1, // spring 获取数据\n                @RequestParam(\"file\") MultipartFile file, // 上传文件\n                @PathVariable(\"id\") int id,               //  /test/124   /test/{id}\n                @RequestHeader(\"Content-Type\") String header,\n                @CookieValue(\"token\") String token,\n                @Value(\"${JAVA_HOME}\") String home2, // spring 获取数据  ${} #{}\n                HttpServletRequest request,          // request, response, session ...\n                @ModelAttribute(\"abc\") User user1,          // name=zhang&age=18\n                User user2,                          // name=zhang&age=18\n                @RequestBody User user3              // json\n        ) {\n        }\n    }\n\n    static class User {\n        private String name;\n        private int age;\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n\n        public void setAge(int age) {\n            this.age = age;\n        }\n\n        @Override\n        public String toString() {\n            return \"User{\" +\n                    \"name='\" + name + '\\'' +\n                    \", age=\" + age +\n                    '}';\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[0] @RequestParam String name1\n[1] String name2\n[2] @RequestParam int age\n[3] @RequestParam String home1\n[4] @RequestParam MultipartFile file\n[5] @PathVariable int id\n[6] @RequestHeader String header\n[7] @CookieValue String token\n[8] @Value String home2\n[9] HttpServletRequest request\n[10] @ModelAttribute User user1\n[11] User user2\n[12] @RequestBody User user3\n```\n\n我们已经能够拿到`Controller`中`HandlerMethod`的属性，例如注解、参数类型、参数名称等\n\n**RequestParamMethodArgumentResolver**\n\n我们添加一个`RequestParamMethodArgumentResolver`来解析`@RequestParam`注解：\n\n```Java\n// 第一个参数为BeanFactory、第二个参数为省略@RequestParam是否解析属性\nRequestParamMethodArgumentResolver resolver = new RequestParamMethodArgumentResolver(null, false);\n```\n\n调用它的方法解析数据：\n\n```Java\nif (resolver.supportsParameter(parameter)) {\n    // 支持此参数解析\n    Object v = resolver.resolveArgument(parameter, container, new ServletWebRequest(request), null);\n    System.out.println(\"[\" + parameter.getParameterIndex() + \"] \" + str + parameter.getParameterType().getSimpleName() + \" \" + parameter.getParameterName() + \"->\" + v);\n} else {\n    System.out.println(\"[\" + parameter.getParameterIndex() + \"] \" + str + parameter.getParameterType().getSimpleName() + \" \" + parameter.getParameterName());\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[0] @RequestParam String name1->zhangsan\n[1] String name2\n[2] @RequestParam int age->18\n[3] @RequestParam String home1->${JAVA_HOME}\n[4] @RequestParam MultipartFile file->org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@50313382\n[5] @PathVariable int id\n[6] @RequestHeader String header\n[7] @CookieValue String token\n[8] @Value String home2\n[9] HttpServletRequest request\n[10] @ModelAttribute User user1\n[11] User user2\n[12] @RequestBody User user3\n```\n\n发现只要标注了`@RequestParam`注解的参数都已经被解析成功。\n\n我们将解析出来的值的类型打印出来：\n\n```Java\nSystem.out.println(v.getClass());\n```\n\n运行启动类，查看控制台：\n\n```Plain\nclass java.lang.String\n[0] @RequestParam String name1->zhangsan\n[1] String name2\nclass java.lang.String\n[2] @RequestParam int age->18\nclass java.lang.String\n[3] @RequestParam String home1->${JAVA_HOME}\nclass org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile\n[4] @RequestParam MultipartFile file->org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@50313382\n[5] @PathVariable int id\n[6] @RequestHeader String header\n[7] @CookieValue String token\n[8] @Value String home2\n[9] HttpServletRequest request\n[10] @ModelAttribute User user1\n[11] User user2\n[12] @RequestBody User user3\n```\n\n发现age参数没有进行类型转换，我们期望的是数值型，但最终还是字符串类型。\n\n我们需要准备一个类型转换工厂：\n\n```Java\nServletRequestDataBinderFactory factory = new ServletRequestDataBinderFactory(null, null);\n```\n\n在调用`resolveArgument()`方法时传入此工厂：\n\n```Java\nObject v = resolver.resolveArgument(parameter, container, new ServletWebRequest(request), factory);\n```\n\n运行启动类，查看控制台：\n\n```Plain\nclass java.lang.String\n[0] @RequestParam String name1->zhangsan\n[1] String name2\nclass java.lang.Integer\n[2] @RequestParam int age->18\nclass java.lang.String\n[3] @RequestParam String home1->${JAVA_HOME}\nclass org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile\n[4] @RequestParam MultipartFile file->org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@6c372fe6\n[5] @PathVariable int id\n[6] @RequestHeader String header\n[7] @CookieValue String token\n[8] @Value String home2\n[9] HttpServletRequest request\n[10] @ModelAttribute User user1\n[11] User user2\n[12] @RequestBody User user3\n```\n\n发现age参数已经帮我们进行了类型转换。\n\n再次观察输出结果，发现在request中我们没有传入home1参数，因此原样输出了`${JAVA_HOME}`，但这并不是我们想要的结果，我们需要的是`${JAVA_HOME}`被解析后的结果。说明表达式并没有被解析，我们可以使用`BeanFactory`容器提供的表达式解析器去解析。\n\n获取`beanFactory`，在创建参数解析器的时候传入`BeanFactory`：\n\n```Java\nDefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();\nRequestParamMethodArgumentResolver resolver = new RequestParamMethodArgumentResolver(beanFactory, false);\n```\n\n运行启动类，查看控制台：\n\n```Plain\nclass java.lang.String\n[0] @RequestParam String name1->zhangsan\n[1] String name2\nclass java.lang.Integer\n[2] @RequestParam int age->18\nclass java.lang.String\n[3] @RequestParam String home1->C:\\Path\\jdk-14.0.1\nclass org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile\n[4] @RequestParam MultipartFile file->org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@19e7a160\n[5] @PathVariable int id\n[6] @RequestHeader String header\n[7] @CookieValue String token\n[8] @Value String home2\n[9] HttpServletRequest request\n[10] @ModelAttribute User user1\n[11] User user2\n[12] @RequestBody User user3\n```\n\n发现`${}`表达式成功被解析。\n\n我们将`new RequestParamMethodArgumentResolver()`第二个参数设置为`true`：\n\n```Java\n// 第一个参数为BeanFactory、第二个参数为省略@RequestParam是否解析属性\nRequestParamMethodArgumentResolver resolver = new RequestParamMethodArgumentResolver(null, true);\n```\n\n运行启动类，查看控制台：\n\n```Plain\nclass java.lang.String\n[0] @RequestParam String name1->zhangsan\nclass java.lang.String\n[1] String name2->lisi\nclass java.lang.Integer\n[2] @RequestParam int age->18\nclass java.lang.String\n[3] @RequestParam String home1->C:\\Path\\jdk-14.0.1\nclass org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile\n[4] @RequestParam MultipartFile file->org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@4e31276e\nException in thread \"main\" java.lang.IllegalStateException: Optional int parameter 'id' is present but cannot be translated into a null value due to being declared as a primitive type. Consider declaring it as object wrapper for the corresponding primitive type.\n        at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.handleNullValue(AbstractNamedValueMethodArgumentResolver.java:263)\n        at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:116)\n        at com.spring.test._21_.A21.main(A21.java:87)\n```\n\n发现`name2`这种没有带`@RequestParam`注解的参数也被成功解析了。\n\n但是解析到带有`@PathVariable`注解的参数`id`却出错了，这是因为只要没有带`@RequestParam`注解的参数例如`@PathVariable`、`@RequestHeader`、`@CookieValue`等注解`RequestParamMethodArgumentResolver`都会尝试去解析，因此会解析失败。针对这种情况，其实我们只需要把其他类型的解析器都添加上，每个解析器都会去尝试解析，只要有一个解析器解析成功就以此值为准。\n\nSpring中提供了`HandlerMethodArgumentResolverComposite`类，它使用了组合模式。我们只需要将解析器添加进去，直接调用`HandlerMethodArgumentResolverComposite`的`supportsParameter()`方法和`resolveArgument()`方法即可，不需要一个一个去调用判断，体现了组合模式的优势。\n\n`HandlerMethodArgumentResolverComposite`使用示例：\n\n```Java\nHandlerMethodArgumentResolverComposite composite = new HandlerMethodArgumentResolverComposite();\ncomposite.addResolvers(\n        new RequestParamMethodArgumentResolver(beanFactory, false)\n);\n//...\nif (composite.supportsParameter(parameter)) {\n    // 支持此参数解析\n    Object v = composite.resolveArgument(parameter, container, new ServletWebRequest(request), factory);\n    System.out.println(v.getClass());\n    System.out.println(\"[\" + parameter.getParameterIndex() + \"] \" + str + parameter.getParameterType().getSimpleName() + \" \" + parameter.getParameterName() + \"->\" + v);\n} else {\n    System.out.println(\"[\" + parameter.getParameterIndex() + \"] \" + str + parameter.getParameterType().getSimpleName() + \" \" + parameter.getParameterName());\n}\n```\n\n**PathVariableMethodArgumentResolver**\n\n`PathVariableMethodArgumentResolver`解析器实际上是从request去取`HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE`键对应的`map`值，然后从这个`map`中去取值，这里我们没有`HandlerMapping`去解析映射，因此我们手动模拟：\n\n```Java\nMap<String, String> map = new AntPathMatcher().extractUriTemplateVariables(\"/test/{id}\", \"/test/123\");\nrequest.setAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, map);\n```\n\n`map`的内容实际为：\n\n```Plain\n{id=123}\n```\n\n我们添加`PathVariableMethodArgumentResolver`解析器：\n\n```Java\ncomposite.addResolvers(\n        //...\n        new PathVariableMethodArgumentResolver()\n);\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[5] @PathVariable int id->123\n```\n\n发现`id`参数已经成功被解析。\n\n**RequestHeaderMethodArgumentResolver**\n\n`RequestHeaderMethodArgumentResolver`解析器主要解析请求头中的内容，我们添加此解析器：\n\n```Java\ncomposite.addResolvers(\n        //...\n        new RequestHeaderMethodArgumentResolver(beanFactory)\n);\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[6] @RequestHeader String header->application/json\n```\n\n发现`header`参数已经成功被解析。\n\n**ServletCookieValueMethodArgumentResolver**\n\n`ServletCookieValueMethodArgumentResolver`解析器是从`cookie`中获取数据，我们添加此解析器：\n\n```Java\ncomposite.addResolvers(\n        //...\n        new ServletCookieValueMethodArgumentResolver(beanFactory)\n);\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[7] @CookieValue String token->123456\n```\n\n发现`token`参数已经成功被解析。\n\n**ExpressionValueMethodArgumentResolver**\n\n`ExpressionValueMethodArgumentResolver`解析器从`BeanFactory`中获取数据，并且支持EL表达式，我们添加此解析器：\n\n```Java\ncomposite.addResolvers(\n        //...\n        new ExpressionValueMethodArgumentResolver(beanFactory)\n);\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[8] @Value String home2->C:\\Path\\jdk-14.0.1\n```\n\n发现`home2`参数已经成功被解析。\n\n**ServletRequestMethodArgumentResolver**\n\n`ServletRequestMethodArgumentResolver`解析器是根据类型解析数据，会将web容器中的类型注入，我们添加此解析器：\n\n```Java\ncomposite.addResolvers(\n        //...\n        new ServletRequestMethodArgumentResolver()\n);\n```\n\n运行启动类，查看控制台：\n\n```Plain\nHttpServletRequest request->org.springframework.web.multipart.support.StandardMultipartHttpServletRequest@6c0d7c83\n```\n\n发现`request`参数已经成功被解析。\n\n除了解析`HttpServletRequest`类型之外，它还支持很多类型，我们可以查看它的`supportsParameter()`方法：\n\n```Java\npublic boolean supportsParameter(MethodParameter parameter) {\n    Class<?> paramType = parameter.getParameterType();\n    return WebRequest.class.isAssignableFrom(paramType) || ServletRequest.class.isAssignableFrom(paramType) || MultipartRequest.class.isAssignableFrom(paramType) || HttpSession.class.isAssignableFrom(paramType) || pushBuilder != null && pushBuilder.isAssignableFrom(paramType) || Principal.class.isAssignableFrom(paramType) && !parameter.hasParameterAnnotations() || InputStream.class.isAssignableFrom(paramType) || Reader.class.isAssignableFrom(paramType) || HttpMethod.class == paramType || Locale.class == paramType || TimeZone.class == paramType || ZoneId.class == paramType;\n}\n```\n\n可以发现一些常用的类型，例如`ServletRequest`、`HttpSession`等\n\n**ServletModelAttributeMethodProcessor**\n\n`ServletModelAttributeMethodProcessor`解析器可以解析请求参数并封装为`Model`，最终会存到`ModelAndViewContainer`中，我们添加此解析器：\n\n```Java\ncomposite.addResolvers(\n        //...\n        // 参数为false代表必须有 @ModelAttribute注解\n        new ServletModelAttributeMethodProcessor(false)\n);\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[10] @ModelAttribute User user1->User{name='zhangsan', age=18}\n```\n\n发现请求参数已经成功被封装为`User`对象。\n\n我们可以再加一个`ServletModelAttributeMethodProcessor`参数为`true`的解析器，用来解析不带`@ModelAttribute`注解的参数：\n\n```Java\ncomposite.addResolvers(\n        //...\n        // 参数为true代表没有@ModelAttribute注解\n        new ServletModelAttributeMethodProcessor(true)\n);\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[11] User user2->User{name='zhangsan', age=18}\n```\n\n发现不带`@ModelAttribute`注解的参数也已经成功被封装为`User`对象。\n\n除了封装将请求参数封装为`Model`，还会存到`ModelAndViewContainer`中，我们打印`ModelAndViewContainer`：\n\n```Java\nSystem.out.println(\"model:\" + container.getModel());\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[10] @ModelAttribute User user1->User{name='zhangsan', age=18}\nmodel:{abc=User{name='zhangsan', age=18}, org.springframework.validation.BindingResult.abc=org.springframework.validation.BeanPropertyBindingResult: 0 errors}\nclass com.spring.test._21_.A21$User\n[11] User user2->User{name='zhangsan', age=18}\nmodel:{abc=User{name='zhangsan', age=18}, org.springframework.validation.BindingResult.abc=org.springframework.validation.BeanPropertyBindingResult: 0 errors, user=User{name='zhangsan', age=18}, org.springframework.validation.BindingResult.user=org.springframework.validation.BeanPropertyBindingResult: 0 errors}\n```\n\n[10]是带有`@ModelAttribute`注解的参数，[11]是不带有`@ModelAttribute`注解的参数，发现都会将解析后的数据存到`ModelAndViewContainer`中。\n\n**RequestResponseBodyMethodProcessor**\n\n`RequestResponseBodyMethodProcessor`解析器会将请求体中的数据绑定到对象上，我们添加此解析器：\n\n```Java\ncomposite.addResolvers(\n        //...\n        new ServletModelAttributeMethodProcessor(false),\n        new RequestResponseBodyMethodProcessor(List.of(new MappingJackson2HttpMessageConverter())),\n        new ServletModelAttributeMethodProcessor(true),\n        );\n```\n\n注意`RequestResponseBodyMethodProcessor`解析器不能放在`ServletModelAttributeMethodProcessor(true)`之后，否则解析的时候会优先使用`ServletModelAttributeMethodProcessor(true)`解析器(从请求参数中取值)，就不会使用`RequestResponseBodyMethodProcessor`解析器。\n\n运行启动类，查看控制台：\n\n```Plain\n[12] @RequestBody User user3->User{name='lisi', age=20}\n```\n\n发现带`@RequestBody`注解的参数已经成功被封装为`User`对象。\n\n# 参数名解析\n\n## 参数名称原理\n\n在通过`HandlerMethod`的`getMethodParameters()`方法获取`MethodParameter`之后，我们直接通过\n\n`MethodParameter`的`getParameterName()`方法获取参数名是获取不到的。我们必须通过`MethodParameter`的`initParameterNameDiscovery()`方法添加一个参数解析器才能获取到参数，说明参数的获取并不是我们想象的那么简单。\n\n为了避免idea为我们编译类，我们在show模块下创建a22目录，并在a22目录下创建com.itheima.a22包，在此包下创建测试类。\n\n我们创建一个测试类：\n\n```Java\npublic class Bean2 {\n    public Bean2() {\n    }\n\n    public void foo(String name, int age) {\n    }\n}\n```\n\n使用`javac`命令手动编译此类：\n\n```Shell\njavac .\\Bean2.java\n```\n\n使用idea查看反编译后的代码：\n\n```Java\npublic class Bean2 {\n    public Bean2() {\n    }\n\n    public void foo(String var1, int var2) {\n    }\n}\n```\n\n发现我们的参数名被丢弃了，变成了var1、var2。说明在不加任何编译参数的情况下，是不会保留代码参数名的。\n\n使用javap命令反编译代码：\n\n```Shell\njavap -c -v .\\Bean2.class\nClassfile /F:/Java/黑马全套java教程/第2阶段企业级开发—基础框架/7、spring高级45讲/代码/代码/show/a22/com/itheima/a22/Bean2.class\n  Last modified 2023年4月4日; size 317 bytes\n  SHA-256 checksum 178e5acc8063e10d20b3da678a5d96fa1b8329c21794834b5304135963070a9a\n  Compiled from \"Bean2.java\"                                      \npublic class com.itheima.a22.Bean2                                \n  minor version: 0                                                \n  major version: 58                                               \n  flags: (0x0021) ACC_PUBLIC, ACC_SUPER                           \n  this_class: #7                          // com/itheima/a22/Bean2\n  super_class: #2                         // java/lang/Object     \n  interfaces: 0, fields: 0, methods: 2, attributes: 1\nConstant pool:\n   #1 = Methodref          #2.#3          // java/lang/Object.\"<init>\":()V\n   #2 = Class              #4             // java/lang/Object\n   #3 = NameAndType        #5:#6          // \"<init>\":()V\n   #4 = Utf8               java/lang/Object\n   #5 = Utf8               <init>\n   #6 = Utf8               ()V\n   #7 = Class              #8             // com/itheima/a22/Bean2\n   #8 = Utf8               com/itheima/a22/Bean2\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               foo\n  #12 = Utf8               (Ljava/lang/String;I)V\n  #13 = Utf8               MethodParameters\n  #14 = Utf8               name\n  #15 = Utf8               age\n  #16 = Utf8               SourceFile\n  #17 = Utf8               Bean2.java\n{\n  public com.itheima.a22.Bean2();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 3: 0\n\n  public void foo(java.lang.String, int);\n    descriptor: (Ljava/lang/String;I)V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=0, locals=3, args_size=3\n         0: return\n      LineNumberTable:\n        line 6: 0\n    MethodParameters:\n      Name                           Flags\n      name\n      age\n}\nSourceFile: \"Bean2.java\"\n```\n\n发现并没有保存参数名称信息。\n\n有两种方式可以解决这个问题：\n\n1. 编译命令添加-parameters参数\n\n```Shell\njavac -parameters .\\Bean2.java\n```\n\n然后再使用idea查看反编译后的代码：\n\n```Java\npublic class Bean2 {\n    public Bean2() {\n    }\n\n    public void foo(String name, int age) {\n    }\n}\n```\n\n发现保留了参数名称。\n\n使用javap命令反编译代码：\n\n```Shell\njavap -c -v .\\Bean2.class\nClassfile /F:/Java/黑马全套java教程/第2阶段企业级开发—基础框架/7、spring高级45讲/代码/代码/show/a22/com/itheima/a22/Bean2.class\n  Last modified 2023年4月4日; size 317 bytes\n  SHA-256 checksum 178e5acc8063e10d20b3da678a5d96fa1b8329c21794834b5304135963070a9a\n  Compiled from \"Bean2.java\"\npublic class com.itheima.a22.Bean2\n  minor version: 0\n  major version: 58\n  flags: (0x0021) ACC_PUBLIC, ACC_SUPER\n  this_class: #7                          // com/itheima/a22/Bean2\n  super_class: #2                         // java/lang/Object\n  interfaces: 0, fields: 0, methods: 2, attributes: 1\nConstant pool:\n   #1 = Methodref          #2.#3          // java/lang/Object.\"<init>\":()V\n   #2 = Class              #4             // java/lang/Object\n   #3 = NameAndType        #5:#6          // \"<init>\":()V\n   #4 = Utf8               java/lang/Object\n   #5 = Utf8               <init>\n   #6 = Utf8               ()V\n   #7 = Class              #8             // com/itheima/a22/Bean2\n   #8 = Utf8               com/itheima/a22/Bean2\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               foo\n  #12 = Utf8               (Ljava/lang/String;I)V\n  #13 = Utf8               MethodParameters\n  #14 = Utf8               name\n  #15 = Utf8               age\n  #16 = Utf8               SourceFile\n  #17 = Utf8               Bean2.java\n{\n  public com.itheima.a22.Bean2();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 3: 0\n\n  public void foo(java.lang.String, int);\n    descriptor: (Ljava/lang/String;I)V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=0, locals=3, args_size=3\n         0: return\n      LineNumberTable:\n        line 6: 0\n    MethodParameters:\n      Name                           Flags\n      name\n      age\n}\nSourceFile: \"Bean2.java\"\n```\n\n发现比没有添加任何参数的编译命令多了`MethodParameters`值，其中记录了参数名称。\n\n2. 编译命令添加-g选项\n\n```Shell\njavac -g .\\Bean2.java\n```\n\n然后再使用idea查看反编译后的代码：\n\n```Java\npublic class Bean2 {\n    public Bean2() {\n    }\n\n    public void foo(String name, int age) {\n    }\n}\n```\n\n发现也保留了参数名称。\n\n使用javap命令反编译代码：\n\n```Shell\njavap -c -v .\\Bean2.class\nClassfile /F:/Java/黑马全套java教程/第2阶段企业级开发—基础框架/7、spring高级45讲/代码/代码/show/a22/com/itheima/a22/Bean2.class\n  Last modified 2023年4月4日; size 418 bytes\n  SHA-256 checksum 7ca753d2e057ff492011420a6e1ec419c0025fbedff47832ddb179560b1b42cd\n  Compiled from \"Bean2.java\"                                                       \npublic class com.itheima.a22.Bean2                                                 \n  minor version: 0                                                                 \n  major version: 58                                                                \n  flags: (0x0021) ACC_PUBLIC, ACC_SUPER                                            \n  this_class: #7                          // com/itheima/a22/Bean2                 \n  super_class: #2                         // java/lang/Object                      \n  interfaces: 0, fields: 0, methods: 2, attributes: 1                              \nConstant pool:                                                            \n   #1 = Methodref          #2.#3          // java/lang/Object.\"<init>\":()V\n   #2 = Class              #4             // java/lang/Object\n   #3 = NameAndType        #5:#6          // \"<init>\":()V\n   #4 = Utf8               java/lang/Object\n   #5 = Utf8               <init>\n   #6 = Utf8               ()V\n   #7 = Class              #8             // com/itheima/a22/Bean2\n   #8 = Utf8               com/itheima/a22/Bean2\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               LocalVariableTable\n  #12 = Utf8               this\n  #13 = Utf8               Lcom/itheima/a22/Bean2;\n  #14 = Utf8               foo\n  #15 = Utf8               (Ljava/lang/String;I)V\n  #16 = Utf8               name\n  #17 = Utf8               Ljava/lang/String;\n  #18 = Utf8               age\n  #19 = Utf8               I\n  #20 = Utf8               SourceFile\n  #21 = Utf8               Bean2.java\n{\n  public com.itheima.a22.Bean2();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 3: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Lcom/itheima/a22/Bean2;\n\n  public void foo(java.lang.String, int);\n    descriptor: (Ljava/lang/String;I)V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=0, locals=3, args_size=3\n         0: return\n      LineNumberTable:\n        line 6: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       1     0  this   Lcom/itheima/a22/Bean2;\n            0       1     1  name   Ljava/lang/String;\n            0       1     2   age   I\n}\nSourceFile: \"Bean2.java\"\n```\n\n发现比没有添加任何参数的编译命令多了`LocalVariableTable`值，其中记录了参数名称。\n\n使用`-parameters`与使用`-g`选项的区别：\n\n- 使用`-parameters`生成的`MethodParameters`可以通过反射获取\n- 使用`-g`生成的`LocalVariableTable`不能通过反射获取，但能通过ASM方式获取\n\n> Spring对这两种方式都支持\n\n## 获取参数名称\n\n首先我们需要将`a22/com/itheima/a22`加入模块依赖：\n\n1. 打开项目结构\n2. 点击模块，选择show模块\n3. 点击依赖，点击+号，选择JAR或目录\n4. 选择`a22/com/itheima/a22`，点击应用\n\n编写测试代码，分别通过反射和ASM的方式获取参数名：\n\n```Java\npublic class A22 {\n\n    public static void main(String[] args) throws NoSuchMethodException, ClassNotFoundException {\n        // 1. 反射获取参数名\n        Method foo = Bean2.class.getMethod(\"foo\", String.class, int.class);\n        for (Parameter parameter : foo.getParameters()) {\n            System.out.println(parameter.getName());\n        }\n        System.out.println(\"-----------\");\n        // 2. 基于 LocalVariableTable 本地变量表  spring中ParameterNameDiscoverer接口的实现\n        LocalVariableTableParameterNameDiscoverer discoverer = new LocalVariableTableParameterNameDiscoverer();\n        String[] parameterNames = discoverer.getParameterNames(foo);\n        System.out.println(Arrays.toString(parameterNames));\n    }\n\n}\n```\n\n测试不带任何参数编译类文件：\n\n```Shell\njavac .\\Bean2.java\n```\n\n运行启动类，查看控制台：\n\n```Plain\narg0\narg1\n-----------\nnull\n```\n\n发现通过反射获取的参数名为编译后的默认名称，而通过`LocalVariableTable`变量表的方式获取不到任何信息。\n\n测试带`-parameters`参数编译类文件：\n\n```Shell\njavac -parameters .\\Bean2.java\n```\n\n运行启动类，查看控制台：\n\n```Plain\nname\nage\n-----------\nnull\n```\n\n发现通过反射能成功获取参数名称，而通过`LocalVariableTable`变量表的方式获取不到任何信息。\n\n测试带`-g`选项编译类文件：\n\n```Plain\njavac -g .\\Bean2.java \n```\n\n运行启动类，查看控制台：\n\n```Plain\narg0\narg1\n-----------\n[name, age]\n```\n\n发现通过反射获取的参数名为编译后的默认名称，而通过`LocalVariableTable`变量表的方式能正常获取参数名称。\n\n`Spring`中其实将以上两种参数解析的方式统一了，`ParameterNameDiscoverer`接口有一个实现`DefaultParameterNameDiscoverer`：\n\n```Java\npublic class DefaultParameterNameDiscoverer extends PrioritizedParameterNameDiscoverer {\n    public DefaultParameterNameDiscoverer() {\n        if (KotlinDetector.isKotlinReflectPresent() && !NativeDetector.inNativeImage()) {\n            this.addDiscoverer(new KotlinReflectionParameterNameDiscoverer());\n        }\n\n        // 通过反射\n        this.addDiscoverer(new StandardReflectionParameterNameDiscoverer());\n        // 通过本地变量表\n        this.addDiscoverer(new LocalVariableTableParameterNameDiscoverer());\n    }\n}\n```\n\n通过本地变量表的方式获取参数名称有一个局限性，它只能获取普通类的方法上的参数，而不能获取接口的方法上的参数名称。\n\n我们创建一个接口：\n\n```Java\npublic interface Bean1 {\n    public void foo(String name, int age);\n}\n```\n\n使用`javac -g .\\Bean1.java`命令编译，然后使用`javap -c -v .\\Bean1.class`命令反编译：\n\n```Plain\nClassfile /F:/Java/黑马全套java教程/第2阶段企业级开发—基础框架/7、spring高级45讲/代码/代码/show/a22/com/itheima/a22/Bean1.class\n  Last modified 2023年4月4日; size 146 bytes\n  SHA-256 checksum 916828ed8e8f37b1a074cb49b21e55a5b35ffd2ecad4926d0608828fc3d1bc5d\n  Compiled from \"Bean1.java\"\npublic interface com.itheima.a22.Bean1\n  minor version: 0\n  major version: 58\n  flags: (0x0601) ACC_PUBLIC, ACC_INTERFACE, ACC_ABSTRACT\n  this_class: #1                          // com/itheima/a22/Bean1\n  super_class: #3                         // java/lang/Object\n  #6 = Utf8               (Ljava/lang/String;I)V\n  #7 = Utf8               SourceFile\n  #8 = Utf8               Bean1.java\n{\n  public abstract void foo(java.lang.String, int);\n    descriptor: (Ljava/lang/String;I)V\n    flags: (0x0401) ACC_PUBLIC, ACC_ABSTRACT\n}\nSourceFile: \"Bean1.java\"\n```\n\n发现反编译后的代码没有`LocalVariableTable`信息。\n\n而通过`javac -parameters .\\Bean2.java`这种方式对于普通类和接口都有效，我们可以测试一下，使用`javac -parameters  .\\Bean1.java`命令编译，然后使用`javap -c -v .\\Bean1.class`命令反编译：\n\n```Plain\nClassfile /F:/Java/黑马全套java教程/第2阶段企业级开发—基础框架/7、spring高级45讲/代码/代码/show/a22/com/itheima/a22/Bean1.class\n  Last modified 2023年4月4日; size 193 bytes\n  SHA-256 checksum 4c2d4e73c785737a30dd1c6986385adced085c4e191a26181f84d6fd253a8c7b\n  Compiled from \"Bean1.java\"                                                       \npublic interface com.itheima.a22.Bean1                                             \n  minor version: 0                                                                 \n  major version: 58                                                                \n  flags: (0x0601) ACC_PUBLIC, ACC_INTERFACE, ACC_ABSTRACT                          \n  this_class: #1                          // com/itheima/a22/Bean1                 \n  super_class: #3                         // java/lang/Object                      \n  interfaces: 0, fields: 0, methods: 1, attributes: 1\nConstant pool:\n   #1 = Class              #2             // com/itheima/a22/Bean1\n   #2 = Utf8               com/itheima/a22/Bean1\n   #3 = Class              #4             // java/lang/Object\n   #4 = Utf8               java/lang/Object\n   #5 = Utf8               foo\n   #6 = Utf8               (Ljava/lang/String;I)V\n   #7 = Utf8               MethodParameters\n   #8 = Utf8               name\n   #9 = Utf8               age\n  #10 = Utf8               SourceFile\n  #11 = Utf8               Bean1.java\n{\n  public abstract void foo(java.lang.String, int);\n    descriptor: (Ljava/lang/String;I)V\n    flags: (0x0401) ACC_PUBLIC, ACC_ABSTRACT\n    MethodParameters:\n      Name                           Flags\n      name\n      age\n}\nSourceFile: \"Bean1.java\"\n```\n\n发现也有`MethodParameters`信息。\n\n# 对象绑定与类型转换\n\n## 底层类型转换接口\n\n1. 底层第一套转换接口与实现：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%91%EF%BC%9AWEB/2.png)\n\n- `Printer`把其它类型转为`String`\n- `Parser`把`String`转为其它类型\n- `Formatter`综合`Printer`与`Parser`功能\n- `Converter`把类型S转为类型T\n- `Printer`、`Parser`、`Converter `经过适配转换成`GenericConverter`放入`Converters`集合\n- `FormattingConversionService`利用其它们实现转换\n\n> 第一套转换接口与实现是由Spring提供的\n\n2. 底层第二套转换接口与实现：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%91%EF%BC%9AWEB/3.png)\n\n- `PropertyEditor`把`String`与其它类型相互转换\n- `PropertyEditorRegistry`可以注册多个`PropertyEditor`对象\n- 与第一套接口直接可以通过`FormatterPropertyEditorAdapter`来进行适配\n\n> 第二套转换接口与实现是由JDK提供的\n\n为什么要使用两套转换接口呢，这里可能是`Spring`的历史遗留问题，最早的时候`Spring`使用的是由`JDK`提供的类型转换接口，后来可能觉得`JDK`提供的功能不够全面，自己实现了一套类型转换接口。而为了保证版本向前兼容，因此保留了`JDK`提供的类型转换接口的实现。\n\n## 高级类型转换接口\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%91%EF%BC%9AWEB/4.png)\n\n- 它们都实现了`TypeConverter`这个高层转换接口，在转换时，会用到`TypeConverterDelegate`委派`ConversionService`与`PropertyEditorRegistry`真正执行转换（`Facade`门面模式）\n    - 首先看是否有自定义转换器, `@InitBinder`添加的即属于这种 (用了适配器模式把`Formatter`转为需要的 `PropertyEditor`)\n    - 再看有没有`ConversionService`转换\n    - 再利用默认的`PropertyEditor`转换\n    - 最后有一些特殊处理\n- `SimpleTypeConverter`仅做类型转换\n- `BeanWrapperImpl`为`bean`的属性赋值，当需要时做类型转换，走`Property`\n- `DirectFieldAccessor`为`bean`的属性赋值，当需要时做类型转换，走`Field`\n- `ServletRequestDataBinder`为`bean`的属性执行绑定，当需要时做类型转换，根据`directFieldAccess`选择走`Property`还是`Field`，具备校验与获取校验结果功能\n\n## 类型转换与数据绑定示例\n\n### SimpleTypeConverter\n\n`SimpleTypeConverter`仅有类型转换的功能：\n\n```Java\npublic class TestSimpleConverter {\n    public static void main(String[] args) {\n        SimpleTypeConverter typeConverter = new SimpleTypeConverter();\n        Integer number = typeConverter.convertIfNecessary(\"13\", int.class);\n        Date date = typeConverter.convertIfNecessary(\"1999/03/04\", Date.class);\n        System.out.println(number);\n        System.out.println(date);\n    }\n}\n```\n\n运行启动类，控制台输出：\n\n```Plain\n13\nThu Mar 04 00:00:00 CST 1999\n```\n\n### BeanWrapperImpl\n\n`BeanWrapperImpl`为`bean`的属性赋值，当需要时做类型转换，走`Property`：\n\n```Java\npublic class TestBeanWrapper {\n    public static void main(String[] args) {\n        MyBean target = new MyBean();\n        BeanWrapperImpl wrapper = new BeanWrapperImpl(target);\n        wrapper.setPropertyValue(\"a\", \"10\");\n        wrapper.setPropertyValue(\"b\", \"hello\");\n        wrapper.setPropertyValue(\"c\", \"1999/03/04\");\n        System.out.println(target);\n    }\n\n    static class MyBean {\n        private int a;\n        private String b;\n        private Date c;\n\n        public int getA() {\n            return a;\n        }\n\n        public void setA(int a) {\n            this.a = a;\n        }\n\n        public String getB() {\n            return b;\n        }\n\n        public void setB(String b) {\n            this.b = b;\n        }\n\n        public Date getC() {\n            return c;\n        }\n\n        public void setC(Date c) {\n            this.c = c;\n        }\n\n        @Override\n        public String toString() {\n            return \"MyBean{\" +\n                   \"a=\" + a +\n                   \", b='\" + b + '\\'' +\n                   \", c=\" + c +\n                   '}';\n        }\n    }\n}\n```\n\n运行启动类，控制台输出：\n\n```Plain\nMyBean{a=10, b='hello', c=Thu Mar 04 00:00:00 CST 1999}\n```\n\n### DirectFieldAccessor\n\n`DirectFieldAccessor`为`bean`的属性赋值，当需要时做类型转换，走`Field`：\n\n```Java\npublic class TestFieldAccessor {\n    public static void main(String[] args) {\n        // 利用反射原理, 为 bean 的属性赋值\n        MyBean target = new MyBean();\n        DirectFieldAccessor accessor = new DirectFieldAccessor(target);\n        accessor.setPropertyValue(\"a\", \"10\");\n        accessor.setPropertyValue(\"b\", \"hello\");\n        accessor.setPropertyValue(\"c\", \"1999/03/04\");\n        System.out.println(target);\n    }\n\n    static class MyBean {\n        private int a;\n        private String b;\n        private Date c;\n        @Override\n        public String toString() {\n            return \"MyBean{\" +\n                   \"a=\" + a +\n                   \", b='\" + b + '\\'' +\n                   \", c=\" + c +\n                   '}';\n        }\n    }\n}\n```\n\n运行启动类，控制台输出：\n\n```Plain\nMyBean{a=10, b='hello', c=Thu Mar 04 00:00:00 CST 1999}\n```\n\n### DataBinder\n\n`DataBinder`执行数据绑定，`DataBinder`有两个方法\n\n- `initBeanPropertyAccess()`使用property的方式绑定数据\n- `initDirectFieldAccess()`使用field的方式绑定数据\n\n我们查看源代码：\n\n```Java\npublic void initBeanPropertyAccess() {\n    Assert.state(this.bindingResult == null, \"DataBinder is already initialized - call initBeanPropertyAccess before other configuration methods\");\n    this.directFieldAccess = false;\n}\npublic void initDirectFieldAccess() {\n    Assert.state(this.bindingResult == null, \"DataBinder is already initialized - call initDirectFieldAccess before other configuration methods\");\n    this.directFieldAccess = true;\n}\n```\n\n发现就是将`directFieldAccess`修改为不同的值。\n\n```Java\npublic class TestDataBinder {\n\n    public static void main(String[] args) {\n        MyBean target = new MyBean();\n        DataBinder dataBinder = new DataBinder(target);\n        dataBinder.initDirectFieldAccess();\n        MutablePropertyValues pvs = new MutablePropertyValues();\n        pvs.add(\"a\", \"10\");\n        pvs.add(\"b\", \"hello\");\n        pvs.add(\"c\", \"1999/03/04\");\n        dataBinder.bind(pvs);\n        System.out.println(target);\n    }\n\n    static class MyBean {\n        private int a;\n        private String b;\n        private Date c;\n\n        @Override\n        public String toString() {\n            return \"MyBean{\" +\n                   \"a=\" + a +\n                   \", b='\" + b + '\\'' +\n                   \", c=\" + c +\n                   '}';\n        }\n    }\n}\n```\n\n运行启动类，控制台输出：\n\n```Plain\nMyBean{a=10, b='hello', c=Thu Mar 04 00:00:00 CST 1999}\n```\n\n以上是普通环境中`DataBinder`的数据绑定，在`WEB`环境中也有相对应的实现，我们需要将`DataBinder`的实现替换为`ServletRequestDataBinder`，同时将`MutablePropertyValues`的实现替换为`ServletRequestParameterPropertyValues`：\n\n```Java\npublic class TestServletDataBinder {\n\n    public static void main(String[] args) {\n        // web 环境下数据绑定\n        MyBean target = new MyBean();\n        ServletRequestDataBinder dataBinder = new ServletRequestDataBinder(target);\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setParameter(\"a\", \"10\");\n        request.setParameter(\"b\", \"hello\");\n        request.setParameter(\"c\", \"1999/03/04\");\n\n        dataBinder.bind(new ServletRequestParameterPropertyValues(request));\n\n        System.out.println(target);\n    }\n\n    static class MyBean {\n        private int a;\n        private String b;\n        private Date c;\n\n        public int getA() {\n            return a;\n        }\n\n        public void setA(int a) {\n            this.a = a;\n        }\n\n        public String getB() {\n            return b;\n        }\n\n        public void setB(String b) {\n            this.b = b;\n        }\n\n        public Date getC() {\n            return c;\n        }\n\n        public void setC(Date c) {\n            this.c = c;\n        }\n\n        @Override\n        public String toString() {\n            return \"MyBean{\" +\n                   \"a=\" + a +\n                   \", b='\" + b + '\\'' +\n                   \", c=\" + c +\n                   '}';\n        }\n    }\n}\n```\n\n运行启动类，控制台输出：\n\n```Plain\nMyBean{a=10, b='hello', c=Thu Mar 04 00:00:00 CST 1999}\n```\n\n实际上参数解析器`ModelAttributeMethodProcessor`使用的类型转换就是`ServletRequestDataBinder`。\n\n## 数据绑定工厂\n\n试想一种场景，如果传入的参数是自定义的格式，那么`DataBinder`还能正常工作吗？先看下面一个例子：\n\n```Java\npublic class TestServletDataBinderFactory {\n    public static void main(String[] args) throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setParameter(\"birthday\", \"1999|01|02\");\n        request.setParameter(\"address.name\", \"西安\");\n        User target = new User();\n        ServletRequestDataBinder dataBinder = new ServletRequestDataBinder(target);\n        dataBinder.bind(new ServletRequestParameterPropertyValues(request));\n        System.out.println(target);\n    }\n\n    public static class User {\n        private Date birthday;\n        private Address address;\n\n        public Address getAddress() {\n            return address;\n        }\n\n        public void setAddress(Address address) {\n            this.address = address;\n        }\n\n        public Date getBirthday() {\n            return birthday;\n        }\n\n        public void setBirthday(Date birthday) {\n            this.birthday = birthday;\n        }\n\n        @Override\n        public String toString() {\n            return \"User{\" +\n                   \"birthday=\" + birthday +\n                   \", address=\" + address +\n                   '}';\n        }\n    }\n\n    public static class Address {\n        private String name;\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"Address{\" +\n                   \"name='\" + name + '\\'' +\n                   '}';\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nUser{birthday=null, address=Address{name='西安'}}\n```\n\n发现我们自定义的日期格式，`DataBinder`是不能识别的，这时候就需要用到类型转换工厂。有两种方式可以实现自定义格式绑定：\n\n- 使用底层第一套类型转换，用`@InitBinder`转换，即`PropertyEditorRegistry`+`PropertyEditor`\n- 使用底层第二套类型转换，用`ConversionService`转换**，**即`ConversionService`+`Formatter`\n- 使用默认的`ConversionService`进行转换\n\n1. 用`@InitBinder`转换：\n\n```Java\n/**\n* 创建自定义转换器\n*/\npublic class MyDateFormatter implements Formatter<Date> {\n    private static final Logger log = LoggerFactory.getLogger(MyDateFormatter.class);\n    private final String desc;\n\n    public MyDateFormatter(String desc) {\n        this.desc = desc;\n    }\n\n    @Override\n    public String print(Date date, Locale locale) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy|MM|dd\");\n        return sdf.format(date);\n    }\n\n    @Override\n    public Date parse(String text, Locale locale) throws ParseException {\n        log.debug(\">>>>>> 进入了: {}\", desc);\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy|MM|dd\");\n        return sdf.parse(text);\n    }\n\n\n}\n\n/**\n* 创建Controller，使用@InitBinder注解，传入WebDataBinder类型，并加入自定义的转换器\n*/\nstatic class MyController {\n    @InitBinder\n    public void aaa(WebDataBinder dataBinder) {\n        // 扩展 dataBinder 的转换器\n        dataBinder.addCustomFormatter(new MyDateFormatter(\"用 @InitBinder 方式扩展的\"));\n    }\n}\n\npublic class TestServletDataBinderFactory {\n    public static void main(String[] args) throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setParameter(\"birthday\", \"1999|01|02\");\n        request.setParameter(\"address.name\", \"西安\");\n\n        User target = new User();\n        // \"2. 用 @InitBinder 转换\"          PropertyEditorRegistry PropertyEditor\n        InvocableHandlerMethod method = new InvocableHandlerMethod(new MyController(), MyController.class.getMethod(\"aaa\", WebDataBinder.class));\n        // 创建工厂\n        ServletRequestDataBinderFactory factory = new ServletRequestDataBinderFactory(List.of(method), null);\n        // 创建WebDataBinder \n        WebDataBinder dataBinder = factory.createBinder(new ServletWebRequest(request), target, \"user\");\n        dataBinder.bind(new ServletRequestParameterPropertyValues(request));\n        System.out.println(target);\n    }\n\n    public static class User {\n       \n        private Date birthday;\n        private Address address;\n\n        public Address getAddress() {\n            return address;\n        }\n\n        public void setAddress(Address address) {\n            this.address = address;\n        }\n\n        public Date getBirthday() {\n            return birthday;\n        }\n\n        public void setBirthday(Date birthday) {\n            this.birthday = birthday;\n        }\n\n        @Override\n        public String toString() {\n            return \"User{\" +\n                   \"birthday=\" + birthday +\n                   \", address=\" + address +\n                   '}';\n        }\n    }\n\n    public static class Address {\n        private String name;\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"Address{\" +\n                   \"name='\" + name + '\\'' +\n                   '}';\n        }\n    }\n}\n```\n\n使用`@InitBinder`转换的步骤：\n\n1. 标注了`@InitBinder`注解的方法向`WebDataBinder`中添加了自定义的转换器\n2. 在创建`ServletRequestDataBinderFactory`时，添加了`InvocableHandlerMethod`\n3. 在通过`factory.createBinder()`获取`WebDataBinder`时会回调标注了`@InitBinder`注解的方法，并添加自定义的转换器\n\n我们查看`WebDataBinder`的`addCustomFormatter()`方法：\n\n```Java\npublic void addCustomFormatter(Formatter<?> formatter) {\n    FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n    this.getPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);\n}\n```\n\n发现实际调用的是`PropertyEditorRegistry`的`registerCustomEditor()`方法注册转换器，本质上是利用`PropertyEditorRegistry`+`PropertyEditor`的方式进行数据绑定。\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 12:55:41.361 [main] com.itheima.a23.MyDateFormatter     - >>>>>> 进入了: 用 @InitBinder 方式扩展的 \nUser{birthday=Sat Jan 02 00:00:00 CST 1999, address=Address{name='西安'}}\n```\n\n发现数据成功被绑定。\n\n2. 用`ConversionService`转换：\n\n```Java\npublic class TestServletDataBinderFactory {\n    public static void main(String[] args) throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setParameter(\"birthday\", \"1999|01|02\");\n        request.setParameter(\"address.name\", \"西安\");\n        User target = new User();\n        FormattingConversionService service = new FormattingConversionService();\n        service.addFormatter(new MyDateFormatter(\"用 ConversionService 方式扩展转换功能\"));\n        ConfigurableWebBindingInitializer initializer = new ConfigurableWebBindingInitializer();\n        initializer.setConversionService(service);\n        ServletRequestDataBinderFactory factory = new ServletRequestDataBinderFactory(null, initializer);\n        WebDataBinder dataBinder = factory.createBinder(new ServletWebRequest(request), target, \"user\");\n        dataBinder.bind(new ServletRequestParameterPropertyValues(request));\n        System.out.println(target);\n    }\n\n    public static class User {\n        \n        private Date birthday;\n        private Address address;\n\n        public Address getAddress() {\n            return address;\n        }\n\n        public void setAddress(Address address) {\n            this.address = address;\n        }\n\n        public Date getBirthday() {\n            return birthday;\n        }\n\n        public void setBirthday(Date birthday) {\n            this.birthday = birthday;\n        }\n\n        @Override\n        public String toString() {\n            return \"User{\" +\n                   \"birthday=\" + birthday +\n                   \", address=\" + address +\n                   '}';\n        }\n    }\n\n    public static class Address {\n        private String name;\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"Address{\" +\n                   \"name='\" + name + '\\'' +\n                   '}';\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 13:07:36.277 [main] com.itheima.a23.MyDateFormatter     - >>>>>> 进入了: 用 ConversionService 方式扩展转换功能 \nUser{birthday=Sat Jan 02 00:00:00 CST 1999, address=Address{name='西安'}}\n```\n\n如果同时使用以上两种方式，那么会优先调用哪一种方式进行转换呢？\n\n```Java\npublic class TestServletDataBinderFactory {\n    public static void main(String[] args) throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setParameter(\"birthday\", \"1999|01|02\");\n        request.setParameter(\"address.name\", \"西安\");\n        User target = new User();\n        InvocableHandlerMethod method = new InvocableHandlerMethod(new MyController(), MyController.class.getMethod(\"aaa\", WebDataBinder.class));\n        FormattingConversionService service = new FormattingConversionService();\n        service.addFormatter(new MyDateFormatter(\"用 ConversionService 方式扩展转换功能\"));\n        ConfigurableWebBindingInitializer initializer = new ConfigurableWebBindingInitializer();\n        initializer.setConversionService(service);\n        ServletRequestDataBinderFactory factory = new ServletRequestDataBinderFactory(List.of(method), initializer);\n        WebDataBinder dataBinder = factory.createBinder(new ServletWebRequest(request), target, \"user\");\n        dataBinder.bind(new ServletRequestParameterPropertyValues(request));\n        System.out.println(target);\n    }\n\n    static class MyController {\n        @InitBinder\n        public void aaa(WebDataBinder dataBinder) {\n            // 扩展 dataBinder 的转换器\n            dataBinder.addCustomFormatter(new MyDateFormatter(\"用 @InitBinder 方式扩展的\"));\n        }\n    }\n\n    public static class User {\n        \n        private Date birthday;\n        private Address address;\n\n        public Address getAddress() {\n            return address;\n        }\n\n        public void setAddress(Address address) {\n            this.address = address;\n        }\n\n        public Date getBirthday() {\n            return birthday;\n        }\n\n        public void setBirthday(Date birthday) {\n            this.birthday = birthday;\n        }\n\n        @Override\n        public String toString() {\n            return \"User{\" +\n                   \"birthday=\" + birthday +\n                   \", address=\" + address +\n                   '}';\n        }\n    }\n\n    public static class Address {\n        private String name;\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"Address{\" +\n                   \"name='\" + name + '\\'' +\n                   '}';\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 13:09:55.594 [main] com.itheima.a23.MyDateFormatter     - >>>>>> 进入了: 用 @InitBinder 方式扩展的 \nUser{birthday=Sat Jan 02 00:00:00 CST 1999, address=Address{name='西安'}}\n```\n\n发现优先使用的是`@InitBinder`的方式进行转换的，这也符合高级类型转换接口的转换规则：\n\n- 首先看是否有自定义转换器, `@InitBinder`添加的即属于这种 (用了适配器模式把`Formatter`转为需要的 `PropertyEditor`)\n- 再看有没有`ConversionService`转换\n- 再利用默认的`PropertyEditor`转换\n- 最后有一些特殊处理\n\n3. 使用默认的`ConversionService`进行转换：\n\n默认的`ConversionService`转换需要配合注解`@DateTimeFormat`使用：\n\n```Java\npublic class TestServletDataBinderFactory {\n    public static void main(String[] args) throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setParameter(\"birthday\", \"1999|01|02\");\n        request.setParameter(\"address.name\", \"西安\");\n        User target = new User();\n        DefaultFormattingConversionService service = new DefaultFormattingConversionService();\n        // 如果是SpringBoot程序还可以使用ApplicationConversionService实现\n        // ApplicationConversionService service = new ApplicationConversionService();\n        ConfigurableWebBindingInitializer initializer = new ConfigurableWebBindingInitializer();\n        initializer.setConversionService(service);\n        ServletRequestDataBinderFactory factory = new ServletRequestDataBinderFactory(null, initializer);\n        WebDataBinder dataBinder = factory.createBinder(new ServletWebRequest(request), target, \"user\");\n        dataBinder.bind(new ServletRequestParameterPropertyValues(request));\n        System.out.println(target);\n    }\n\n    public static class User {\n        @DateTimeFormat(pattern = \"yyyy|MM|dd\")\n        private Date birthday;\n        private Address address;\n\n        public Address getAddress() {\n            return address;\n        }\n\n        public void setAddress(Address address) {\n            this.address = address;\n        }\n\n        public Date getBirthday() {\n            return birthday;\n        }\n\n        public void setBirthday(Date birthday) {\n            this.birthday = birthday;\n        }\n\n        @Override\n        public String toString() {\n            return \"User{\" +\n                   \"birthday=\" + birthday +\n                   \", address=\" + address +\n                   '}';\n        }\n    }\n\n    public static class Address {\n        private String name;\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"Address{\" +\n                   \"name='\" + name + '\\'' +\n                   '}';\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nUser{birthday=Sat Jan 02 00:00:00 CST 1999, address=Address{name='西安'}}\n```\n\n## 获取泛型参数\n\n获取泛型参数有两种方法：\n\n1. 使用`jdk`的原始`api`\n2. 使用`spring`提供的工具类\n\n创建示例代码：\n\n```Java\nclass BaseDao<T> {\n    T findOne() {\n        return null;\n    }\n}\n\nclass EmployeeDao extends BaseDao {\n}\n\nclass Student {\n}\n\nclass StudentDao extends BaseDao<Student> {\n}\n\nclass Teacher {\n}\n\nclass TeacherDao extends BaseDao<Teacher> {\n}\n```\n\n1. 使用`jdk`的原始`api`：\n\n```Java\npublic class TestGenericType {\n    public static void main(String[] args) {\n        // 1. java api\n        Type type = TeacherDao.class.getGenericSuperclass();\n        System.out.println(type);\n        // 判断type是否带有泛型信息，例如EmployeeDao继承了BaseDao但是却没有泛型信息\n        if (type instanceof ParameterizedType parameterizedType) {\n            System.out.println(parameterizedType.getActualTypeArguments()[0]);\n        }\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\ncom.itheima.a23.sub.BaseDao<com.itheima.a23.sub.Teacher>\nclass com.itheima.a23.sub.Teacher\n```\n\n2. 使用`spring`提供的工具类\n\n```Java\npublic class TestGenericType {\n    public static void main(String[] args) {\n        // 2. spring api 1\n        Class<?> t = GenericTypeResolver.resolveTypeArgument(TeacherDao.class, BaseDao.class);\n        System.out.println(t);\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nclass com.itheima.a23.sub.Teacher\n```\n\n如果有多个泛型参数的话，可以使用`GenericTypeResolver`的`resolveTypeArgument()`方法\n\n# @InitBinder注解\n\n`@ControllerAdvice`可以为控制器提供增强功能，它能提供以下三种功能增强：\n\n1. `@ExceptionHandler`：加在方法上，统一异常处理\n2. `@ModelAttribute`：加载方法上，方法的返回值将作为模型数据补充到控制器的执行过程中\n3. `@InitBinder`：自定义类型转换器\n\n这里主要介绍`@InitBinder`注解，`@InitBinder`注解可以在两个地方使用：\n\n1. 加在`@ControllerAdvice`注解修饰的类中的方法上，对所有`Controller`都生效。\n2. 加在`@Controller`注解修饰的类中的方法上，只对当前`Controller`生效。\n\n初始化流程大致为先解析`@InitBinder`注解，再执行对应的`Handler`方法，查看`RequestMappingHandlerAdapter`源码：\n\n```Java\n// 每个控制器中的initBinder解析缓存\nprivate final Map<Class<?>, Set<Method>> initBinderCache = new ConcurrentHashMap(64);\n// 全局的initBinder解析缓存\nprivate final Map<ControllerAdviceBean, Set<Method>> initBinderAdviceCache = new LinkedHashMap();\n```\n\n准备代码示例：\n\n```Java\n/**\n* 配置类\n*/\n@Configuration\npublic class WebConfig {\n\n    @ControllerAdvice\n    static class MyControllerAdvice {\n        @InitBinder\n        public void binder3(WebDataBinder webDataBinder) {\n            webDataBinder.addCustomFormatter(new MyDateFormatter(\"binder3 转换器\"));\n        }\n    }\n\n    @Controller\n    static class Controller1 {\n        @InitBinder\n        public void binder1(WebDataBinder webDataBinder) {\n            webDataBinder.addCustomFormatter(new MyDateFormatter(\"binder1 转换器\"));\n        }\n\n        public void foo() {\n\n        }\n    }\n\n    @Controller\n    static class Controller2 {\n        @InitBinder\n        public void binder21(WebDataBinder webDataBinder) {\n            webDataBinder.addCustomFormatter(new MyDateFormatter(\"binder21 转换器\"));\n        }\n\n        @InitBinder\n        public void binder22(WebDataBinder webDataBinder) {\n            webDataBinder.addCustomFormatter(new MyDateFormatter(\"binder22 转换器\"));\n        }\n\n        public void bar() {\n\n        }\n    }\n\n}\n\n/**\n* 启动类\n*/\npublic class A24 {\n\n    private static final Logger log = LoggerFactory.getLogger(A24.class);\n\n    public static void main(String[] args) throws Exception {\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(WebConfig.class);\n        RequestMappingHandlerAdapter handlerAdapter = new RequestMappingHandlerAdapter();\n        handlerAdapter.setApplicationContext(context);\n        handlerAdapter.afterPropertiesSet();\n\n        log.debug(\"1. 刚开始...\");\n        showBindMethods(handlerAdapter);\n\n        Method getDataBinderFactory = RequestMappingHandlerAdapter.class.getDeclaredMethod(\"getDataBinderFactory\", HandlerMethod.class);\n        getDataBinderFactory.setAccessible(true);\n\n        log.debug(\"2. 模拟调用 Controller1 的 foo 方法时 ...\");\n        getDataBinderFactory.invoke(handlerAdapter, new HandlerMethod(new WebConfig.Controller1(), WebConfig.Controller1.class.getMethod(\"foo\")));\n        showBindMethods(handlerAdapter);\n\n        log.debug(\"3. 模拟调用 Controller2 的 bar 方法时 ...\");\n        getDataBinderFactory.invoke(handlerAdapter, new HandlerMethod(new WebConfig.Controller2(), WebConfig.Controller2.class.getMethod(\"bar\")));\n        showBindMethods(handlerAdapter);\n\n        context.close();\n    }\n\n    @SuppressWarnings(\"all\")\n    private static void showBindMethods(RequestMappingHandlerAdapter handlerAdapter) throws NoSuchFieldException, IllegalAccessException {\n        Field initBinderAdviceCache = RequestMappingHandlerAdapter.class.getDeclaredField(\"initBinderAdviceCache\");\n        initBinderAdviceCache.setAccessible(true);\n        Map<ControllerAdviceBean, Set<Method>> globalMap = (Map<ControllerAdviceBean, Set<Method>>) initBinderAdviceCache.get(handlerAdapter);\n        log.debug(\"全局的 @InitBinder 方法 {}\",\n                globalMap.values().stream()\n                        .flatMap(ms -> ms.stream().map(m -> m.getName()))\n                        .collect(Collectors.toList())\n        );\n\n        Field initBinderCache = RequestMappingHandlerAdapter.class.getDeclaredField(\"initBinderCache\");\n        initBinderCache.setAccessible(true);\n        Map<Class<?>, Set<Method>> controllerMap = (Map<Class<?>, Set<Method>>) initBinderCache.get(handlerAdapter);\n        log.debug(\"控制器的 @InitBinder 方法 {}\",\n                controllerMap.entrySet().stream()\n                        .flatMap(e -> e.getValue().stream().map(v -> e.getKey().getSimpleName() + \".\" + v.getName()))\n                        .collect(Collectors.toList())\n        );\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 16:20:11.370 [main] com.itheima.a24.A24                 - 1. 刚开始... \n[DEBUG] 16:20:11.376 [main] com.itheima.a24.A24                 - 全局的 @InitBinder 方法 [binder3] \n[DEBUG] 16:20:11.378 [main] com.itheima.a24.A24                 - 控制器的 @InitBinder 方法 [] \n[DEBUG] 16:20:11.379 [main] com.itheima.a24.A24                 - 2. 模拟调用 Controller1 的 foo 方法时 ... \n[DEBUG] 16:20:11.384 [main] com.itheima.a24.A24                 - 全局的 @InitBinder 方法 [binder3] \n[DEBUG] 16:20:11.387 [main] com.itheima.a24.A24                 - 控制器的 @InitBinder 方法 [Controller1.binder1] \n[DEBUG] 16:20:11.387 [main] com.itheima.a24.A24                 - 3. 模拟调用 Controller2 的 bar 方法时 ... \n[DEBUG] 16:20:11.388 [main] com.itheima.a24.A24                 - 全局的 @InitBinder 方法 [binder3] \n[DEBUG] 16:20:11.388 [main] com.itheima.a24.A24                 - 控制器的 @InitBinder 方法 [Controller1.binder1, Controller2.binder22, Controller2.binder21] \n```\n\n观察输出，我们发现：\n\n1. `@ControllerAdvice`中`@InitBinder`标注的方法，由`RequestMappingHandlerAdapter`在**初始化**时解析并记录\n2. `@Controller`中`@InitBinder`标注的方法，由`RequestMappingHandlerAdapter`会**在控制器方法首次执行时**解析并记录\n\n# 控制器方法执行流程\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%91%EF%BC%9AWEB/5.png)\n\n`HandlerMethod`需要：\n\n- `bean`即是哪个`Controller`\n- `method`即是`Controller`中的哪个方法\n\n`ServletInvocableHandlerMethod`需要：\n\n- `WebDataBinderFactory`负责对象绑定、类型转换\n- `ParameterNameDiscoverer`负责参数名解析\n- `HandlerMethodArgumentResolverComposite`负责解析参数\n- `HandlerMethodReturnValueHandlerComposite`负责处理返回值\n\n控制器方法执行流程如下图所示：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%91%EF%BC%9AWEB/6.png)\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%91%EF%BC%9AWEB/7.png)\n\n准备代码示例：\n\n```Java\n/**\n* 配置类\n*/\n@Configuration\npublic class WebConfig {\n\n    @Controller\n    static class Controller1 {\n        @ResponseStatus(HttpStatus.OK)\n        public ModelAndView foo(User user) {\n            System.out.println(\"foo\");\n            return null;\n        }\n    }\n\n    static class User {\n        private String name;\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n\n            return name;\n        }\n\n        @Override\n        public String toString() {\n            return \"User{\" +\n                   \"name='\" + name + '\\'' +\n                   '}';\n        }\n    }\n}\n\n/**\n* 启动类\n*/\npublic class A25 {\n\n    public static void main(String[] args) throws Exception {\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(WebConfig.class);\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setParameter(\"name\", \"张三\");\n        // 现在可以通过 ServletInvocableHandlerMethod 把这些整合在一起, 并完成控制器方法的调用, 如下\n        ServletInvocableHandlerMethod handlerMethod = new ServletInvocableHandlerMethod(\n                new Controller1(), Controller1.class.getMethod(\"foo\", User.class));\n        ServletRequestDataBinderFactory factory = new ServletRequestDataBinderFactory(null, null);\n        handlerMethod.setDataBinderFactory(factory);\n        handlerMethod.setParameterNameDiscoverer(new DefaultParameterNameDiscoverer());\n        handlerMethod.setHandlerMethodArgumentResolvers(getArgumentResolvers(context));\n        ModelAndViewContainer container = new ModelAndViewContainer();\n        handlerMethod.invokeAndHandle(new ServletWebRequest(request), container);\n        System.out.println(container.getModel());\n        context.close();\n    }\n\n    public static HandlerMethodArgumentResolverComposite getArgumentResolvers(AnnotationConfigApplicationContext context) {\n        HandlerMethodArgumentResolverComposite composite = new HandlerMethodArgumentResolverComposite();\n        // 添加参数解析器\n        composite.addResolvers(\n                new RequestParamMethodArgumentResolver(context.getDefaultListableBeanFactory(), false),\n                new PathVariableMethodArgumentResolver(),\n                new RequestHeaderMethodArgumentResolver(context.getDefaultListableBeanFactory()),\n                new ServletCookieValueMethodArgumentResolver(context.getDefaultListableBeanFactory()),\n                new ExpressionValueMethodArgumentResolver(context.getDefaultListableBeanFactory()),\n                new ServletRequestMethodArgumentResolver(),\n                new ServletModelAttributeMethodProcessor(false),\n                new RequestResponseBodyMethodProcessor(List.of(new MappingJackson2HttpMessageConverter())),\n                new ServletModelAttributeMethodProcessor(true),\n                new RequestParamMethodArgumentResolver(context.getDefaultListableBeanFactory(), true)\n        );\n        return composite;\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nfoo\n{user=User{name='张三'}, org.springframework.validation.BindingResult.user=org.springframework.validation.BeanPropertyBindingResult: 0 errors}\n```\n\n发现调用了目标方法，并且将`@ModelAttribute`注解解析的数据放入了`Model`中。\n\n# @ModelAttribute注解\n\n`@ModelAttribute`注解可以在三个地方使用：\n\n1. 添加到`Controller`中的方法参数列表上：\n\n```Java\n@Controller\nstatic class Controller1 {\n    @ResponseStatus(HttpStatus.OK)\n    public ModelAndView foo(@ModelAttribute(\"u\") User user) {\n        System.out.println(\"foo\");\n        return null;\n    }\n}\n```\n\n这种方式由参数解析器`ServletModelAttributeMethodProcessor`解析。\n\n2. 添加到`ControllerAdvice`中的方法上，对于全局都有效：\n\n```Java\n@ControllerAdvice\nstatic class MyControllerAdvice {\n    @ModelAttribute(\"a\")\n    public String aa() {\n        return \"aa\";\n    }\n}\n```\n\n这种方式由`RequestMappingHandlerAdapter`来解析。\n\n3. 添加到`Controller`中的方法上，对于当前`Controller`有效：\n\n```Java\n@Controller\nstatic class Controller1 {\n    @ModelAttribute(\"b\")\n    public String aa() {\n        return \"bb\";\n    }\n}\n```\n\n这种方式由`RequestMappingHandlerAdapter`来解析。\n\n以上几种方式的功能一样，都是解析数据并添加到`ModelAndViewContainer`中。\n\n准备代码示例：\n\n```Java\n/**\n* 配置类\n*/\n@Configuration\npublic class WebConfig {\n\n    @ControllerAdvice\n    static class MyControllerAdvice {\n        @ModelAttribute(\"a\")\n        public String aa() {\n            return \"aa\";\n        }\n    }\n\n    @Controller\n    static class Controller1 {\n        @ModelAttribute(\"b\")\n        public String aa() {\n            return \"bb\";\n        }\n\n        @ResponseStatus(HttpStatus.OK)\n        public ModelAndView foo(@ModelAttribute(\"u\") User user) {\n            System.out.println(\"foo\");\n            return null;\n        }\n    }\n\n    static class User {\n        private String name;\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n\n            return name;\n        }\n\n        @Override\n        public String toString() {\n            return \"User{\" +\n                   \"name='\" + name + '\\'' +\n                   '}';\n        }\n    }\n}\n\n/**\n* 启动类\n*/\npublic class A26 {\n\n    public static void main(String[] args) throws Exception {\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(WebConfig.class);\n\n        RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter();\n        adapter.setApplicationContext(context);\n        // 将会初始化ControllerAdviceCache\n        adapter.afterPropertiesSet();\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setParameter(\"name\", \"张三\");\n        // 现在可以通过 ServletInvocableHandlerMethod 把这些整合在一起, 并完成控制器方法的调用, 如下\n        ServletInvocableHandlerMethod handlerMethod = new ServletInvocableHandlerMethod(\n                new Controller1(), Controller1.class.getMethod(\"foo\", User.class));\n        ServletRequestDataBinderFactory factory = new ServletRequestDataBinderFactory(null, null);\n        handlerMethod.setDataBinderFactory(factory);\n        handlerMethod.setParameterNameDiscoverer(new DefaultParameterNameDiscoverer());\n        handlerMethod.setHandlerMethodArgumentResolvers(getArgumentResolvers(context));\n        ModelAndViewContainer container = new ModelAndViewContainer();\n        // 获取模型工厂方法\n        Method getModelFactory = RequestMappingHandlerAdapter.class.getDeclaredMethod(\"getModelFactory\", HandlerMethod.class, WebDataBinderFactory.class);\n        getModelFactory.setAccessible(true);\n        ModelFactory modelFactory = (ModelFactory) getModelFactory.invoke(adapter, handlerMethod, factory);\n        // 初始化模型数据\n        modelFactory.initModel(new ServletWebRequest(request), container, handlerMethod);\n        handlerMethod.invokeAndHandle(new ServletWebRequest(request), container);\n        System.out.println(container.getModel());\n        context.close();\n    }\n\n    public static HandlerMethodArgumentResolverComposite getArgumentResolvers(AnnotationConfigApplicationContext context) {\n        HandlerMethodArgumentResolverComposite composite = new HandlerMethodArgumentResolverComposite();\n        // 添加参数解析器\n        composite.addResolvers(\n                new RequestParamMethodArgumentResolver(context.getDefaultListableBeanFactory(), false),\n                new PathVariableMethodArgumentResolver(),\n                new RequestHeaderMethodArgumentResolver(context.getDefaultListableBeanFactory()),\n                new ServletCookieValueMethodArgumentResolver(context.getDefaultListableBeanFactory()),\n                new ExpressionValueMethodArgumentResolver(context.getDefaultListableBeanFactory()),\n                new ServletRequestMethodArgumentResolver(),\n                new ServletModelAttributeMethodProcessor(false),\n                new RequestResponseBodyMethodProcessor(List.of(new MappingJackson2HttpMessageConverter())),\n                new ServletModelAttributeMethodProcessor(true),\n                new RequestParamMethodArgumentResolver(context.getDefaultListableBeanFactory(), true)\n        );\n        return composite;\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nfoo\n{a=aa, b=bb, u=User{name='张三'}, org.springframework.validation.BindingResult.u=org.springframework.validation.BeanPropertyBindingResult: 0 errors}\n```\n\n所有的`@ModelAttribute`注解都已经被解析。\n\n# 返回值处理器\n\n`RequestMappingHandlerAdapter`自带的返回值处理器：\n\n```Plain\norg.springframework.web.servlet.mvc.method.annotation.ModelAndViewMethodReturnValueHandler@1f44ddab\norg.springframework.web.method.annotation.ModelMethodProcessor@5017e1\norg.springframework.web.servlet.mvc.method.annotation.ViewMethodReturnValueHandler@65b66b08\norg.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler@4726927c\norg.springframework.web.servlet.mvc.method.annotation.StreamingResponseBodyReturnValueHandler@7eb6b6b6\norg.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor@7ed9499e\norg.springframework.web.servlet.mvc.method.annotation.HttpHeadersReturnValueHandler@28e19366\norg.springframework.web.servlet.mvc.method.annotation.CallableMethodReturnValueHandler@5b275174\norg.springframework.web.servlet.mvc.method.annotation.DeferredResultMethodReturnValueHandler@10ef5fa0\norg.springframework.web.servlet.mvc.method.annotation.AsyncTaskMethodReturnValueHandler@244e619a\norg.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor@10acd6\norg.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor@61dde151\norg.springframework.web.servlet.mvc.method.annotation.ViewNameMethodReturnValueHandler@b25b095\norg.springframework.web.method.annotation.MapMethodProcessor@5cb042da\norg.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor@59c33386\n```\n\n准备测试代码：\n\n```Java\n/**\n* 模板解析配置\n*/\n@Configuration\npublic class WebConfig {\n\n    @Bean\n    public FreeMarkerConfigurer freeMarkerConfigurer() {\n        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n        configurer.setDefaultEncoding(\"utf-8\");\n        configurer.setTemplateLoaderPath(\"classpath:templates\");\n        return configurer;\n    }\n\n    @Bean // FreeMarkerView 在借助 Spring 初始化时，会要求 web 环境才会走 setConfiguration, 这里想办法去掉了 web 环境的约束\n    public FreeMarkerViewResolver viewResolver(FreeMarkerConfigurer configurer) {\n        FreeMarkerViewResolver resolver = new FreeMarkerViewResolver() {\n            @Override\n            protected AbstractUrlBasedView instantiateView() {\n                FreeMarkerView view = new FreeMarkerView() {\n                    @Override\n                    protected boolean isContextRequired() {\n                        return false;\n                    }\n                };\n                view.setConfiguration(configurer.getConfiguration());\n                return view;\n            }\n        };\n        resolver.setContentType(\"text/html;charset=utf-8\");\n        resolver.setPrefix(\"/\");\n        resolver.setSuffix(\".ftl\");\n        resolver.setExposeSpringMacroHelpers(false);\n        return resolver;\n    }\n}\n\n/**\n* 启动类\n*/\npublic class A27 {\n    private static final Logger log = LoggerFactory.getLogger(A27.class);\n\n    public static void main(String[] args) throws Exception {\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(WebConfig.class);\n        // 测试参数解析器\n        testXxx(context);\n    }\n\n    public static HandlerMethodReturnValueHandlerComposite getReturnValueHandler() {\n        HandlerMethodReturnValueHandlerComposite composite = new HandlerMethodReturnValueHandlerComposite();\n        composite.addHandler(new ModelAndViewMethodReturnValueHandler());\n        composite.addHandler(new ViewNameMethodReturnValueHandler());\n        composite.addHandler(new ServletModelAttributeMethodProcessor(false));\n        composite.addHandler(new HttpEntityMethodProcessor(List.of(new MappingJackson2HttpMessageConverter())));\n        composite.addHandler(new HttpHeadersReturnValueHandler());\n        composite.addHandler(new RequestResponseBodyMethodProcessor(List.of(new MappingJackson2HttpMessageConverter())));\n        composite.addHandler(new ServletModelAttributeMethodProcessor(true));\n        return composite;\n    }\n\n    @SuppressWarnings(\"all\")\n    private static void renderView(AnnotationConfigApplicationContext context, ModelAndViewContainer container,\n                                   ServletWebRequest webRequest) throws Exception {\n        log.debug(\">>>>>> 渲染视图\");\n        FreeMarkerViewResolver resolver = context.getBean(FreeMarkerViewResolver.class);\n        String viewName = container.getViewName() != null ? container.getViewName() : new DefaultRequestToViewNameTranslator().getViewName(webRequest.getRequest());\n        log.debug(\"没有获取到视图名, 采用默认视图名: {}\", viewName);\n        // 每次渲染时, 会产生新的视图对象, 它并非被 Spring 所管理, 但确实借助了 Spring 容器来执行初始化\n        View view = resolver.resolveViewName(viewName, Locale.getDefault());\n        view.render(container.getModel(), webRequest.getRequest(), webRequest.getResponse());\n        System.out.println(new String(((MockHttpServletResponse) webRequest.getResponse()).getContentAsByteArray(), StandardCharsets.UTF_8));\n    }\n\n    static class Controller {\n        private static final Logger log = LoggerFactory.getLogger(Controller.class);\n\n        public ModelAndView test1() {\n            log.debug(\"test1()\");\n            ModelAndView mav = new ModelAndView(\"view1\");\n            mav.addObject(\"name\", \"张三\");\n            return mav;\n        }\n\n        public String test2() {\n            log.debug(\"test2()\");\n            return \"view2\";\n        }\n\n        @ModelAttribute\n//        @RequestMapping(\"/test3\")\n        public User test3() {\n            log.debug(\"test3()\");\n            return new User(\"李四\", 20);\n        }\n\n        public User test4() {\n            log.debug(\"test4()\");\n            return new User(\"王五\", 30);\n        }\n\n        public HttpEntity<User> test5() {\n            log.debug(\"test5()\");\n            return new HttpEntity<>(new User(\"赵六\", 40));\n        }\n\n        public HttpHeaders test6() {\n            log.debug(\"test6()\");\n            HttpHeaders headers = new HttpHeaders();\n            headers.add(\"Content-Type\", \"text/html\");\n            return headers;\n        }\n\n        @ResponseBody\n        public User test7() {\n            log.debug(\"test7()\");\n            return new User(\"钱七\", 50);\n        }\n    }\n\n    // 必须用 public 修饰, 否则 freemarker 渲染其 name, age 属性时失败\n    public static class User {\n        private String name;\n        private int age;\n\n        public User(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n\n        public void setAge(int age) {\n            this.age = age;\n        }\n\n        @Override\n        public String toString() {\n            return \"User{\" +\n                   \"name='\" + name + '\\'' +\n                   \", age=\" + age +\n                   '}';\n        }\n    }\n}\n```\n\n`templates`代码：\n\n```HTML\n<!--test3.ftl-->\n<!doctype html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>test3</title>\n</head>\n<body>\n    <h1>Hello! ${user.name} ${user.age}</h1>\n</body>\n</html>\n\n\n<!--test4.ftl-->\n<!doctype html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>test4</title>\n</head>\n<body>\n    <h1>Hello! ${user.name} ${user.age}</h1>\n</body>\n</html>\n\n<!--view1.ftl-->\n<!doctype html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>view1</title>\n</head>\n<body>\n    <h1>Hello! ${name}</h1>\n</body>\n</html>\n\n<!--view2.ftl-->\n<!doctype html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>view2</title>\n</head>\n<body>\n    <h1>Hello!</h1>\n</body>\n</html>\n```\n\n**ModelAndViewMethodReturnValueHandler**\n\n`ModelAndViewMethodReturnValueHandler`解析模型和视图，跳转到视图并且根据模型数据渲染视图。\n\n添加测试方法：\n\n```Java\n/**\n * 1. 测试返回值类型为 ModelAndView\n * @param context\n * @throws Exception\n */\nprivate static void test1(AnnotationConfigApplicationContext context) throws Exception {\n    Method method = Controller.class.getMethod(\"test1\");\n    Controller controller = new Controller();\n    Object returnValue = method.invoke(controller); // 获取返回值\n\n    HandlerMethod methodHandle = new HandlerMethod(controller, method);\n\n    ModelAndViewContainer container = new ModelAndViewContainer();\n    HandlerMethodReturnValueHandlerComposite composite = getReturnValueHandler();\n    ServletWebRequest webRequest = new ServletWebRequest(new MockHttpServletRequest(), new MockHttpServletResponse());\n    if (composite.supportsReturnType(methodHandle.getReturnType())) { // 检查是否支持此类型的返回值\n        composite.handleReturnValue(returnValue, methodHandle.getReturnType(), container, webRequest);\n        System.out.println(container.getModel());\n        System.out.println(container.getViewName());\n        renderView(context, container, webRequest); // 渲染视图\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 21:01:41.269 [main] com.itheima.a27.A27$Controller      - test1() \n{name=张三}\nview1\n[DEBUG] 21:01:41.616 [main] com.itheima.a27.A27                 - >>>>>> 渲染视图 \n[DEBUG] 21:01:41.617 [main] com.itheima.a27.A27                 - 没有获取到视图名, 采用默认视图名: view1 \n[DEBUG] 21:01:41.667 [main] com.itheima.a27.WebConfig$1$1       - View name 'view1', model {name=张三} \n[DEBUG] 21:01:41.673 [main] com.itheima.a27.WebConfig$1$1       - Rendering [/view1.ftl] \n<!doctype html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>view1</title>\n</head>\n<body>\n    <h1>Hello! 张三</h1>\n</body>\n</html>\n```\n\n发现能成功解析返回值并渲染视图。\n\n**ViewNameMethodReturnValueHandler**\n\n`ViewNameMethodReturnValueHandler`解析视图，跳转到对应的视图。\n\n添加测试方法：\n\n```Java\n/**\n * 2. 测试返回值类型为 String 时, 把它当做视图名\n * @param context\n * @throws Exception\n */\nprivate static void test2(AnnotationConfigApplicationContext context) throws Exception {\n    Method method = Controller.class.getMethod(\"test2\");\n    Controller controller = new Controller();\n    Object returnValue = method.invoke(controller); // 获取返回值\n\n    HandlerMethod methodHandle = new HandlerMethod(controller, method);\n\n    ModelAndViewContainer container = new ModelAndViewContainer();\n    HandlerMethodReturnValueHandlerComposite composite = getReturnValueHandler();\n    ServletWebRequest webRequest = new ServletWebRequest(new MockHttpServletRequest(), new MockHttpServletResponse());\n    if (composite.supportsReturnType(methodHandle.getReturnType())) { // 检查是否支持此类型的返回值\n        composite.handleReturnValue(returnValue, methodHandle.getReturnType(), container, webRequest);\n        System.out.println(container.getModel());\n        System.out.println(container.getViewName());\n        renderView(context, container, webRequest); // 渲染视图\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 21:07:58.480 [main] com.itheima.a27.A27$Controller      - test2() \n{}\nview2\n[DEBUG] 21:07:59.284 [main] com.itheima.a27.A27                 - >>>>>> 渲染视图 \n[DEBUG] 21:07:59.286 [main] com.itheima.a27.A27                 - 没有获取到视图名, 采用默认视图名: view2 \n[DEBUG] 21:07:59.438 [main] com.itheima.a27.WebConfig$1$1       - View name 'view2', model {} \n[DEBUG] 21:07:59.447 [main] com.itheima.a27.WebConfig$1$1       - Rendering [/view2.ftl] \n<!doctype html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>view2</title>\n</head>\n<body>\n    <h1>Hello!</h1>\n</body>\n</html>\n```\n\n发现成功跳转到`view2`视图。\n\n**ServletModelAttributeMethodProcessor**\n\n`ServletModelAttributeMethodProcessor`解析加在方法上的`@ModelAttribute`注解，跳转视图时按照方法上的`@RequestMapping`注解的值为准，这里没有`@RequestMapping`注解的解析环境，因此手动去添加视图。\n\n添加测试方法：\n\n```Java\n/**\n * 3. 测试返回值添加了 @ModelAttribute 注解时, 此时需找到默认视图名\n * @param context\n * @throws Exception\n */\nprivate static void test3(AnnotationConfigApplicationContext context) throws Exception {\n    Method method = Controller.class.getMethod(\"test3\");\n    Controller controller = new Controller();\n    Object returnValue = method.invoke(controller); // 获取返回值\n\n    HandlerMethod methodHandle = new HandlerMethod(controller, method);\n\n    ModelAndViewContainer container = new ModelAndViewContainer();\n    HandlerMethodReturnValueHandlerComposite composite = getReturnValueHandler();\n    MockHttpServletRequest request = new MockHttpServletRequest();\n    // 视图解析时使用此名称\n    request.setRequestURI(\"/test3\");\n    UrlPathHelper.defaultInstance.resolveAndCacheLookupPath(request);\n    ServletWebRequest webRequest = new ServletWebRequest(request, new MockHttpServletResponse());\n    if (composite.supportsReturnType(methodHandle.getReturnType())) { // 检查是否支持此类型的返回值\n        composite.handleReturnValue(returnValue, methodHandle.getReturnType(), container, webRequest);\n        System.out.println(container.getModel());\n        System.out.println(container.getViewName());\n        renderView(context, container, webRequest); // 渲染视图\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 21:13:27.532 [main] com.itheima.a27.A27$Controller      - test3() \n{user=User{name='李四', age=20}}\nnull\n[DEBUG] 21:13:27.799 [main] com.itheima.a27.A27                 - >>>>>> 渲染视图 \n[DEBUG] 21:13:27.802 [main] com.itheima.a27.A27                 - 没有获取到视图名, 采用默认视图名: test3 \n[DEBUG] 21:13:27.839 [main] com.itheima.a27.WebConfig$1$1       - View name 'test3', model {user=User{name='李四', age=20}} \n[DEBUG] 21:13:27.844 [main] com.itheima.a27.WebConfig$1$1       - Rendering [/test3.ftl] \n<!doctype html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>test3</title>\n</head>\n<body>\n    <h1>Hello! 李四 20</h1>\n</body>\n</html>\n```\n\n在创建`ServletModelAttributeMethodProcessor`对象时，可以传入一个布尔值，如果为true代表可以省略方法上的`@ModelAttribute`注解，如果为false代表不能省略`@ModelAttribute`注解。\n\n**HttpEntityMethodProcessor**\n\n`HttpEntityMethodProcessor`、`HttpHeadersReturnValueHandler`、`RequestResponseBodyMethodProcessor`都是只处理数据，不解析视图，在它们的`handleReturnValue()`方法中，都有以下操作：\n\n```Java\n// 设置为true，因此后续操作不会进行视图解析以及渲染流程\nmavContainer.setRequestHandled(true);\n```\n\n`HttpEntityMethodProcessor`处理器可以返回响应的所有内容，包括响应头、响应体、状态码等。\n\n添加测试方法：\n\n```Java\n/**\n * 5. 测试返回值类型为 ResponseEntity 时, 此时不走视图流程\n * @param context\n * @throws Exception\n */\nprivate static void test5(AnnotationConfigApplicationContext context) throws Exception {\n    Method method = Controller.class.getMethod(\"test5\");\n    Controller controller = new Controller();\n    Object returnValue = method.invoke(controller); // 获取返回值\n\n    HandlerMethod methodHandle = new HandlerMethod(controller, method);\n\n    ModelAndViewContainer container = new ModelAndViewContainer();\n    HandlerMethodReturnValueHandlerComposite composite = getReturnValueHandler();\n    MockHttpServletRequest request = new MockHttpServletRequest();\n    MockHttpServletResponse response = new MockHttpServletResponse();\n    ServletWebRequest webRequest = new ServletWebRequest(request, response);\n    if (composite.supportsReturnType(methodHandle.getReturnType())) { // 检查是否支持此类型的返回值\n        composite.handleReturnValue(returnValue, methodHandle.getReturnType(), container, webRequest);\n        System.out.println(container.getModel());\n        System.out.println(container.getViewName());\n        if (!container.isRequestHandled()) {\n            renderView(context, container, webRequest); // 渲染视图\n        } else {\n            System.out.println(new String(response.getContentAsByteArray(), StandardCharsets.UTF_8));\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 21:25:55.986 [main] com.itheima.a27.A27$Controller      - test5() \n{}\nnull\n{\"name\":\"赵六\",\"age\":40}\n```\n\n发现模型与视图都为空，而返回值为`json`格式的数据。\n\n**HttpHeadersReturnValueHandler**\n\n`HttpHeadersReturnValueHandler`主要解析响应头和状态码。\n\n添加测试方法：\n\n```Java\n/**\n * 6. 测试返回值类型为 HttpHeaders 时, 此时不走视图流程\n * @param context\n * @throws Exception\n */\nprivate static void test6(AnnotationConfigApplicationContext context) throws Exception {\n    Method method = Controller.class.getMethod(\"test6\");\n    Controller controller = new Controller();\n    Object returnValue = method.invoke(controller); // 获取返回值\n\n    HandlerMethod methodHandle = new HandlerMethod(controller, method);\n\n    ModelAndViewContainer container = new ModelAndViewContainer();\n    HandlerMethodReturnValueHandlerComposite composite = getReturnValueHandler();\n    MockHttpServletRequest request = new MockHttpServletRequest();\n    MockHttpServletResponse response = new MockHttpServletResponse();\n    ServletWebRequest webRequest = new ServletWebRequest(request, response);\n    if (composite.supportsReturnType(methodHandle.getReturnType())) { // 检查是否支持此类型的返回值\n        composite.handleReturnValue(returnValue, methodHandle.getReturnType(), container, webRequest);\n        System.out.println(container.getModel());\n        System.out.println(container.getViewName());\n        if (!container.isRequestHandled()) {\n            renderView(context, container, webRequest); // 渲染视图\n        } else {\n            for (String name : response.getHeaderNames()) {\n                System.out.println(name + \"=\" + response.getHeader(name));\n            }\n            System.out.println(new String(response.getContentAsByteArray(), StandardCharsets.UTF_8));\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 21:28:51.932 [main] com.itheima.a27.A27$Controller      - test6() \n{}\nnull\nContent-Type=text/html\n```\n\n发现模型与视图都为空，而响应头中的内容以及被打印。\n\n**RequestResponseBodyMethodProcessor**\n\n```\nRequestResponseBodyMethodProcessor`主要解析响应体内容，它会默认在响应头中给我们添加`Content-Type=application/json\n```\n\n添加测试方法：\n\n```Java\n/**\n * 7. 测试返回值添加了 @ResponseBody 注解时, 此时不走视图流程\n * @param context\n * @throws Exception\n */\nprivate static void test7(AnnotationConfigApplicationContext context) throws Exception {\n    Method method = Controller.class.getMethod(\"test7\");\n    Controller controller = new Controller();\n    Object returnValue = method.invoke(controller); // 获取返回值\n\n    HandlerMethod methodHandle = new HandlerMethod(controller, method);\n\n    ModelAndViewContainer container = new ModelAndViewContainer();\n    HandlerMethodReturnValueHandlerComposite composite = getReturnValueHandler();\n    MockHttpServletRequest request = new MockHttpServletRequest();\n    MockHttpServletResponse response = new MockHttpServletResponse();\n    ServletWebRequest webRequest = new ServletWebRequest(request, response);\n    if (composite.supportsReturnType(methodHandle.getReturnType())) { // 检查是否支持此类型的返回值\n        composite.handleReturnValue(returnValue, methodHandle.getReturnType(), container, webRequest);\n        System.out.println(container.getModel());\n        System.out.println(container.getViewName());\n        if (!container.isRequestHandled()) {\n            renderView(context, container, webRequest); // 渲染视图\n        } else {\n            for (String name : response.getHeaderNames()) {\n                System.out.println(name + \"=\" + response.getHeader(name));\n            }\n            System.out.println(new String(response.getContentAsByteArray(), StandardCharsets.UTF_8));\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 21:30:50.557 [main] com.itheima.a27.A27$Controller      - test7() \n{}\nnull\nContent-Type=application/json\n{\"name\":\"钱七\",\"age\":50}\n```\n\n# **MessageConverter**\n\n在学习`HttpEntityMethodProcessor`处理器和`RequestResponseBodyMethodProcessor`时，创建这两个处理器我们都会添加一个`MappingJackson2HttpMessageConverter`。`MappingJackson2HttpMessageConverter`的作用是将返回值转换为`json`格式。\n\n测试`MessageConverter`的用法，准备实体类：\n\n```Java\npublic static class User {\n    private String name;\n    private int age;\n\n    @JsonCreator\n    public User(@JsonProperty(\"name\") String name, @JsonProperty(\"age\") int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n               \"name='\" + name + '\\'' +\n               \", age=\" + age +\n               '}';\n    }\n}\n```\n\n1. 测试将对象转化为json格式：\n\n```Java\npublic static void test1() throws IOException {\n    MockHttpOutputMessage message = new MockHttpOutputMessage();\n    MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();\n    if (converter.canWrite(User.class, MediaType.APPLICATION_JSON)) {\n        converter.write(new User(\"张三\", 18), MediaType.APPLICATION_JSON, message);\n        System.out.println(message.getBodyAsString());\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n{\"name\":\"张三\",\"age\":18}\n```\n\n2. 测试将对象转为`xml`格式：\n\n```Java\nprivate static void test2() throws IOException {\n    MockHttpOutputMessage message = new MockHttpOutputMessage();\n    MappingJackson2XmlHttpMessageConverter converter = new MappingJackson2XmlHttpMessageConverter();\n    if (converter.canWrite(User.class, MediaType.APPLICATION_XML)) {\n        converter.write(new User(\"李四\", 20), MediaType.APPLICATION_XML, message);\n        System.out.println(message.getBodyAsString());\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n<User><name>李四</name><age>20</age></User>\n```\n\n3. 测试将`json`格式数据转换为`java`对象：\n\n```Java\nprivate static void test3() throws IOException {\n    MockHttpInputMessage message = new MockHttpInputMessage(\"\"\"\n            {\n                \"name\":\"李四\",\n                \"age\":20\n            }\n            \"\"\".getBytes(StandardCharsets.UTF_8));\n    MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();\n    if (converter.canRead(User.class, MediaType.APPLICATION_JSON)) {\n        Object read = converter.read(User.class, message);\n        System.out.println(read);\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nUser{name='李四', age=20}\n```\n\n如果添加了多个`MessageConverter`，会以那种优先呢？\n\n添加方法：\n\n```Java\n@ResponseBody\npublic User user() {\n    return null;\n}\n```\n\n添加测试方法：\n\n```Java\nprivate static void test4() throws IOException, HttpMediaTypeNotAcceptableException, NoSuchMethodException {\n    MockHttpServletRequest request = new MockHttpServletRequest();\n    MockHttpServletResponse response = new MockHttpServletResponse();\n    ServletWebRequest webRequest = new ServletWebRequest(request, response);\n\n    RequestResponseBodyMethodProcessor processor = new RequestResponseBodyMethodProcessor(\n            List.of(\n                    new MappingJackson2HttpMessageConverter(), new MappingJackson2XmlHttpMessageConverter()\n            ));\n    processor.handleReturnValue(\n            new User(\"张三\", 18),\n            new MethodParameter(A28.class.getMethod(\"user\"), -1),\n            new ModelAndViewContainer(),\n            webRequest\n    );\n    System.out.println(new String(response.getContentAsByteArray(), StandardCharsets.UTF_8));\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n{\"name\":\"张三\",\"age\":18}\n```\n\n在默认情况下，按照`MessageConverter`添加的次序进行解析。\n\n如果将`MappingJackson2XmlHttpMessageConverter`放在前面：\n\n```Java\nRequestResponseBodyMethodProcessor processor = new RequestResponseBodyMethodProcessor(\n        List.of(\n                new MappingJackson2XmlHttpMessageConverter(), new MappingJackson2HttpMessageConverter()\n        ));\n```\n\n运行启动类，查看控制台：\n\n```Plain\n<User><name>张三</name><age>18</age></User>\n```\n\n如果在请求头中添加可接受的格式，例如：\n\n```Java\nrequest.addHeader(\"Accept\", \"application/xml\");\n```\n\n那么不论`MessageConverter`的次序如何，都会返回`xml`格式的数据。\n\n如果在响应头中设置了`ContentType`格式，那么按照`ContentType`设置的格式返回，其优先级比请求头中的`Accept`高，例如：\n\n```Java\nresponse.setContentType(\"application/json\");\n```\n\n此时会以`json`格式的数据返回。\n\n返回值处理器如何选择`MediaType`：\n\n1. 首先看`@RequestMapping`上有没有指定(这种情况由于没有环境没有进行测试)\n2. 其次看`request`的`Accept`头有没有指定\n3. 最后按`MessageConverter`的顺序, 谁能谁先转换\n\n# ResponseBodyAdvice\n\n一般在编写`controller`时，我们都会统一将返回值封装成一个`Result`对象，包含状态码，消息，数据等。例如：\n\n```Java\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class Result {\n    private int code;\n    private String msg;\n    private Object data;\n\n    public int getCode() {\n        return code;\n    }\n\n    public void setCode(int code) {\n        this.code = code;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n\n    public Object getData() {\n        return data;\n    }\n\n    public void setData(Object data) {\n        this.data = data;\n    }\n\n    @JsonCreator\n    private Result(@JsonProperty(\"code\") int code, @JsonProperty(\"data\") Object data) {\n        this.code = code;\n        this.data = data;\n    }\n\n    private Result(int code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    public static Result ok() {\n        return new Result(200, null);\n    }\n\n    public static Result ok(Object data) {\n        return new Result(200, data);\n    }\n\n    public static Result error(String msg) {\n        return new Result(500, \"服务器内部错误:\" + msg);\n    }\n}\n```\n\n这种约定的返回方式非常常用，当然也有其他方式可以实现，将返回值封装为一个`Result`对象。我们可以使用`@ControllerAdvice`注解对响应体进行增强。\n\n对返回值的增强需要实现`ResponseBodyAdvice`接口，其中有两个方法：\n\n1. `supports()`：判断是否需要增强返回值\n2. `beforeBodyWrite()`：增强返回值的具体逻辑\n\n编写配置类：\n\n```Java\n@Configuration\npublic class WebConfig {\n\n    @ControllerAdvice\n    static class MyControllerAdvice implements ResponseBodyAdvice<Object> {\n        // 满足条件才转换 \n        public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {\n            // 判断方法上的注解||判断类上的注解以及注解中包含的注解\n            if (returnType.getMethodAnnotation(ResponseBody.class) != null ||\n                AnnotationUtils.findAnnotation(returnType.getContainingClass(), ResponseBody.class) != null) {\n                return true;\n            }\n            return false;\n        }\n\n        // 将 User 或其它类型统一为 Result 类型\n        public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class<? extends HttpMessageConverter<?>> selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {\n            if (body instanceof Result) {\n                return body;\n            }\n            return Result.ok(body);\n        }\n    }\n\n    // @Controller\n    // @ResponseBody\n    @RestController\n    public static class MyController {\n        public User user() {\n            return new User(\"王五\", 18);\n        }\n    }\n\n    public static class User {\n        private String name;\n        private int age;\n\n        public User(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n\n        public void setAge(int age) {\n            this.age = age;\n        }\n    }\n}\n```\n\n编写启动类：\n\n```Java\npublic class A29 {\n\n    public static void main(String[] args) throws Exception {\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(WebConfig.class);\n\n        ServletInvocableHandlerMethod handlerMethod = new ServletInvocableHandlerMethod(\n                context.getBean(WebConfig.MyController.class),\n                WebConfig.MyController.class.getMethod(\"user\")\n        );\n        handlerMethod.setDataBinderFactory(new ServletRequestDataBinderFactory(Collections.emptyList(), null));\n        handlerMethod.setParameterNameDiscoverer(new DefaultParameterNameDiscoverer());\n        handlerMethod.setHandlerMethodArgumentResolvers(getArgumentResolvers(context));\n        handlerMethod.setHandlerMethodReturnValueHandlers(getReturnValueHandlers(context));\n\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        MockHttpServletResponse response = new MockHttpServletResponse();\n        ModelAndViewContainer container = new ModelAndViewContainer();\n        handlerMethod.invokeAndHandle(new ServletWebRequest(request, response), container);\n\n        System.out.println(new String(response.getContentAsByteArray(), StandardCharsets.UTF_8));\n    }\n\n    public static HandlerMethodArgumentResolverComposite getArgumentResolvers(AnnotationConfigApplicationContext context) {\n        HandlerMethodArgumentResolverComposite composite = new HandlerMethodArgumentResolverComposite();\n        composite.addResolvers(\n                new RequestParamMethodArgumentResolver(context.getDefaultListableBeanFactory(), false),\n                new PathVariableMethodArgumentResolver(),\n                new RequestHeaderMethodArgumentResolver(context.getDefaultListableBeanFactory()),\n                new ServletCookieValueMethodArgumentResolver(context.getDefaultListableBeanFactory()),\n                new ExpressionValueMethodArgumentResolver(context.getDefaultListableBeanFactory()),\n                new ServletRequestMethodArgumentResolver(),\n                new ServletModelAttributeMethodProcessor(false),\n                new RequestResponseBodyMethodProcessor(List.of(new MappingJackson2HttpMessageConverter())),\n                new ServletModelAttributeMethodProcessor(true),\n                new RequestParamMethodArgumentResolver(context.getDefaultListableBeanFactory(), true)\n        );\n        return composite;\n    }\n\n    public static HandlerMethodReturnValueHandlerComposite getReturnValueHandlers(AnnotationConfigApplicationContext context) {\n        // 添加 advice\n        List<ControllerAdviceBean> annotatedBeans = ControllerAdviceBean.findAnnotatedBeans(context);\n        List<Object> collect = annotatedBeans.stream().filter(b -> ResponseBodyAdvice.class.isAssignableFrom(b.getBeanType()))\n                .collect(Collectors.toList());\n\n        HandlerMethodReturnValueHandlerComposite composite = new HandlerMethodReturnValueHandlerComposite();\n        composite.addHandler(new ModelAndViewMethodReturnValueHandler());\n        composite.addHandler(new ViewNameMethodReturnValueHandler());\n        composite.addHandler(new ServletModelAttributeMethodProcessor(false));\n        composite.addHandler(new HttpEntityMethodProcessor(List.of(new MappingJackson2HttpMessageConverter())));\n        composite.addHandler(new HttpHeadersReturnValueHandler());\n        composite.addHandler(new RequestResponseBodyMethodProcessor(List.of(new MappingJackson2HttpMessageConverter()), collect));\n        composite.addHandler(new ServletModelAttributeMethodProcessor(true));\n        return composite;\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n{\"code\":200,\"data\":{\"name\":\"王五\",\"age\":18}}\n```\n\n发现返回值的格式已经被重新封装。\n\n# **异常解析器**\n\n`DispatcherServlet`的核心流程在`doDispatch()`方法内：\n\n```Java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n        try {\n            ModelAndView mv = null;\n            Exception dispatchException = null;\n\n            try {\n                processedRequest = this.checkMultipart(request);\n                multipartRequestParsed = processedRequest != request;\n                mappedHandler = this.getHandler(processedRequest);\n                if (mappedHandler == null) {\n                    this.noHandlerFound(processedRequest, response);\n                    return;\n                }\n\n                HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());\n                String method = request.getMethod();\n                boolean isGet = HttpMethod.GET.matches(method);\n                if (isGet || HttpMethod.HEAD.matches(method)) {\n                    long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                    if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) {\n                        return;\n                    }\n                }\n\n                if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n                    return;\n                }\n\n                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n                if (asyncManager.isConcurrentHandlingStarted()) {\n                    return;\n                }\n\n                this.applyDefaultViewName(processedRequest, mv);\n                mappedHandler.applyPostHandle(processedRequest, response, mv);\n            } catch (Exception var20) {\n                dispatchException = var20;\n            } catch (Throwable var21) {\n                dispatchException = new NestedServletException(\"Handler dispatch failed\", var21);\n            }\n\n            this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);\n        } catch (Exception var22) {\n            this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);\n        } catch (Throwable var23) {\n            this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", var23));\n        }\n\n    } finally {\n        if (asyncManager.isConcurrentHandlingStarted()) {\n            if (mappedHandler != null) {\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n            }\n        } else if (multipartRequestParsed) {\n            this.cleanupMultipart(processedRequest);\n        }\n\n    }\n}\n```\n\n在发生异常时，只是将异常记录在`dispatchException`变量内，并不直接抛出，最后在`processDispatchResult()`内进行处理。\n\n我们查看`processDispatchResult()`方法：\n\n```Java\nprivate void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception {\n    boolean errorView = false;\n    if (exception != null) {\n        if (exception instanceof ModelAndViewDefiningException) {\n            this.logger.debug(\"ModelAndViewDefiningException encountered\", exception);\n            mv = ((ModelAndViewDefiningException)exception).getModelAndView();\n        } else {\n            Object handler = mappedHandler != null ? mappedHandler.getHandler() : null;\n            mv = this.processHandlerException(request, response, handler, exception);\n            errorView = mv != null;\n        }\n    }\n\n    if (mv != null && !mv.wasCleared()) {\n        this.render(mv, request, response);\n        if (errorView) {\n            WebUtils.clearErrorRequestAttributes(request);\n        }\n    } else if (this.logger.isTraceEnabled()) {\n        this.logger.trace(\"No view rendering, null ModelAndView returned.\");\n    }\n\n    if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n        if (mappedHandler != null) {\n            mappedHandler.triggerAfterCompletion(request, response, (Exception)null);\n        }\n\n    }\n}\n```\n\n`processDispatchResult()`方法首先判断异常是否为空，如果不为空则处理异常，否则进行正常的视图渲染流程。\n\n我们进入`processHandlerException()`方法：\n\n```Java\n@Nullable\nprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) throws Exception {\n    request.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\n    ModelAndView exMv = null;\n    if (this.handlerExceptionResolvers != null) {\n        Iterator var6 = this.handlerExceptionResolvers.iterator();\n\n        while(var6.hasNext()) {\n            HandlerExceptionResolver resolver = (HandlerExceptionResolver)var6.next();\n            exMv = resolver.resolveException(request, response, handler, ex);\n            if (exMv != null) {\n                break;\n            }\n        }\n    }\n\n    if (exMv != null) {\n        if (exMv.isEmpty()) {\n            request.setAttribute(EXCEPTION_ATTRIBUTE, ex);\n            return null;\n        } else {\n            if (!exMv.hasView()) {\n                String defaultViewName = this.getDefaultViewName(request);\n                if (defaultViewName != null) {\n                    exMv.setViewName(defaultViewName);\n                }\n            }\n\n            if (this.logger.isTraceEnabled()) {\n                this.logger.trace(\"Using resolved error view: \" + exMv, ex);\n            } else if (this.logger.isDebugEnabled()) {\n                this.logger.debug(\"Using resolved error view: \" + exMv);\n            }\n\n            WebUtils.exposeErrorRequestAttributes(request, ex, this.getServletName());\n            return exMv;\n        }\n    } else {\n        throw ex;\n    }\n}\n```\n\n`processHandlerException()`方法遍历`handlerExceptionResolvers`，查找合适的异常处理器进行处理。\n\n```Java\n@Nullable\nprivate List<HandlerExceptionResolver> handlerExceptionResolvers;\n```\n\n`HandlerExceptionResolver`接口有一个重要的实现——`ExceptionHandlerExceptionResolver`。这个解析器就是用来解析`@ExceptionHandler`注解的。\n\n1. 测试处理`json`返回值\n\n编写示例代码：\n\n```Java\npublic class A30 {\n    public static void main(String[] args) throws NoSuchMethodException {\n        ExceptionHandlerExceptionResolver resolver = new ExceptionHandlerExceptionResolver();\n        resolver.setMessageConverters(List.of(new MappingJackson2HttpMessageConverter()));\n        resolver.afterPropertiesSet();\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        MockHttpServletResponse response = new MockHttpServletResponse();\n        // 1.测试 json\n        HandlerMethod handlerMethod = new HandlerMethod(new Controller1(), Controller1.class.getMethod(\"foo\"));\n        Exception e = new ArithmeticException(\"被零除\");\n        resolver.resolveException(request, response, handlerMethod, e);\n        System.out.println(new String(response.getContentAsByteArray(), StandardCharsets.UTF_8));\n    }\n\n    static class Controller1 {\n        public void foo() {\n\n        }\n        @ExceptionHandler\n        @ResponseBody\n        public Map<String, Object> handle(ArithmeticException e) {\n            return Map.of(\"error\", e.getMessage());\n        }\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n{\"error\":\"被零除\"}\n```\n\n发现能正确处理`json`格式的返回值。\n\n2. 测试处理`ModelAndView`返回值\n\n编写示例代码：\n\n```Java\npublic class A30 {\n    public static void main(String[] args) throws NoSuchMethodException {\n        ExceptionHandlerExceptionResolver resolver = new ExceptionHandlerExceptionResolver();\n        resolver.setMessageConverters(List.of(new MappingJackson2HttpMessageConverter()));\n        resolver.afterPropertiesSet();\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        MockHttpServletResponse response = new MockHttpServletResponse();\n        // 2.测试 mav\n        HandlerMethod handlerMethod = new HandlerMethod(new Controller2(), Controller2.class.getMethod(\"foo\"));\n        Exception e = new ArithmeticException(\"被零除\");\n        ModelAndView mav = resolver.resolveException(request, response, handlerMethod, e);\n        System.out.println(mav.getModel());\n        System.out.println(mav.getViewName());\n    }\n\n    static class Controller2 {\n        public void foo() {\n\n        }\n        @ExceptionHandler\n        public ModelAndView handle(ArithmeticException e) {\n            return new ModelAndView(\"test2\", Map.of(\"error\", e.getMessage()));\n        }\n    }\n    \n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n{error=被零除}\ntest2\n```\n\n3. 测试处理嵌套异常的情况\n\n编写示例代码：\n\n```Java\npublic class A30 {\n    public static void main(String[] args) throws NoSuchMethodException {\n        ExceptionHandlerExceptionResolver resolver = new ExceptionHandlerExceptionResolver();\n        resolver.setMessageConverters(List.of(new MappingJackson2HttpMessageConverter()));\n        resolver.afterPropertiesSet();\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        MockHttpServletResponse response = new MockHttpServletResponse();\n        // 3.测试嵌套异常\n        HandlerMethod handlerMethod = new HandlerMethod(new Controller3(), Controller3.class.getMethod(\"foo\"));\n        Exception e = new Exception(\"e1\", new RuntimeException(\"e2\", new IOException(\"e3\")));\n        resolver.resolveException(request, response, handlerMethod, e);\n        System.out.println(new String(response.getContentAsByteArray(), StandardCharsets.UTF_8));\n    }\n\n    static class Controller3 {\n        public void foo() {\n\n        }\n        @ExceptionHandler\n        @ResponseBody\n        public Map<String, Object> handle(IOException e3) {\n            return Map.of(\"error\", e3.getMessage());\n        }\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n{\"error\":\"e3\"}\n```\n\n发现这种嵌套异常的情况也能够正确匹配到异常处理器。\n\n查看`ExceptionHandlerExceptionResolver`类中的`doResolveHandlerMethodException()`方法：\n\n```Java\n//...\nThrowable cause;\nfor(Throwable exToExpose = exception; exToExpose != null; exToExpose = cause != exToExpose ? cause : null) {\n    exceptions.add(exToExpose);\n    cause = ((Throwable)exToExpose).getCause();\n}\n//..\n```\n\n注意这段逻辑，首先拿到最外层异常，然后循环拿到起因异常，最后将所有异常都添加到`exceptions`中，因此它能够处理嵌套异常。\n\n4. 测试异常处理方法参数解析\n\n编写示例代码：\n\n```Java\npublic class A30 {\n    public static void main(String[] args) throws NoSuchMethodException {\n        ExceptionHandlerExceptionResolver resolver = new ExceptionHandlerExceptionResolver();\n        resolver.setMessageConverters(List.of(new MappingJackson2HttpMessageConverter()));\n        resolver.afterPropertiesSet();\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        MockHttpServletResponse response = new MockHttpServletResponse();\n        // 4.测试异常处理方法参数解析\n        HandlerMethod handlerMethod = new HandlerMethod(new Controller4(), Controller4.class.getMethod(\"foo\"));\n        Exception e = new Exception(\"e1\");\n        resolver.resolveException(request, response, handlerMethod, e);\n        System.out.println(new String(response.getContentAsByteArray(), StandardCharsets.UTF_8));\n    }\n\n    static class Controller4 {\n        public void foo() {}\n        @ExceptionHandler\n        @ResponseBody\n        public Map<String, Object> handler(Exception e, HttpServletRequest request) {\n            System.out.println(request);\n            return Map.of(\"error\", e.getMessage());\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\norg.springframework.mock.web.MockHttpServletRequest@60db1c0e\n{\"error\":\"e1\"}\n```\n\n在抛出异常时，也能正确拿到`request`对象。\n\n# @ExceptionHandler注解\n\n`@ControllerAdvice`注解配合`@ExceptionHandler`注解可以实现全局异常处理器，不需要每个`Controller`中都添加`ExceptionHandler`。\n\n编写测试代码：\n\n```Java\n/**\n* 配置类\n*/\n\n@Configuration\npublic class WebConfig {\n    @ControllerAdvice\n    static class MyControllerAdvice {\n        @ExceptionHandler\n        @ResponseBody\n        public Map<String, Object> handle(Exception e) {\n            return Map.of(\"error\", e.getMessage());\n        }\n    }\n\n    @Bean\n    public ExceptionHandlerExceptionResolver resolver() {\n        ExceptionHandlerExceptionResolver resolver = new ExceptionHandlerExceptionResolver();\n        resolver.setMessageConverters(List.of(new MappingJackson2HttpMessageConverter()));\n        return resolver;\n    }\n}\n\n/**\n* 启动类\n*/\npublic class A31 {\n    public static void main(String[] args) throws NoSuchMethodException {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        MockHttpServletResponse response = new MockHttpServletResponse();\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);\n        ExceptionHandlerExceptionResolver resolver = context.getBean(ExceptionHandlerExceptionResolver.class);\n\n        HandlerMethod handlerMethod = new HandlerMethod(new Controller5(), Controller5.class.getMethod(\"foo\"));\n        Exception e = new Exception(\"e1\");\n        resolver.resolveException(request, response, handlerMethod, e);\n        System.out.println(new String(response.getContentAsByteArray(), StandardCharsets.UTF_8));\n    }\n\n    static class Controller5 {\n        public void foo() {\n\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n{\"error\":\"e1\"}\n```\n\n我们发现在`Controller5`中没有添加`ExceptionHandler`，通过全局的`ExceptionHandler`也能处理异常。\n\n异常处理流程：\n\n1. 优先在`Controller`中找`ExceptionHandler`\n2. 其次在全局处理器中找`ExceptionHandler`\n\n查看`ExceptionHandlerExceptionResolver`中的`afterPropertiesSet()`方法：\n\n```Java\npublic void afterPropertiesSet() {\n    this.initExceptionHandlerAdviceCache();\n    List handlers;\n    if (this.argumentResolvers == null) {\n        handlers = this.getDefaultArgumentResolvers();\n        this.argumentResolvers = (new HandlerMethodArgumentResolverComposite()).addResolvers(handlers);\n    }\n\n    if (this.returnValueHandlers == null) {\n        handlers = this.getDefaultReturnValueHandlers();\n        this.returnValueHandlers = (new HandlerMethodReturnValueHandlerComposite()).addHandlers(handlers);\n    }\n\n}\n```\n\n`initExceptionHandlerAdviceCache()`即是处理`@ControllerAdvice`注解标注的配置，进入此方法：\n\n```Java\nprivate void initExceptionHandlerAdviceCache() {\n    if (this.getApplicationContext() != null) {\n        List<ControllerAdviceBean> adviceBeans = ControllerAdviceBean.findAnnotatedBeans(this.getApplicationContext());\n        Iterator var2 = adviceBeans.iterator();\n\n        while(var2.hasNext()) {\n            ControllerAdviceBean adviceBean = (ControllerAdviceBean)var2.next();\n            Class<?> beanType = adviceBean.getBeanType();\n            if (beanType == null) {\n                throw new IllegalStateException(\"Unresolvable type for ControllerAdviceBean: \" + adviceBean);\n            }\n\n            ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(beanType);\n            if (resolver.hasExceptionMappings()) {\n                this.exceptionHandlerAdviceCache.put(adviceBean, resolver);\n            }\n\n            if (ResponseBodyAdvice.class.isAssignableFrom(beanType)) {\n                this.responseBodyAdvice.add(adviceBean);\n            }\n        }\n\n        if (this.logger.isDebugEnabled()) {\n            int handlerSize = this.exceptionHandlerAdviceCache.size();\n            int adviceSize = this.responseBodyAdvice.size();\n            if (handlerSize == 0 && adviceSize == 0) {\n                this.logger.debug(\"ControllerAdvice beans: none\");\n            } else {\n                this.logger.debug(\"ControllerAdvice beans: \" + handlerSize + \" @ExceptionHandler, \" + adviceSize + \" ResponseBodyAdvice\");\n            }\n        }\n\n    }\n}\n```\n\n此方法中获取并添加了`ControllerAdvice`中的`ExceptionHandler`以及`ResponseBody`增强。\n\n# **Tomcat异常处理**\n\n`ControllerAdvice`中的`ExceptionHandler`只能处理`Controller`中抛出的异常，如果是过滤器中抛出的异常，那么`ControllerAdvice`不能处理，因此需要更上一级的异常处理。\n\n测试`tomcat`中默认的异常处理：\n\n```Java\n/**\n* 配置类\n*/\n@Configuration\npublic class WebConfig {\n    @Bean\n    public TomcatServletWebServerFactory servletWebServerFactory() {\n        return new TomcatServletWebServerFactory();\n    }\n\n    @Bean\n    public DispatcherServlet dispatcherServlet() {\n        return new DispatcherServlet();\n    }\n\n    @Bean\n    public DispatcherServletRegistrationBean servletRegistrationBean(DispatcherServlet dispatcherServlet) {\n        DispatcherServletRegistrationBean registrationBean = new DispatcherServletRegistrationBean(dispatcherServlet, \"/\");\n        registrationBean.setLoadOnStartup(1);\n        return registrationBean;\n    }\n\n    @Bean // @RequestMapping\n    public RequestMappingHandlerMapping requestMappingHandlerMapping() {\n        return new RequestMappingHandlerMapping();\n    }\n\n    @Bean // 注意默认的 RequestMappingHandlerAdapter 不会带 jackson 转换器\n    public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {\n        RequestMappingHandlerAdapter handlerAdapter = new RequestMappingHandlerAdapter();\n        handlerAdapter.setMessageConverters(List.of(new MappingJackson2HttpMessageConverter()));\n        return handlerAdapter;\n    }\n\n    @Bean\n    public ErrorPageRegistrarBeanPostProcessor errorPageRegistrarBeanPostProcessor() {\n        return new ErrorPageRegistrarBeanPostProcessor();\n    }\n\n    @Controller\n    public static class MyController {\n        @RequestMapping(\"test\")\n        public ModelAndView test() {\n            int i = 1 / 0;\n            return null;\n        }\n    }\n\n}\n\n/**\n* 启动类\n*/\npublic class A32 {\n\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n        AnnotationConfigServletWebServerApplicationContext context =\n                new AnnotationConfigServletWebServerApplicationContext(WebConfig.class);\n        RequestMappingHandlerMapping handlerMapping = context.getBean(RequestMappingHandlerMapping.class);\n        handlerMapping.getHandlerMethods().forEach((RequestMappingInfo k, HandlerMethod v) -> {\n            System.out.println(\"映射路径:\" + k + \"\\t方法信息:\" + v);\n        });\n    }\n}\n```\n\n运行启动类，访问localhost:8080/test，浏览器上出现以下页面：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%91%EF%BC%9AWEB/8.png)\n\n说明`tomcat`是有默认的异常的异常处理以及跳转逻辑的。\n\n为了提高用户体验，一般来讲需要返回`json`格式的错误信息，因此我们需要自定义异常处理。\n\n自定义异常处理：\n\n修改`Tomcat`服务器默认错误转发地址，添加以下`Bean`：\n\n```Java\n@Bean\npublic ErrorPageRegistrar errorPageRegistrar() { // 出现错误，会使用请求转发 forward 跳转到 error 地址\n    return webServerFactory -> webServerFactory.addErrorPages(new ErrorPage(\"/error\"));\n}\n```\n\n添加`ErrorPageRegistrarBeanPostProcessor`，这个Bean将会回调`webServerFactory`的`addErrorPages()`方法，去真正执行修改错误页面的动作：\n\n```Java\n@Bean\npublic ErrorPageRegistrarBeanPostProcessor errorPageRegistrarBeanPostProcessor() {\n    return new ErrorPageRegistrarBeanPostProcessor();\n}\n```\n\n添加`Controller`方法，返回`json`格式的数据：\n\n```Java\n@RequestMapping(\"/error\")\n@ResponseBody\npublic Map<String, Object> error(HttpServletRequest request) {\n    Throwable e = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);\n    return Map.of(\"error\", e.getMessage());\n}\n```\n\n运行启动类，访问localhost:8080/test，浏览器上出现以下输出：\n\n```Plain\n{\n\"error\": \"Request processing failed; nested exception is java.lang.ArithmeticException: / by zero\"\n}\n```\n\n成功将我们的错误信息以`json`格式返回。\n\n除了通过`tomcat`提供的方式自定义异常处理，`springboot`中也提供了`BasicErrorController`支持我们自定义异常处理。\n\n查看`BasicErrorController`源码：\n\n```Java\n@Controller\n@RequestMapping({\"${server.error.path:${error.path:/error}}\"})\npublic class BasicErrorController extends AbstractErrorController {\n}\n```\n\n发现这也是一个`Controller`，它的`RequestMapping`映射的路径寻找规则：\n\n1. 首先查找`server.error.path`值\n2. 其次查找`error.path`值\n3. 最后使用默认的`/error`路径\n\n我们在容器中添加`BasicErrorController`：\n\n```Java\n@Bean\npublic BasicErrorController basicErrorController() {\n  // 第一个参数指的是异常信息，第二个参数指配置文件中的键值\n  return new BasicErrorController(new DefaultErrorAttributes(), new ErrorProperties());\n}\n```\n\n`BasicErrorController`异常处理考虑得更加全面，其中有两个RequestMapping：\n\n```Java\n@RequestMapping(\n    produces = {\"text/html\"}\n)\npublic ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {\n    HttpStatus status = this.getStatus(request);\n    Map<String, Object> model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.TEXT_HTML)));\n    response.setStatus(status.value());\n    ModelAndView modelAndView = this.resolveErrorView(request, response, status, model);\n    return modelAndView != null ? modelAndView : new ModelAndView(\"error\", model);\n}\n\n@RequestMapping\npublic ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {\n    HttpStatus status = this.getStatus(request);\n    if (status == HttpStatus.NO_CONTENT) {\n        return new ResponseEntity(status);\n    } else {\n        Map<String, Object> body = this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.ALL));\n        return new ResponseEntity(body, status);\n    }\n}\n```\n\n根据前端想要的返回格式，一种是返回`html`格式，另一种是`json`格式。\n\n运行启动类，使用`postman`进行测试：\n\n```JSON\n{\n    \"timestamp\": 1680758526029,\n    \"status\": 500,\n    \"error\": \"Internal Server Error\",\n    \"path\": \"/test\"\n}\n```\n\n返回的一串`json`格式的数据，其中的属性就是我们构造`BasicErrorController`时，传入的`DefaultErrorAttributes`。\n\n查看`DefaultErrorAttributes`的`getErrorAttributes()`方法：\n\n```Java\nprivate Map<String, Object> getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) {\n    Map<String, Object> errorAttributes = new LinkedHashMap();\n    errorAttributes.put(\"timestamp\", new Date());\n    this.addStatus(errorAttributes, webRequest);\n    this.addErrorDetails(errorAttributes, webRequest, includeStackTrace);\n    this.addPath(errorAttributes, webRequest);\n    return errorAttributes;\n}\n```\n\n我们发现返回的`json`数据中没有真正的错误信息，展示错误信息有两种方法：\n\n1. 可以通过在配置文件中添加`server.error.include-exception=true`配置\n2. 可以在构造`BasicErrorController`时传入配置：\n\n```Java\n@Bean\npublic BasicErrorController basicErrorController() {\n  ErrorProperties errorProperties = new ErrorProperties();\n  errorProperties.setIncludeException(true);\n  // 第一个参数指的是异常信息，第二个参数指配置文件中的键值\n  return new BasicErrorController(new DefaultErrorAttributes(), errorProperties);\n}\n```\n\n运行启动类，使用`postman`进行测试：\n\n```JSON\n{\n    \"timestamp\": 1680758791767,\n    \"status\": 500,\n    \"error\": \"Internal Server Error\",\n    \"exception\": \"java.lang.ArithmeticException\",\n    \"path\": \"/test\"\n}\n```\n\n已经成功添加了错误信息。\n\n我们通过浏览器访问的方式测试`BasicErrorController`：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%91%EF%BC%9AWEB/9.png)\n\n发现还是使用的是`tomcat`异常处理的方式，我们查看`BasicErrorController`源码：\n\n```Java\n@RequestMapping(\n    produces = {\"text/html\"}\n)\npublic ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {\n    HttpStatus status = this.getStatus(request);\n    Map<String, Object> model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.TEXT_HTML)));\n    response.setStatus(status.value());\n    ModelAndView modelAndView = this.resolveErrorView(request, response, status, model);\n    return modelAndView != null ? modelAndView : new ModelAndView(\"error\", model);\n}\n```\n\n发现最终返回的是一个`ModelAndView`对象，但此时我们没有添加名为`error`的视图，因此没有生效。\n\n添加`error`视图以及视图解析器：\n\n```Java\n/**\n* 方法名称即为视图名称\n*/\n@Bean\npublic View error() {\n    return new View() {\n        @Override\n        public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception {\n            System.out.println(model);\n            response.setContentType(\"text/html;charset=utf-8\");\n            response.getWriter().print(\"\"\"\n                    <h3>服务器内部错误</h3>\n                    \"\"\");\n        }\n    };\n}\n\n/**\n* 视图解析器\n*/\n@Bean\npublic ViewResolver viewResolver() {\n    return new BeanNameViewResolver();\n}\n```\n\n运行启动类，访问localhost:8080/test，浏览器上出现以下页面：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%91%EF%BC%9AWEB/10.png)\n\n已经能正确解析我们的自定义视图。\n\n`springboot`中其实就是采用的`BasicErrorController`来做错误处理。\n\n# BeanNameUrlHandlerMapping与SimpleControllerHandlerAdapter\n\n`BeanNameUrlHandlerMapping`与`SimpleControllerHandlerAdapter`是`SpringMVC`早期的实现，比`RequestMappingHandlerMapping`和`RequestMappingHandlerAdapter`的实现更加简单。\n\n**BeanNameUrlHandlerMapping**\n\n`BeanNameUrlHandlerMapping`的作用是通过请求路径去查找相应的控制器的名称，例如我们访问`/test`路径，`BeanNameUrlHandlerMapping`就回去查找容器中名为`/test`的`Bean`，以这种规则去做路径与控制器的映射。\n\n以下这三个`Bean`分别映射路径`/c1`、`/c2`、`/c3`。\n\n```Java\n@Component(\"/c1\")\npublic static class Controller1 implements Controller {\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        response.getWriter().print(\"this is c1\");\n        return null;\n    }\n}\n\n@Component(\"/c2\")\npublic static class Controller2 implements Controller {\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        response.getWriter().print(\"this is c2\");\n        return null;\n    }\n}\n\n@Bean(\"/c3\")\npublic Controller controller3() {\n    return (request, response) -> {\n        response.getWriter().print(\"this is c3\");\n        return null;\n    };\n}\n```\n\n**SimpleControllerHandlerAdapter**\n\n`SimpleControllerHandlerAdapter`的作用是调用控制器的方法，它要求每个控制器必须实现`Controller`，重写`handleRequest()`方法才能调用。\n\n```Java\n@Component(\"/c1\")\npublic static class Controller1 implements Controller {\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        response.getWriter().print(\"this is c1\");\n        return null;\n    }\n}\n\n@Component(\"/c2\")\npublic static class Controller2 implements Controller {\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        response.getWriter().print(\"this is c2\");\n        return null;\n    }\n}\n\n@Bean(\"/c3\")\npublic Controller controller3() {\n    return (request, response) -> {\n        response.getWriter().print(\"this is c3\");\n        return null;\n    };\n}\n```\n\n添加启动类：\n\n```Java\npublic class A33 {\n    public static void main(String[] args) {\n        AnnotationConfigServletWebServerApplicationContext context\n                = new AnnotationConfigServletWebServerApplicationContext(WebConfig.class);\n    }\n}\n```\n\n运行启动类，访问http://localhost:8080/c1，浏览器输出：\n\n```Plain\nthis is c1\n```\n\n访问http://localhost:8080/c2，浏览器输出：\n\n```Plain\nthis is c2\n```\n\n访问http://localhost:8080/c3，浏览器输出：\n\n```Plain\nthis is c3\n```\n\n都能映射到正确的控制器中。\n\n# 自定义HandlerMapping与HandlerAdapter\n\n我们自定义`HandlerMapping`与`HandlerAdapter`实现简单的`BeanNameUrlHandlerMapping`与`SimpleControllerHandlerAdapter`。\n\n`HandlerMapping`的实现：\n\n```Java\n@Component\nstatic class MyHandlerMapping implements HandlerMapping {\n    @Override\n    public HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n        String key = request.getRequestURI();\n        Controller controller = collect.get(key);\n        if (controller == null) {\n            return null;\n        }\n        return new HandlerExecutionChain(controller);\n    }\n\n    @Autowired\n    private ApplicationContext context;\n    private Map<String, Controller> collect;\n\n    @PostConstruct\n    public void init() {\n        collect = context.getBeansOfType(Controller.class).entrySet()\n                .stream().filter(e -> e.getKey().startsWith(\"/\"))\n                .collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue()));\n        System.out.println(collect);\n    }\n}\n```\n\n实现步骤：\n\n1. 在初始化方法中获取所有的`Bean`，并过滤不以`\"/\"`开头的名称\n2. 在映射时，根据请求路径获取`Bean`，并封装为`HandlerExecutionChain`。\n\n`HandlerAdapter`的实现：\n\n```Java\n@Component\nstatic class MyHandlerAdapter implements HandlerAdapter {\n\n    @Override\n    public boolean supports(Object handler) {\n        return handler instanceof Controller;\n    }\n\n    @Override\n    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        if (handler instanceof Controller controller) {\n            controller.handleRequest(request, response);\n        }\n        return null;\n    }\n\n    @Override\n    public long getLastModified(HttpServletRequest request, Object handler) {\n        return -1;\n    }\n}\n```\n\n`HandlerAdapter`接口有三个方法需要实现：\n\n1. `supports()`：是否支持`Controller`调用\n2. `handle()`：调用方法的具体逻辑\n3. `getLastModified()`：处理修改时间，缓存相关\n\n编写启动类：\n\n```Java\npublic class A33_1 {\n    public static void main(String[] args) {\n        AnnotationConfigServletWebServerApplicationContext context\n                = new AnnotationConfigServletWebServerApplicationContext(WebConfig_1.class);\n    }\n}\n```\n\n运行启动类，访问http://localhost:8080/c1，浏览器输出：\n\n```Plain\nthis is c1\n```\n\n# RouterFunctionMapping与HandlerFunctionAdapter\n\n`RouterFunctionMapping`与`HandlerFunctionAdapter`是一对新的实现，在`spring5.2`版本引入的。\n\n1. `RouterFunctionMapping`, 收集所有`RouterFunction`，它包括两部分： `RequestPredicate`设置映射条件，`HandlerFunction`包含处理逻辑\n2. 请求到达，根据映射条件找到`HandlerFunction`，即`handler`\n3. `HandlerFunctionAdapter`调用`handler`\n\n编写配置类：\n\n```Java\n@Configuration\npublic class WebConfig {\n    @Bean // ⬅️内嵌 web 容器工厂\n    public TomcatServletWebServerFactory servletWebServerFactory() {\n        return new TomcatServletWebServerFactory(8080);\n    }\n\n    @Bean // ⬅️创建 DispatcherServlet\n    public DispatcherServlet dispatcherServlet() {\n        return new DispatcherServlet();\n    }\n\n    @Bean // ⬅️注册 DispatcherServlet, Spring MVC 的入口\n    public DispatcherServletRegistrationBean servletRegistrationBean(DispatcherServlet dispatcherServlet) {\n        return new DispatcherServletRegistrationBean(dispatcherServlet, \"/\");\n    }\n\n    /**\n    * 路径映射\n    */\n    @Bean\n    public RouterFunctionMapping routerFunctionMapping() {\n        return new RouterFunctionMapping();\n    }\n\n    /**\n    * 调用handler\n    */\n    @Bean\n    public HandlerFunctionAdapter handlerFunctionAdapter() {\n        return new HandlerFunctionAdapter();\n    }\n\n    @Bean\n    public RouterFunction<ServerResponse> r1() {\n        // 参数一为请求的方法和路径，方法二为处理逻辑\n        return route(GET(\"/r1\"), request -> ok().body(\"this is r1\"));\n    }\n\n    @Bean\n    public RouterFunction<ServerResponse> r2() {\n        return route(GET(\"/r2\"), request -> ok().body(\"this is r2\"));\n    }\n\n}\n```\n\n编写启动类：\n\n```Java\npublic class A34 {\n    public static void main(String[] args) {\n        AnnotationConfigServletWebServerApplicationContext context =\n                new AnnotationConfigServletWebServerApplicationContext(WebConfig.class);\n    }\n}\n```\n\n运行启动类，通过浏览器访问localhost:8080/r1，浏览器输出：\n\n```Plain\nthis is r1\n```\n\n运行启动类，通过浏览器访问localhost:8080/r2，浏览器输出：\n\n```Plain\nthis is r2\n```\n\n函数式控制器与经典控制器的对比：\n\n函数式控制器：\n\n1. `RouterFunctionMapping`，通过`RequestPredicate`映射\n2. `handler`要实现`HandlerFunction`接口\n3. `HandlerFunctionAdapter`，调用`handler`\n\n经典控制器：\n\n1. `RequestMappingHandlerMapping`，以`@RequestMapping`作为映射路径\n2. 控制器的具体方法会被当作`handler`\n3. `RequestMappingHandlerAdapter`，调用`handler`\n\n函数式控制器的实现没有经典控制器实现功能强大，其特点是比较简洁，适合简单业务场景下使用。\n\n# SimpleUrlHandlerMapping与HttpRequestHandlerAdapter\n\n`SimpleUrlHandlerMapping`与`HttpRequestHandlerAdapter`主要用于处理静态资源：\n\n1. `SimpleUrlHandlerMapping`做映射\n2. `ResourceHttpRequestHandler`作为处理器处理静态资源\n3. `HttpRequestHandlerAdapter`调用处理器\n\n编写配置类：\n\n```Java\n@Configuration\npublic class WebConfig {\n    @Bean // ⬅️内嵌 web 容器工厂\n    public TomcatServletWebServerFactory servletWebServerFactory() {\n        return new TomcatServletWebServerFactory(8080);\n    }\n\n    @Bean // ⬅️创建 DispatcherServlet\n    public DispatcherServlet dispatcherServlet() {\n        return new DispatcherServlet();\n    }\n\n    @Bean // ⬅️注册 DispatcherServlet, Spring MVC 的入口\n    public DispatcherServletRegistrationBean servletRegistrationBean(DispatcherServlet dispatcherServlet) {\n        return new DispatcherServletRegistrationBean(dispatcherServlet, \"/\");\n    }\n\n    /**\n     * 记录映射路径与处理器\n     * @param context\n     * @return\n     */\n    @Bean\n    public SimpleUrlHandlerMapping simpleUrlHandlerMapping(ApplicationContext context) {\n        SimpleUrlHandlerMapping handlerMapping = new SimpleUrlHandlerMapping();\n        Map<String, ResourceHttpRequestHandler> map = context.getBeansOfType(ResourceHttpRequestHandler.class);\n        handlerMapping.setUrlMap(map);\n        System.out.println(map);\n        return handlerMapping;\n    }\n\n    @Bean\n    public HttpRequestHandlerAdapter httpRequestHandlerAdapter() {\n        return new HttpRequestHandlerAdapter();\n    }\n\n    /**\n     * 请求的所有路径都会被映射到资源目录下\n     * 例如访问/r1.html、/r2.html、/r3.html\n     * @return\n     */\n    @Bean(\"/**\")\n    public ResourceHttpRequestHandler handler1() {\n        ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler();\n        // 设置静态资源的目录\n        handler.setLocations(List.of(new ClassPathResource(\"static/\")));\n        return handler;\n    }\n\n\n    /**\n     * 请求的img下的路径都会被映射到资源目录下\n     * 例如访问/img/1.jpg、/img/2.jpg、/img/3.jpg\n     * @return\n     */\n    @Bean(\"/img/**\")\n    public ResourceHttpRequestHandler handler2() {\n        ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler();\n        handler.setLocations(List.of(new ClassPathResource(\"images/\")));\n        return handler;\n    }\n\n}\n```\n\n编写启动类：\n\n```Java\npublic class A35 {\n    public static void main(String[] args) {\n        AnnotationConfigServletWebServerApplicationContext context\n                = new AnnotationConfigServletWebServerApplicationContext(WebConfig.class);\n    }\n}\n```\n\n运行启动类，通过浏览器访问localhost:8080/index.html，浏览器输出：\n\n```Plain\n我是欢迎页！\n```\n\n运行启动类，通过浏览器访问http://localhost:8080/img/1.jpg，浏览器能正确展示图片。\n\n`ResourceHttpRequestHandler`中的`afterPropertiesSet()`会添加资源解析器：\n\n```Java\npublic void afterPropertiesSet() throws Exception {\n    this.resolveResourceLocations();\n    if (logger.isWarnEnabled() && CollectionUtils.isEmpty(this.getLocations())) {\n        logger.warn(\"Locations list is empty. No resources will be served unless a custom ResourceResolver is configured as an alternative to PathResourceResolver.\");\n    }\n\n    if (this.resourceResolvers.isEmpty()) {\n        this.resourceResolvers.add(new PathResourceResolver());\n    }\n\n    this.initAllowedLocations();\n    this.resolverChain = new DefaultResourceResolverChain(this.resourceResolvers);\n    this.transformerChain = new DefaultResourceTransformerChain(this.resolverChain, this.resourceTransformers);\n    if (this.resourceHttpMessageConverter == null) {\n        this.resourceHttpMessageConverter = new ResourceHttpMessageConverter();\n    }\n\n    if (this.resourceRegionHttpMessageConverter == null) {\n        this.resourceRegionHttpMessageConverter = new ResourceRegionHttpMessageConverter();\n    }\n\n    ContentNegotiationManager manager = this.getContentNegotiationManager();\n    if (manager != null) {\n        this.setMediaTypes(manager.getMediaTypeMappings());\n    }\n\n    PathExtensionContentNegotiationStrategy strategy = this.initContentNegotiationStrategy();\n    if (strategy != null) {\n        this.setMediaTypes(strategy.getMediaTypes());\n    }\n\n}\n```\n\n它会判断`resourceResolvers`是否为空，如果为空则添加`PathResourceResolver`解析器，也就是进行路径资源解析。`Spring`中提供多种解析器，我们可以手动添加增强`ResourceHttpRequestHandler`的功能。\n\n我们在`ResourceHttpRequestHandler`中添加更多的解析器：\n\n```Java\n@Bean(\"/**\")\npublic ResourceHttpRequestHandler handler1() {\n    ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler();\n    // 设置静态资源的目录\n    handler.setLocations(List.of(new ClassPathResource(\"static/\")));\n    handler.setResourceResolvers(List.of(\n            // 添加缓存\n            new CachingResourceResolver(new ConcurrentMapCache(\"cache1\")),\n            // 读取压缩的资源\n            new EncodedResourceResolver(),\n            // 根据路径读取资源\n            new PathResourceResolver()\n    ));\n    return handler;\n}\n```\n\n测试`CachingResourceResolver`的功能：\n\n运行启动类，通过浏览器访问localhost:8080/index.html，第一次访问走的是正常逻辑，第二次访问后台输出：\n\n```Plain\n[TRACE] 15:01:43.385 [http-nio-8080-exec-5] o.s.web.servlet.DispatcherServlet   - GET \"/index.html\", parameters={}, headers={masked} in DispatcherServlet 'dispatcherServlet' \n[TRACE] 15:01:43.386 [http-nio-8080-exec-5] o.s.w.s.r.CachingResourceResolver   - Resource resolved from cache \n[TRACE] 15:01:43.386 [http-nio-8080-exec-5] o.s.w.s.r.ResourceHttpRequestHandler - Resource not modified \n[TRACE] 15:01:43.386 [http-nio-8080-exec-5] o.s.web.servlet.DispatcherServlet   - No view rendering, null ModelAndView returned. \n[DEBUG] 15:01:43.386 [http-nio-8080-exec-5] o.s.web.servlet.DispatcherServlet   - Completed 304 NOT_MODIFIED, headers={masked} \n```\n\n发现使用了`CachingResourceResolver`中的缓存。\n\n测试`EncodedResourceResolver`的功能：\n\n`EncodedResourceResolver`可以读取压缩的文件，提高网络传输的速度，使用此解析器我们需要手动生成压缩文件：\n\n```Java\n@PostConstruct\n@SuppressWarnings(\"all\")\npublic void initGzip() throws IOException {\n    Resource resource = new ClassPathResource(\"static\");\n    File dir = resource.getFile();\n    for (File file : dir.listFiles(pathname -> pathname.getName().endsWith(\".html\"))) {\n        System.out.println(file);\n        try (FileInputStream fis = new FileInputStream(file); GZIPOutputStream fos = new GZIPOutputStream(new FileOutputStream(file.getAbsoluteFile() + \".gz\"))) {\n            byte[] bytes = new byte[8 * 1024];\n            int len;\n            while ((len = fis.read(bytes)) != -1) {\n                fos.write(bytes, 0, len);\n            }\n        }\n    }\n}\n```\n\n运行启动类，可以发现压缩后的.gz文件比原始的html文件要小很多，浏览器请求时会自动请求.gz文件，并进行解压。\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%91%EF%BC%9AWEB/11.png)\n\n如果我们访问http://localhost:8080/，根路径不对应任何资源，因此会返回404。一般情况下我们希望访问根路径能够跳转到欢迎页，有两种方式可以实现：\n\n1. 使用静态资源作为欢迎页\n2. 使用控制器映射作为欢迎页\n\n这里演示使用静态资源作为欢迎页，另外，欢迎页的功能是由`Spring`提供的，在传统的`SpringMVC`中没有此功能。\n\n我们在配置类中添加`Bean`：\n\n```Java\n@Bean\npublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext context) {\n    Resource resource = context.getResource(\"classpath:static/index.html\");\n    // 它将会生成一个处理器，这个处理器实现了Controller接口的，因此需要ControllerHandlerAdapter去调用\n    return new WelcomePageHandlerMapping(null, context, resource, \"/**\");\n}\n\n@Bean\npublic SimpleControllerHandlerAdapter simpleControllerHandlerAdapter() {\n    return new SimpleControllerHandlerAdapter();\n}\n```\n\n`welcomePageHandlerMapping`用来映射到欢迎页，`SimpleControllerHandlerAdapter`用来调用`welcomePageHandlerMapping`生成的处理器。\n\n运行启动类，通过浏览器访问localhost:8080，浏览器输出：\n\n```Plain\n我是欢迎页！\n```\n\n说明映射已经生效。\n\n欢迎页的处理流程：\n\n1. `WelcomePageHandlerMapping`，映射欢迎页(即只映射`'/'`)\n    1. 它内置了`handler`，`ParameterizableViewController`作用是不执行逻辑, 仅根据视图名找视图\n    2. 视图名固定为`forward:index.html `\n2. `SimpleControllerHandlerAdapter`调用`handler`\n    1. 转发至`/index.html`\n    2. 处理`/index.html`又会走静态资源处理流程\n\n**五大映射器与四大处理器总结：**\n\n1. `HandlerMapping`负责建立请求与控制器之间的映射关系\n    1. `RequestMappingHandlerMapping`：处理与`@RequestMapping`注解的匹配\n    2. `WelcomePageHandlerMapping`：处理`/`路径，主要用于欢迎页的处理\n    3. `BeanNameUrlHandlerMapping`：处理路径与`bean`的名字匹配，需要以`/`开头\n    4. `RouterFunctionMapping`：支持函数式调用，`RequestPredicate`、`HandlerFunction`\n    5. SimpleUrlHandlerMapping：处理与静态资源的映射。\n\n> 之间也会有顺序问题, `springboot`中默认顺序如上\n\n1. `HandlerAdapter`负责实现对各种各样的`handler`的适配调用\n    1. `RequestMappingHandlerAdapter`：处理`@RequestMapping`方法，参数解析器、返回值处理器体现了组合模式\n    2. `SimpleControllerHandlerAdapter`：处理`Controller`接口\n    3. `HandlerFunctionAdapter`：处理`HandlerFunction`函数式接口\n    4. `HttpRequestHandlerAdapter`：处理`HttpRequestHandler`接口，(静态资源处理)这也是典型适配器模式体现\n2. `ResourceHttpRequestHandler.setResourceResolvers`这是典型责任链模式体现\n\n# SpringMVC处理流程\n\n当浏览器发送一个请求 `http://localhost:8080/hello` 后，请求到达服务器，其处理流程是：\n\n1. 服务器提供了`DispatcherServlet`，它使用的是标准`Servlet`技术\n    1. 路径：默认映射路径为`/`，即会匹配到所有请求`URL`，可作为请求的统一入口，也被称之为**前控制器**\n        - `jsp`不会匹配到`DispatcherServlet`\n        - 其它有路径的`Servlet`匹配优先级也高于`DispatcherServlet`\n    2. 创建：在`SpringBoot`中，由`DispatcherServletAutoConfiguration`这个自动配置类提供 `DispatcherServlet`的`bean`\n    3. 初始化：`DispatcherServlet`初始化时会优先到容器里寻找各种组件，作为它的成员变量\n        - `HandlerMapping`，初始化时记录映射关系\n        - `HandlerAdapter`，初始化时准备参数解析器、返回值处理器、消息转换器\n        - `HandlerExceptionResolver`，初始化时准备参数解析器、返回值处理器、消息转换器\n        - `ViewResolver`\n2. `DispatcherServlet`会利用`RequestMappingHandlerMapping`查找控制器方法\n    1. 例如根据`/hello`路径找到`@RequestMapping(\"/hello\")`对应的控制器方法\n    2. 控制器方法会被封装为`HandlerMethod`对象，并结合匹配到的拦截器一起返回给`DispatcherServlet`\n    3. `HandlerMethod`和拦截器合在一起称为`HandlerExecutionChain`（调用链）对象\n3. `DispatcherServlet`接下来会：\n    1. 调用拦截器的`preHandle`方法\n    2. `RequestMappingHandlerAdapter`调用`handle`方法，准备数据绑定工厂、模型工厂、`ModelAndViewContainer`、将`HandlerMethod`完善为`ServletInvocableHandlerMethod`\n        1. `@ControllerAdvice`全局增强点：补充模型数据\n        2. `@ControllerAdvice`全局增强点：补充自定义类型转换器\n        3. 使用`HandlerMethodArgumentResolver`准备参数\n            - `@ControllerAdvice`全局增强点：`RequestBody`增强\n        4. 调用`ServletInvocableHandlerMethod`\n        5. 使用`HandlerMethodReturnValueHandler`处理返回值\n            - `@ControllerAdvice`全局增强点：`ResponseBody`增强\n        6. 根据`ModelAndViewContainer`获取`ModelAndView`\n            - 如果返回的`ModelAndView`为`null`，不走第4步视图解析及渲染流程\n                - 例如，有的返回值处理器调用了`HttpMessageConverter`来将结果转换为`JSON`，这时 `ModelAndView`就为`null`\n            - 如果返回的`ModelAndView`不为`null`，会在第4步走视图解析及渲染流程\n    3. 调用拦截器的`postHandle`方法\n    4. 处理异常或视图渲染\n        1. 如果1~3出现异常，走`ExceptionHandlerExceptionResolver`处理异常流程\n            - `@ControllerAdvice`全局增强点：`@ExceptionHandler`异常处理\n        2. 正常，走视图解析及渲染流程\n    5. 调用拦截器的`afterCompletion`方法\n","tags":["spring"],"categories":["原理探究"]},{"title":"Spring高级45讲【第三章】：AOP","url":"/2023/04/15/Spring高级45讲【第三章】：AOP.html","content":"\n# 代理增强方式\n\n## aspectj编译器增强\n\n先看一组例子：\n\n`pom.xml`文件中增加插件：\n\n```XML\n<plugin>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>aspectj-maven-plugin</artifactId>\n    <version>1.14.0</version>\n    <configuration>\n        <complianceLevel>1.8</complianceLevel>\n        <source>8</source>\n        <target>8</target>\n        <showWeaveInfo>true</showWeaveInfo>\n        <verbose>true</verbose>\n        <Xlint>ignore</Xlint>\n        <encoding>UTF-8</encoding>\n    </configuration>\n    <executions>\n        <execution>\n            <goals>\n                <!-- use this goal to weave all your main classes -->\n                <goal>compile</goal>\n                <!-- use this goal to weave all your test classes -->\n                <goal>test-compile</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n编写`com.itheima.service.MyService`类：\n\n```Java\n@Service\npublic class MyService {\n\n    private static final Logger log = LoggerFactory.getLogger(MyService.class);\n\n    public static void foo() {\n        log.debug(\"foo()\");\n    }\n}\n```\n\n编写`com.itheima.aop.MyAspect`类：\n\n```Java\n/**\n* ⬅️注意此切面并未被 Spring 管理\n*/\n@Aspect\npublic class MyAspect {\n\n    private static final Logger log = LoggerFactory.getLogger(MyAspect.class);\n\n    @Before(\"execution(* com.itheima.service.MyService.foo())\")\n    public void before() {\n        log.debug(\"before()\");\n    }\n}\n```\n\n`MyAspect`类代理了`MyService`类，增加了前置通知。\n\n编写启动类`com.itheima.A09`：\n\n```Java\n@SpringBootApplication\npublic class A09 {\n\n    private static final Logger log = LoggerFactory.getLogger(A09.class);\n\n    public static void main(String[] args) {\n        new MyService().foo();\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n11:35:42.441 [main] DEBUG com.itheima.aop.MyAspect - before()\n11:35:42.444 [main] DEBUG com.itheima.service.MyService - foo()\n```\n\n`aspectj`编译器增强时在**编译阶段直接修改类文件**，并且不需要依赖`spring`容器，我们查看被改写的类文件：\n\n```Java\n@Service\npublic class MyService {\n    private static final Logger log = LoggerFactory.getLogger(MyService.class);\n\n    public MyService() {\n    }\n\n    public static void foo() {\n        MyAspect.aspectOf().before();\n        log.debug(\"foo()\");\n    }\n}\n```\n\n发现直接在目标方法前加上了我们的前置增强方法。\n\n当`jdk`代理和`cglib`代理都不能使用时，可以考虑使用此方式实现代理。\n\n## agent类加载增强\n\n先看一组例子：\n\n编写`com.itheima.service.MyService`类\n\n```Java\n@Service\npublic class MyService {\n\n    private static final Logger log = LoggerFactory.getLogger(MyService.class);\n\n    final public void foo() {\n        log.debug(\"foo()\");\n        this.bar();\n    }\n\n    public void bar() {\n        log.debug(\"bar()\");\n    }\n}\n```\n\n编写`com.itheima.aop.MyAspect`类：\n\n```Java\n/**\n* ⬅️注意此切面并未被 Spring 管理\n*/\n@Aspect\npublic class MyAspect {\n\n    private static final Logger log = LoggerFactory.getLogger(MyAspect.class);\n\n    @Before(\"execution(* com.itheima.service.MyService.*())\")\n    public void before() {\n        log.debug(\"before()\");\n    }\n}\n```\n\n`MyAspect`类代理了`MyService`类，并对所有方法增加了前置通知。\n\n编写启动类`com.itheima.A10`：\n\n```Java\n/*\n    注意几点\n    1. 版本选择了 java 8, 因为目前的 aspectj-maven-plugin 1.14.0 最高只支持到 java 16\n    2. 运行时需要在 VM options 里加入 -javaagent:C:/Users/manyh/.m2/repository/org/aspectj/aspectjweaver/1.9.7/aspectjweaver-1.9.7.jar\n        把其中 C:/Users/manyh/.m2/repository 改为你自己 maven 仓库起始地址\n */\n@SpringBootApplication\npublic class A10 {\n\n    private static final Logger log = LoggerFactory.getLogger(A10.class);\n\n    public static void main(String[] args) {\n        ConfigurableApplicationContext context = SpringApplication.run(A10.class, args);\n        MyService service = context.getBean(MyService.class);\n\n        // ⬇️MyService 并非代理, 但 foo 方法也被增强了, 做增强的 java agent, 在加载类时, 修改了 class 字节码\n        log.debug(\"service class: {}\", service.getClass());\n        service.foo();\n\n        context.close();\n\n    }\n}\n```\n\n`agent`类增强是在**类加载阶段修改类文件**进行的增强，运行时需要加上虚拟机参数：\n\n```Bash\n-javaagent:C:/Users/WolfMan/.m2/repository/org/aspectj/aspectjweaver/1.9.7/aspectjweaver-1.9.7.jar\n```\n\n运行启动类，查看控制台：\n\n```Plain\n2023-03-27 14:49:59.773 DEBUG 30220 --- [           main] com.itheima.aop.MyAspect                 : before()\n2023-03-27 14:49:59.773 DEBUG 30220 --- [           main] com.itheima.service.MyService            : foo()\n2023-03-27 14:49:59.773 DEBUG 30220 --- [           main] com.itheima.aop.MyAspect                 : before()\n2023-03-27 14:49:59.773 DEBUG 30220 --- [           main] com.itheima.service.MyService            : bar()\n```\n\n这种代理方式突破了普通代理的限制，即在一个方法内调用另外的方法，这两个方法都被代理了，而普通的代理只能代理被调用的方法。\n\n打开`arthas`，连接目标进程，使用`jad`命令反编译`MyService`类：\n\n```Java\npackage com.itheima.service;\n\nimport com.itheima.aop.MyAspect;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class MyService {\n   private static final Logger log = LoggerFactory.getLogger(MyService.class);\n\n   public final void foo() {\n       MyAspect.aspectOf().before();\n       log.debug(\"foo()\");\n       this.bar();\n   }\n\n   public void bar() {\n       MyAspect.aspectOf().before();\n       log.debug(\"bar()\");\n   }\n}\n```\n\n发现在方法前插入了我们增强的方法。\n\n## jdk代理增强\n\n演示代码：\n\n```Java\npublic class JdkProxyDemo {\n\n    interface Foo {\n        void foo();\n    }\n\n    static final class Target implements Foo {\n        public void foo() {\n            System.out.println(\"target foo\");\n        }\n    }\n\n    // jdk 只能针对接口代理\n    public static void main(String[] param) throws IOException {\n        // 目标对象\n        Target target = new Target();\n        // 用来加载在运行期间动态生成的字节码\n        ClassLoader loader = JdkProxyDemo.class.getClassLoader();\n        Foo proxy = (Foo) Proxy.newProxyInstance(loader, new Class[]{Foo.class}, (p, method, args) -> {\n            System.out.println(\"before...\");\n            // 目标.方法(参数)\n            // 方法.invoke(目标, 参数);\n            Object result = method.invoke(target, args);\n            System.out.println(\"after....\");\n            return result; // 让代理也返回目标方法执行的结果\n        });\n\n        System.out.println(proxy.getClass());\n\n        proxy.foo();\n\n        System.in.read();\n    }\n}\n```\n\n运行`main()`方法，查看控制台：\n\n```Plain\nclass com.itheima.a11.$Proxy0\nbefore...\ntarget foo\nafter....\n```\n\n发现对象被代理了，打印出我们真实调用的对象实际上是一个代理类对象。\n\n`invoke`方法的参数：\n\n- `Object`：代表代理类自身\n- `Method`：代表代理类正在执行的方法\n- `Object[]`：代表正在执行方法传入的参数\n\n`jdk`代理的特点：\n\n- 被代理对象与代理对象为兄弟关系，都实现了父接口\n- 被代理对象如果被final修饰没有影响\n\n## cglib代理增强\n\n实例代码：\n\n```Java\npublic class CglibProxyDemo {\n\n    static class Target {\n        public void foo() {\n            System.out.println(\"target foo\");\n        }\n    }\n\n    // 代理是子类型, 目标是父类型\n    public static void main(String[] param) {\n        Target target = new Target();\n\n        Target proxy = (Target) Enhancer.create(Target.class, (MethodInterceptor) (p, method, args, methodProxy) -> {\n            System.out.println(\"before...\");\n            Object result = method.invoke(target, args); // 用方法反射调用目标\n            System.out.println(\"after...\");\n            return result;\n        });\n\n        proxy.foo();\n\n    }\n}\n```\n\n运行`main()`方法，查看控制台：\n\n```Plain\nbefore...\ntarget foo\nafter...\n```\n\n`MethodInterceptor`参数含义：\n\n- `Object`：代表代理类自身\n- `Method`：代表代理类正在执行的方法\n- `Object[]`：代表正在执行方法传入的参数\n- `MethodProxy`：一个方法对象，提供更多功能\n\n`cgilib`代理的特点：\n\n- 被代理对象与代理对象为父子关系，代理对象继承了被代理对象\n- 被代理对象或者方法为final都不能使用cglib代理\n\n`MethodInterceptor`参数中的`methodProxy`有两个方法可以避免反射调用：\n\n- `methodProxy.invoke(target, args)`：内部没有用反射, 需要目标(spring使用的这种方式)\n- `methodProxy.invokeSuper(p, args)`：内部没有用反射, 需要代理\n\n实例使用：\n\n```Java\nObject result = methodProxy.invoke(target, args); // 内部没有用反射, 需要目标 （spring）\nObject result = methodProxy.invokeSuper(p, args); // 内部没有用反射, 需要代理\n```\n\n# jdk动态代理原理\n\n## 模拟jdk动态代理\n\n代码演示：\n\n```Java\n// 被代理对象实现的接口\ninterface Foo {\n    void foo();\n\n    int bar();\n}\n\n// 自己实现的InvocationHandler接口\ninterface InvocationHandler {\n    Object invoke(Object proxy, Method method, Object[] args) throws Throwable;\n}\n\n// 被代理对象\nclass Target implements Foo {\n    public void foo() {\n        System.out.println(\"target foo\");\n    }\n\n    @Override\n    public int bar() {\n        System.out.println(\"target bar\");\n        return 100;\n    }\n}\n\n// 代理类\npublic class $Proxy0 implements Foo {\n\n    static Method foo;\n    static Method bar;\n\n    static {\n        try {\n            foo = Foo.class.getMethod(\"foo\");\n            bar = Foo.class.getMethod(\"bar\");\n        } catch (NoSuchMethodException e) {\n            throw new NoSuchMethodError(e.getMessage());\n        }\n    }\n\n    InvocationHandler h;\n\n    public $Proxy0(InvocationHandler h) {\n        this.h = h;\n    }\n\n    @Override\n    public void foo() {\n        try {\n            h.invoke(this, foo, new Object[0]);\n        } catch (RuntimeException | Error e) {\n            throw e;\n        } catch (Throwable e) {\n            throw new UndeclaredThrowableException(e);\n        }\n    }\n\n    @Override\n    public int bar() {\n        try {\n            Object result = h.invoke(this, bar, new Object[0]);\n            return (int) result;\n        } catch (RuntimeException | Error e) {\n            throw e;\n        } catch (Throwable e) {\n            throw new UndeclaredThrowableException(e);\n        }\n    }\n\n\n}\n\n// 使用自己实现的代理类\npublic class A12 {\n\n    public static void main(String[] param) {\n        Foo proxy = new $Proxy0(new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                // 1. 功能增强\n                System.out.println(\"before...\");\n                // 2. 调用目标\n                return method.invoke(new Target(), args);\n            }\n        });\n        proxy.foo();\n        proxy.bar();\n    }\n}\n```\n\n模拟jdk动态代理思路：\n\n1. 方法重写可以增强逻辑, 只不过这**增强逻辑**千变万化, 不能写死在代理内部\n2. 通过接口回调将**增强逻辑**置于代理类之外\n3. 配合接口方法反射(也是多态)，就可以再联动调用目标方法\n\n## jdk动态代理源码\n\n打开arthas：\n\n```Bash\nC:/Path/jdk1.8.0_152/bin/java  -jar arthas-boot.jar\n```\n\n连接进程，使用`jad`命令查看运行时的源码：\n\n```Java\npackage com.itheima.a11;\n\nimport com.itheima.a11.JdkProxyDemo;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\n\nfinal class $Proxy0\nextends Proxy\nimplements JdkProxyDemo.Foo {\n    private static final Method m0;\n    private static final Method m1;\n    private static final Method m2;\n    private static final Method m3;\n\n    public $Proxy0(InvocationHandler invocationHandler) {\n        super(invocationHandler);\n    }\n\n    static {\n        ClassLoader classLoader = $Proxy0.class.getClassLoader();\n        try {\n            m0 = Class.forName(\"java.lang.Object\", false, classLoader).getMethod(\"hashCode\", new Class[0]);\n            m1 = Class.forName(\"java.lang.Object\", false, classLoader).getMethod(\"equals\", Class.forName(\"java.lang.Object\", false, classLoader));\n            m2 = Class.forName(\"java.lang.Object\", false, classLoader).getMethod(\"toString\", new Class[0]);\n            m3 = Class.forName(\"com.itheima.a11.JdkProxyDemo$Foo\", false, classLoader).getMethod(\"foo\", new Class[0]);\n            return;\n        }\n        catch (NoSuchMethodException noSuchMethodException) {\n            throw new NoSuchMethodError(noSuchMethodException.getMessage());\n        }\n        catch (ClassNotFoundException classNotFoundException) {\n            throw new NoClassDefFoundError(classNotFoundException.getMessage());\n        }\n    }\n\n    public final boolean equals(Object object) {\n        try {\n            return (Boolean)this.h.invoke(this, m1, new Object[]{object});\n        }\n        catch (Error | RuntimeException throwable) {\n            throw throwable;\n        }\n        catch (Throwable throwable) {\n            throw new UndeclaredThrowableException(throwable);\n        }\n    }\n\n    public final String toString() {\n        try {\n            return (String)this.h.invoke(this, m2, null);\n        }\n        catch (Error | RuntimeException throwable) {\n            throw throwable;\n        }\n        catch (Throwable throwable) {\n            throw new UndeclaredThrowableException(throwable);\n        }\n    }\n\n    public final int hashCode() {\n        try {\n            return (Integer)this.h.invoke(this, m0, null);\n        }\n        catch (Error | RuntimeException throwable) {\n            throw throwable;\n        }\n        catch (Throwable throwable) {\n            throw new UndeclaredThrowableException(throwable);\n        }\n    }\n\n    public final void foo() {\n        try {\n            this.h.invoke(this, m3, null);\n            return;\n        }\n        catch (Error | RuntimeException throwable) {\n            throw throwable;\n        }\n        catch (Throwable throwable) {\n            throw new UndeclaredThrowableException(throwable);\n        }\n    }\n\n    private static MethodHandles.Lookup proxyClassLookup(MethodHandles.Lookup lookup) throws IllegalAccessException {\n        if (lookup.lookupClass() == Proxy.class && lookup.hasFullPrivilegeAccess()) {\n            return MethodHandles.lookup();\n        }\n        throw new IllegalAccessException(lookup.toString());\n    }\n}\n```\n\njdk直接生成字节码使用的技术是ASM，接下来演示ASM生成的字节码。\n\n在idea中安装`ASM Bytecode Viewer Support Kotlin`插件，编写以下代码：\n\n```Java\n// 代理接口\npublic interface Foo {\n    public void foo();\n}\n\n// 代理类\npublic class $Proxy0 extends Proxy implements Foo {\n    static Method foo;\n\n    public $Proxy0(InvocationHandler h) {\n        super(h);\n    }\n\n    public void foo() {\n        try {\n            this.h.invoke(this, foo, null);\n        } catch (Throwable var2) {\n            throw new UndeclaredThrowableException(var2);\n        }\n    }\n\n    static {\n        try {\n            foo = Foo.class.getMethod(\"foo\");\n        } catch (NoSuchMethodException var1) {\n            throw new NoSuchMethodError(var1.getMessage());\n        }\n    }\n}\n```\n\n编译这两个类，在`$Proxy0`中右键`ASM Bytecode Viewer`，选择`ASMified`选项：\n\n```Java\npackage asm.com.itheima;\n\nimport org.objectweb.asm.AnnotationVisitor;\nimport org.objectweb.asm.Attribute;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.ConstantDynamic;\nimport org.objectweb.asm.FieldVisitor;\nimport org.objectweb.asm.Handle;\nimport org.objectweb.asm.Label;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.TypePath;\n\npublic class $Proxy0Dump implements Opcodes {\n\n    public static byte[] dump() throws Exception {\n\n        ClassWriter classWriter = new ClassWriter(0);\n        FieldVisitor fieldVisitor;\n        MethodVisitor methodVisitor;\n        AnnotationVisitor annotationVisitor0;\n\n        // 定义类\n        classWriter.visit(V1_8, ACC_PUBLIC | ACC_SUPER, \"com/itheima/$Proxy0\", null, \"java/lang/reflect/Proxy\", new String[]{\"com/itheima/Foo\"});\n\n        {\n            // 定义静态成员变量\n            fieldVisitor = classWriter.visitField(ACC_STATIC, \"foo\", \"Ljava/lang/reflect/Method;\", null, null);\n            fieldVisitor.visitEnd();\n        }\n        {\n            // 定义构造方法\n            methodVisitor = classWriter.visitMethod(ACC_PUBLIC, \"<init>\", \"(Ljava/lang/reflect/InvocationHandler;)V\", null, null);\n            // 定义方法内的字节码\n            methodVisitor.visitCode();\n            methodVisitor.visitVarInsn(ALOAD, 0);\n            methodVisitor.visitVarInsn(ALOAD, 1);\n            methodVisitor.visitMethodInsn(INVOKESPECIAL, \"java/lang/reflect/Proxy\", \"<init>\", \"(Ljava/lang/reflect/InvocationHandler;)V\", false);\n            methodVisitor.visitInsn(RETURN);\n            methodVisitor.visitMaxs(2, 2);\n            methodVisitor.visitEnd();\n        }\n        {\n            // 定义方法\n            methodVisitor = classWriter.visitMethod(ACC_PUBLIC, \"foo\", \"()V\", null, null);\n            methodVisitor.visitCode();\n            Label label0 = new Label();\n            Label label1 = new Label();\n            Label label2 = new Label();\n            methodVisitor.visitTryCatchBlock(label0, label1, label2, \"java/lang/Throwable\");\n            methodVisitor.visitLabel(label0);\n            methodVisitor.visitVarInsn(ALOAD, 0);\n            methodVisitor.visitFieldInsn(GETFIELD, \"com/itheima/$Proxy0\", \"h\", \"Ljava/lang/reflect/InvocationHandler;\");\n            methodVisitor.visitVarInsn(ALOAD, 0);\n            methodVisitor.visitFieldInsn(GETSTATIC, \"com/itheima/$Proxy0\", \"foo\", \"Ljava/lang/reflect/Method;\");\n            methodVisitor.visitInsn(ACONST_NULL);\n            methodVisitor.visitMethodInsn(INVOKEINTERFACE, \"java/lang/reflect/InvocationHandler\", \"invoke\", \"(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;\", true);\n            methodVisitor.visitInsn(POP);\n            methodVisitor.visitLabel(label1);\n            Label label3 = new Label();\n            methodVisitor.visitJumpInsn(GOTO, label3);\n            methodVisitor.visitLabel(label2);\n            methodVisitor.visitVarInsn(ASTORE, 1);\n            methodVisitor.visitTypeInsn(NEW, \"java/lang/reflect/UndeclaredThrowableException\");\n            methodVisitor.visitInsn(DUP);\n            methodVisitor.visitVarInsn(ALOAD, 1);\n            methodVisitor.visitMethodInsn(INVOKESPECIAL, \"java/lang/reflect/UndeclaredThrowableException\", \"<init>\", \"(Ljava/lang/Throwable;)V\", false);\n            methodVisitor.visitInsn(ATHROW);\n            methodVisitor.visitLabel(label3);\n            methodVisitor.visitInsn(RETURN);\n            methodVisitor.visitMaxs(4, 2);\n            methodVisitor.visitEnd();\n        }\n        {\n            methodVisitor = classWriter.visitMethod(ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n            methodVisitor.visitCode();\n            Label label0 = new Label();\n            Label label1 = new Label();\n            Label label2 = new Label();\n            methodVisitor.visitTryCatchBlock(label0, label1, label2, \"java/lang/NoSuchMethodException\");\n            methodVisitor.visitLabel(label0);\n            methodVisitor.visitLdcInsn(Type.getType(\"Lcom/itheima/Foo;\"));\n            methodVisitor.visitLdcInsn(\"foo\");\n            methodVisitor.visitInsn(ICONST_0);\n            methodVisitor.visitTypeInsn(ANEWARRAY, \"java/lang/Class\");\n            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Class\", \"getMethod\", \"(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;\", false);\n            methodVisitor.visitFieldInsn(PUTSTATIC, \"com/itheima/$Proxy0\", \"foo\", \"Ljava/lang/reflect/Method;\");\n            methodVisitor.visitLabel(label1);\n            Label label3 = new Label();\n            methodVisitor.visitJumpInsn(GOTO, label3);\n            methodVisitor.visitLabel(label2);\n            methodVisitor.visitVarInsn(ASTORE, 0);\n            methodVisitor.visitTypeInsn(NEW, \"java/lang/NoSuchMethodError\");\n            methodVisitor.visitInsn(DUP);\n            methodVisitor.visitVarInsn(ALOAD, 0);\n            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/NoSuchMethodException\", \"getMessage\", \"()Ljava/lang/String;\", false);\n            methodVisitor.visitMethodInsn(INVOKESPECIAL, \"java/lang/NoSuchMethodError\", \"<init>\", \"(Ljava/lang/String;)V\", false);\n            methodVisitor.visitInsn(ATHROW);\n            methodVisitor.visitLabel(label3);\n            methodVisitor.visitInsn(RETURN);\n            methodVisitor.visitMaxs(3, 1);\n            methodVisitor.visitEnd();\n        }\n        classWriter.visitEnd();\n\n        // 生成字节数组\n        return classWriter.toByteArray();\n    }\n}\n```\n\n我们可以使用此类生成代码：\n\n```Java\npublic class TestProxy {\n    public static void main(String[] args) throws Exception {\n        byte[] dump = $Proxy0Dump.dump();\n\n        FileOutputStream os = new FileOutputStream(\"$Proxy0.class\");\n        os.write(dump, 0, dump.length);\n        os.close();\n    }\n}\n```\n\n在项目目录下生成文件`$Proxy0.class`：\n\n```Java\npackage com.itheima;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\n\npublic class $Proxy0 extends Proxy implements Foo {\n    static Method foo;\n\n    public $Proxy0(InvocationHandler h) {\n        super(h);\n    }\n\n    public void foo() {\n        try {\n            this.h.invoke(this, foo, (Object[])null);\n        } catch (Throwable var2) {\n            throw new UndeclaredThrowableException(var2);\n        }\n    }\n\n    static {\n        try {\n            foo = Foo.class.getMethod(\"foo\");\n        } catch (NoSuchMethodException var1) {\n            throw new NoSuchMethodError(var1.getMessage());\n        }\n    }\n}\n```\n\n我们也可以使用`$Proxy0Dump`类调用方法：\n\n```Java\npublic class TestProxy {\n    public static void main(String[] args) throws Exception {\n        byte[] dump = $Proxy0Dump.dump();\n        ClassLoader loader = new ClassLoader() {\n            @Override\n            protected Class<?> findClass(String name) throws ClassNotFoundException {\n                return super.defineClass(name, dump, 0, dump.length);\n            }\n        };\n        Class<?> proxyClass = loader.loadClass(\"com.itheima.$Proxy0\");\n\n        Constructor<?> constructor = proxyClass.getConstructor(InvocationHandler.class);\n        Foo proxy = (Foo) constructor.newInstance(new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(\"before...\");\n                System.out.println(\"调用目标\");\n                return null;\n            }\n        });\n\n        proxy.foo();\n    }\n}\n```\n\n运行main()方法，查看控制台：\n\n```Plain\nbefore...\n调用目标\n```\n\n## jdk反射优化\n\n编写测试类：\n\n```Java\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n// 运行时请添加 --add-opens java.base/java.lang.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED\npublic class TestMethodInvoke {\n    public static void main(String[] args) throws Exception {\n        Method foo = TestMethodInvoke.class.getMethod(\"foo\", int.class);\n        for (int i = 1; i <= 17; i++) {\n            show(i, foo);\n            foo.invoke(null, i);\n        }\n        System.in.read();\n    }\n\n    // 方法反射调用时, 底层 MethodAccessor 的实现类\n    private static void show(int i, Method foo) throws Exception {\n        Method getMethodAccessor = Method.class.getDeclaredMethod(\"getMethodAccessor\");\n        getMethodAccessor.setAccessible(true);\n        Object invoke = getMethodAccessor.invoke(foo);\n        if (invoke == null) {\n            System.out.println(i + \":\" + null);\n            return;\n        }\n        Field delegate = Class.forName(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\").getDeclaredField(\"delegate\");\n        delegate.setAccessible(true);\n        System.out.println(i + \":\" + delegate.get(invoke));\n    }\n\n    public static void foo(int i) {\n        System.out.println(i + \":\" + \"foo\");\n    }\n}\n```\n\n运行启动类，查看控制台输出：\n\n```SQL\n1:null\n1:foo\n2:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n2:foo\n3:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n3:foo\n4:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n4:foo\n5:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n5:foo\n6:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n6:foo\n7:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n7:foo\n8:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n8:foo\n9:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n9:foo\n10:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n10:foo\n11:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n11:foo\n12:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n12:foo\n13:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n13:foo\n14:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n14:foo\n15:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n15:foo\n16:jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2\n16:foo\n17:jdk.internal.reflect.GeneratedMethodAccessor2@2d38eb89\n17:foo\n```\n\n我们发现前面16次调用都是使用`jdk.internal.reflect.NativeMethodAccessorImpl@5b37e0d2`，这个实现是使用java本地api实现的，性能比较低。\n\n我们可以使用arthas查看`jdk.internal.reflect.GeneratedMethodAccessor2`的实现：\n\n```Java\npackage jdk.internal.reflect;\n\nimport com.itheima.a12.TestMethodInvoke;\nimport java.lang.reflect.InvocationTargetException;\nimport jdk.internal.reflect.MethodAccessorImpl;\n\npublic class GeneratedMethodAccessor2\nextends MethodAccessorImpl {\n    /*\n     * Loose catch block\n     */\n    public Object invoke(Object object, Object[] objectArray) throws InvocationTargetException {\n        char c;\n        block9: {\n            if (objectArray.length != 1) {\n                throw new IllegalArgumentException();\n            }\n            Object object2 = objectArray[0];\n            if (object2 instanceof Byte) {\n                c = ((Byte)object2).byteValue();\n                break block9;\n            }\n            if (object2 instanceof Character) {\n                c = ((Character)object2).charValue();\n                break block9;\n            }\n            if (object2 instanceof Short) {\n                c = (char)((Short)object2).shortValue();\n                break block9;\n            }\n            if (object2 instanceof Integer) {\n                c = (char)((Integer)object2).intValue();\n                break block9;\n            }\n            throw new IllegalArgumentException();\n        }\n        try {\n            // 直接调用，没有使用反射调用\n            TestMethodInvoke.foo((int)c);\n            return null;\n        }\n        catch (Throwable throwable) {\n            throw new InvocationTargetException(throwable);\n        }\n        catch (ClassCastException | NullPointerException runtimeException) {\n            throw new IllegalArgumentException(super.toString());\n        }\n    }\n}\n```\n\n我们发现jdk在运行时直接生成了`jdk.internal.reflect.GeneratedMethodAccessor2`类，然后直接调用其方法，避免了反射调用的性能损耗。缺点是每个方法都需要生成一个代理类，而cglib是一个类所有方法的代理生成两个代理类进行直接调用。\n\n# cglib动态代理原理\n\n## 模拟cglib动态代理\n\n代码演示：\n\n```Java\n// 代理目标类\npublic class Target {\n    public void save() {\n        System.out.println(\"save()\");\n    }\n\n    public void save(int i) {\n        System.out.println(\"save(int)\");\n    }\n\n    public void save(long j) {\n        System.out.println(\"save(long)\");\n    }\n}\n\n//代理类\npublic class Proxy extends Target {\n\n    private MethodInterceptor methodInterceptor;\n\n    public void setMethodInterceptor(MethodInterceptor methodInterceptor) {\n        this.methodInterceptor = methodInterceptor;\n    }\n\n    static Method save0;\n    static Method save1;\n    static Method save2;\n    static MethodProxy save0Proxy;\n    static MethodProxy save1Proxy;\n    static MethodProxy save2Proxy;\n    static {\n        try {\n            save0 = Target.class.getMethod(\"save\");\n            save1 = Target.class.getMethod(\"save\", int.class);\n            save2 = Target.class.getMethod(\"save\", long.class);\n            //\"()V\" 代表参数为空，返回值为void， \"(I)V\"代表参数为int类型，返回值为空\n            save0Proxy = MethodProxy.create(Target.class, Proxy.class, \"()V\", \"save\", \"saveSuper\");\n            save1Proxy = MethodProxy.create(Target.class, Proxy.class, \"(I)V\", \"save\", \"saveSuper\");\n            save2Proxy = MethodProxy.create(Target.class, Proxy.class, \"(J)V\", \"save\", \"saveSuper\");\n        } catch (NoSuchMethodException e) {\n            throw new NoSuchMethodError(e.getMessage());\n        }\n    }\n\n    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 带原始功能的方法\n    public void saveSuper() {\n        super.save();\n    }\n    public void saveSuper(int i) {\n        super.save(i);\n    }\n    public void saveSuper(long j) {\n        super.save(j);\n    }\n    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 带增强功能的方法\n    @Override\n    public void save() {\n        try {\n            methodInterceptor.intercept(this, save0, new Object[0], save0Proxy);\n        } catch (Throwable e) {\n            throw new UndeclaredThrowableException(e);\n        }\n    }\n\n    @Override\n    public void save(int i) {\n        try {\n            methodInterceptor.intercept(this, save1, new Object[]{i}, save1Proxy);\n        } catch (Throwable e) {\n            throw new UndeclaredThrowableException(e);\n        }\n    }\n\n    @Override\n    public void save(long j) {\n        try {\n            methodInterceptor.intercept(this, save2, new Object[]{j}, save2Proxy);\n        } catch (Throwable e) {\n            throw new UndeclaredThrowableException(e);\n        }\n    }\n}\n\n// 启动类\npublic class A13 {\n\n    public static void main(String[] args) {\n        Proxy proxy = new Proxy();\n        Target target = new Target();\n        proxy.setMethodInterceptor(new MethodInterceptor() {\n            @Override\n            public Object intercept(Object p, Method method, Object[] args,\n                                    MethodProxy methodProxy) throws Throwable {\n                System.out.println(\"before...\");\n                return method.invoke(target, args); // 反射调用\n                // FastClass\n//                return methodProxy.invoke(target, args); // 内部无反射, 结合目标用\n//                return methodProxy.invokeSuper(p, args); // 内部无反射, 结合代理用\n            }\n        });\n\n        proxy.save();\n        proxy.save(1);\n        proxy.save(2L);\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nbefore...\nsave()\nbefore...\nsave(int)\nbefore...\nsave(long)\n```\n\n## MethodProxy原理\n\n`methodProxy`的`invoke()`方法和`invokeSuper()`方法都可以避免反射调用，以提高动态代理的性能，接下来我们介绍这两种方法。\n\n### **invoke()**\n\ncglib在调用`invoke()`方法和`invokeSuper()`方法的时候会生成两个代理类，这两个代理类都继承了`org.springframework.cglib.reflect.FastClass`，这两个代理类中的一些关键方法就避免了反射。\n\n其中有两个关键抽象方法：\n\n```Java\npublic abstract int getIndex(Signature var1);\npublic abstract Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException;\n```\n\n接下来模拟`method.invoke()`方法的实现，取名叫`TargetFastClass`，主要实现以上两个抽象方法的功能，`TargetFastClass`会在`Proxy`调用`MethodProxy.create()`的时候创建：\n\n```Java\npublic class TargetFastClass {\n    static Signature s0 = new Signature(\"save\", \"()V\");\n    static Signature s1 = new Signature(\"save\", \"(I)V\");\n    static Signature s2 = new Signature(\"save\", \"(J)V\");\n\n    /**\n     * 根据方法信息获取目标方法的编号\n     * Target\n     *             save()              0\n     *             save(int)           1\n     *             save(long)          2\n     * signature 包括方法名字、参数返回值\n     * @param signature\n     * @return\n     */\n    public int getIndex(Signature signature) {\n        if (s0.equals(signature)) {\n            return 0;\n        } else if (s1.equals(signature)) {\n            return 1;\n        } else if (s2.equals(signature)) {\n            return 2;\n        }\n        return -1;\n    }\n\n    /**\n     * 根据方法编号, 正常调用目标对象方法\n     * @param index\n     * @param target\n     * @param args\n     * @return\n     */\n    public Object invoke(int index, Object target, Object[] args) {\n        if (index == 0) {\n            ((Target) target).save();\n            return null;\n        } else if (index == 1) {\n            ((Target) target).save((int) args[0]);\n            return null;\n        } else if (index == 2) {\n            ((Target) target).save((long) args[0]);\n            return null;\n        } else {\n            throw new RuntimeException(\"无此方法\");\n        }\n    }\n\n    public static void main(String[] args) {\n        TargetFastClass fastClass = new TargetFastClass();\n        int index = fastClass.getIndex(new Signature(\"save\", \"(I)V\"));\n        fastClass.invoke(index, new Target(), new Object[]{100});\n    }\n\n}\n```\n\n`method.invoke()`调用流程：\n\n1. 当proxy被创建时，会**初始化方法信息**，创建`MethodProxy`\n2. 调用`method.invoke(target, args)`时，会先根据签名获取index\n3. 根据传入的index，target，args参数调用`TargetFastClass`的`invoke()`方法\n\n### **invokeSuper()**\n\n接下来模拟`method.invoke()`方法的实现，取名叫`ProxyFastClass`：\n\n```Java\npublic class ProxyFastClass {\n    static Signature s0 = new Signature(\"saveSuper\", \"()V\");\n    static Signature s1 = new Signature(\"saveSuper\", \"(I)V\");\n    static Signature s2 = new Signature(\"saveSuper\", \"(J)V\");\n\n    /**\n     * 根据方法信息获取代理方法的编号\n     * Target\n     *             saveSuper()              0\n     *             saveSuper(int)           1\n     *             saveSuper(long)          2\n     * signature 包括方法名字、参数返回值\n     * @param signature\n     * @return\n     */\n    public int getIndex(Signature signature) {\n        if (s0.equals(signature)) {\n            return 0;\n        } else if (s1.equals(signature)) {\n            return 1;\n        } else if (s2.equals(signature)) {\n            return 2;\n        }\n        return -1;\n    }\n\n    /**\n     * 根据方法编号, 正常调用目标对象方法\n     * @param index\n     * @param proxy\n     * @param args\n     * @return\n     */\n    public Object invoke(int index, Object proxy, Object[] args) {\n        if (index == 0) {\n            ((Proxy) proxy).saveSuper();\n            return null;\n        } else if (index == 1) {\n            ((Proxy) proxy).saveSuper((int) args[0]);\n            return null;\n        } else if (index == 2) {\n            ((Proxy) proxy).saveSuper((long) args[0]);\n            return null;\n        } else {\n            throw new RuntimeException(\"无此方法\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ProxyFastClass fastClass = new ProxyFastClass();\n        int index = fastClass.getIndex(new Signature(\"saveSuper\", \"()V\"));\n        System.out.println(index);\n\n        fastClass.invoke(index, new Proxy(), new Object[0]);\n    }\n}\n```\n\n`ProxyFastClass`的实现和`TargetFastClass`类似，只不过传入的参数是代理类本身，并且在`invoke()`方法中调用的是`invokeSuper()`方法(原始方法)。\n\n`method.invokeSuper()`调用流程：\n\n1. 当proxy被创建时，会**初始化方法信息**，创建`MethodProxy`\n2. 调用`method.invoke(proxy, args)`时，会先根据签名获取index\n3. 根据传入的`proxy`，`target`，`args`参数调用`ProxyFastClass`的`invokeSuper()`方法\n\n**jdk与cglib动态代理对比：**\n\n- `jdk`动态代理需要先预热16次，再进行优化，并且每个方法会生成一个代理类\n- `cglib`动态代理直接就可以避免反射调用，并且一个类对应两个代理类(`FastClass`实现)\n\n# jdk和cglib的统一\n\n## spring的代理选择规则\n\n`aspect`切面与`advisor`切面的区别：\n\n1. `aspect = 通知1(advice) +  切点1(pointcut)`，一个aspect类中可以定义多个通知和切点。\n2. `advisor`是更细粒度的切面，包含一个通知和切点\n3. `aspect`最终生效解析之前会被拆解成多个`advisor`\n\n使用代理增强的步骤：\n\n1. 备好切点\n2. 备好通知\n3. 备好切面\n4. 创建代理\n\n切点在spring中是用`org.springframework.aop.Pointcut`来表示：\n\n```Java\npublic interface Pointcut {\n    Pointcut TRUE = TruePointcut.INSTANCE;\n    // 进行类过滤\n    ClassFilter getClassFilter();\n    // 进行方法匹配\n    MethodMatcher getMethodMatcher();\n}\n```\n\n可以看到比较常用的实现：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%91%EF%BC%9AAOP/1.png)\n\n比较重要的通知`org.aopalliance.intercept.MethodInterceptor`：\n\n```Java\n@FunctionalInterface\npublic interface MethodInterceptor extends Interceptor {\n    @Nullable\n    Object invoke(@Nonnull MethodInvocation invocation) throws Throwable;\n}\n```\n\n代码演示：\n\n```Java\npublic class A15 {\n    public static void main(String[] args) {\n        // 1. 备好切点\n        AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n        pointcut.setExpression(\"execution(* foo())\");\n        // 2. 备好通知\n        MethodInterceptor advice = invocation -> {\n            System.out.println(\"before...\");\n            // 调用目标\n            Object result = invocation.proceed(); \n            System.out.println(\"after...\");\n            return result;\n        };\n        // 3. 备好切面\n        DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, advice);\n        // 4. 创建代理\n        Target2 target = new Target2();\n        ProxyFactory factory = new ProxyFactory();\n        factory.setTarget(target);\n        factory.addAdvisor(advisor);\n        // 设置接口，使spring知道target实现了接口\n        factory.setInterfaces(target.getClass().getInterfaces());\n        // 设置setProxyTargetClass值\n        factory.setProxyTargetClass(false);\n        Target2 proxy = (Target2) factory.getProxy();\n        System.out.println(proxy.getClass());\n        proxy.foo();\n        proxy.bar();\n    }\n\n    interface I1 {\n        void foo();\n\n        void bar();\n    }\n\n    static class Target1 implements I1 {\n        public void foo() {\n            System.out.println(\"target1 foo\");\n        }\n\n        public void bar() {\n            System.out.println(\"target1 bar\");\n        }\n    }\n\n    static class Target2 {\n        public void foo() {\n            System.out.println(\"target2 foo\");\n        }\n\n        public void bar() {\n            System.out.println(\"target2 bar\");\n        }\n    }\n}\n```\n\n**spring的代理选择规则**\n\n`ProxyFactory`的间接父类中`ProxyConfig`有`proxyTargetClass`字段：\n\n1. `proxyTargetClass = false`，目标实现了接口, 用 jdk 实现\n2. `proxyTargetClass = false`，目标没有实现接口, 用 cglib 实现\n3. `proxyTargetClass = true`， 总是使用 cglib 实现\n\n## 底层的切点实现\n\n介绍切点匹配的方法，编写两个示例类：\n\n```Java\nstatic class T1 {\n    @Transactional\n    public void foo() {\n    }\n    public void bar() {\n    }\n}\n```\n\n创建启动类，根据**表达式**切入：\n\n```Java\npublic class A16 {\n    public static void main(String[] args) throws NoSuchMethodException {\n        AspectJExpressionPointcut pt1 = new AspectJExpressionPointcut();\n        pt1.setExpression(\"execution(* bar())\");\n        System.out.println(pt1.matches(T1.class.getMethod(\"foo\"), T1.class));\n        System.out.println(pt1.matches(T1.class.getMethod(\"bar\"), T1.class));\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nfalse \ntrue\n```\n\n`foo()`方法没有被表达式匹配，`bar()`成功匹配。\n\n创建启动类，根据**注解**切入：\n\n```Java\npublic class A16 {\n    public static void main(String[] args) throws NoSuchMethodException {\n        AspectJExpressionPointcut pt2 = new AspectJExpressionPointcut();\n        pt2.setExpression(\"@annotation(org.springframework.transaction.annotation.Transactional)\");\n        System.out.println(pt2.matches(T1.class.getMethod(\"foo\"), T1.class));\n        System.out.println(pt2.matches(T1.class.getMethod(\"bar\"), T1.class));\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\ntrue\nfalse\n```\n\n`foo()`方法被注解匹配，`bar()`没有被匹配。\n\n> @Transactional注解并不是使用AspectJExpressionPointcut这种方式来实现的\n\n`@Transactional`注解有多种使用方式：\n\n1. 加在方法上\n\n```Java\nstatic class T1 {\n    @Transactional\n    public void foo() {\n    }\n}\n```\n\n1. 加在类上\n\n```Java\n@Transactional\nstatic class T2 {\n    public void foo() {\n    }\n}\n```\n\n1. 加载接口上，实现类实现了该接口的方法将会生效\n\n```Java\n@Transactional\ninterface I3 {\n    void foo();\n}\nstatic class T3 implements I3 {\n    public void foo() {\n    }\n}\n```\n\n`AspectJExpressionPointcut`没法处理`@Transactional`注解的这些场景，因此我们这里模拟解析`@Transactional`注解的实现：\n\n```Java\npublic class A16 {\n    public static void main(String[] args) throws NoSuchMethodException {\n        StaticMethodMatcherPointcut pt3 = new StaticMethodMatcherPointcut() {\n            @Override\n            public boolean matches(Method method, Class<?> targetClass) {\n                // 检查方法上是否加了 Transactional 注解\n                MergedAnnotations annotations = MergedAnnotations.from(method);\n                if (annotations.isPresent(Transactional.class)) {\n                    return true;\n                }\n                // 查看类上是否加了 Transactional 注解 查看类上是否加了 Transactional 注解 搜索策略设置为TYPE_HIERARCHY会搜索本类、父类\n                annotations = MergedAnnotations.from(targetClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);\n                if (annotations.isPresent(Transactional.class)) {\n                    return true;\n                }\n                return false;\n            }\n        };\n\n        System.out.println(pt3.matches(T1.class.getMethod(\"foo\"), T1.class));\n        System.out.println(pt3.matches(T1.class.getMethod(\"bar\"), T1.class));\n        System.out.println(pt3.matches(T2.class.getMethod(\"foo\"), T2.class));\n        System.out.println(pt3.matches(T3.class.getMethod(\"foo\"), T3.class));\n    }\n\n\n    static class T1 {\n        @Transactional\n        public void foo() {\n        }\n        public void bar() {\n        }\n    }\n\n    @Transactional\n    static class T2 {\n        public void foo() {\n        }\n    }\n\n    @Transactional\n    interface I3 {\n        void foo();\n    }\n    static class T3 implements I3 {\n        public void foo() {\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\ntrue\nfalse\ntrue\ntrue\n```\n\n## 底层的切面实现\n\n准备代码：\n\n```Java\npackage org.springframework.aop.framework.autoproxy;\n\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.aop.Advisor;\nimport org.springframework.aop.aspectj.AspectJExpressionPointcut;\nimport org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator;\nimport org.springframework.aop.support.DefaultPointcutAdvisor;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.ConfigurationClassPostProcessor;\nimport org.springframework.context.support.GenericApplicationContext;\nimport org.springframework.core.annotation.Order;\n\nimport java.util.List;\n\npublic class A17 {\n    public static void main(String[] args) {\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"aspect1\", Aspect1.class);\n        context.registerBean(\"config\", Config.class);\n        context.registerBean(ConfigurationClassPostProcessor.class);\n        // BeanPostProcessor\n        // 创建 -> (*) 依赖注入 -> 初始化 (*)\n        context.refresh();\n        for (String name : context.getBeanDefinitionNames()) {\n            System.out.println(name);\n        }\n\n    }\n\n    static class Target1 {\n        public void foo() {\n            System.out.println(\"target1 foo\");\n        }\n    }\n\n    static class Target2 {\n        public void bar() {\n            System.out.println(\"target2 bar\");\n        }\n    }\n\n    @Aspect // 高级切面类\n    static class Aspect1 {\n        @Before(\"execution(* foo())\")\n        public void before1() {\n            System.out.println(\"aspect1 before1...\");\n        }\n\n        @Before(\"execution(* foo())\")\n        public void before2() {\n            System.out.println(\"aspect1 before2...\");\n        }\n    }\n\n    @Configuration\n    static class Config {\n        @Bean // 低级切面\n        public Advisor advisor3(MethodInterceptor advice3) {\n            AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n            pointcut.setExpression(\"execution(* foo())\");\n            DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, advice3);\n            return advisor;\n        }\n        @Bean\n        public MethodInterceptor advice3() {\n            return invocation -> {\n                System.out.println(\"advice3 before...\");\n                Object result = invocation.proceed();\n                System.out.println(\"advice3 after...\");\n                return result;\n            };\n        }\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\naspect1\nconfig\norg.springframework.context.annotation.ConfigurationClassPostProcessor\nadvisor3\nadvice3\n```\n\n### 底层切面实现\n\n底层切面实现用的是`AnnotationAwareAspectJAutoProxyCreator`，`AnnotationAwareAspectJAutoProxyCreator`是一个Bean后处理器，它有两个作用：\n\n- 找到容器中所有的切面，如果是`@Aspect`这种高级切面，会将其转换为`advisor`低级切面\n- 根据找到的切面创建代理对象\n\n查看其类图：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%91%EF%BC%9AAOP/2.png)\n\n我们发现它实现了`BeanPostProcessor`接口，对`Bean`进行了增强。`AnnotationAwareAspectJAutoProxyCreator`主要是在`Bean`**依赖注入**之前以及**初始化**之后进行了增强。它有两个比较重要的方法：\n\n- `findEligibleAdvisors()`：找到有资格的切面类，主要找的是`advisor`，如果是高级切面，会将其转换为低级切面\n- `wrapIfNecessary()`：针对符合要求的切面类创建代理\n\n这两个方法都被`protected`方法修饰，因此我们把测试类放在`org.springframework.aop.framework.autoproxy`包内。\n\n#### findEligibleAdvisors()\n\n此方法的功能是：根据给定的目标类型，查找与目标类型相匹配的所有切面。\n\n添加代码进行测试：\n\n首先将`AnnotationAwareAspectJAutoProxyCreator`类注入`spring`容器中：\n\n```Java\ncontext.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);\n```\n\n获取`AnnotationAwareAspectJAutoProxyCreator`，调用`findEligibleAdvisors()`方法，并打印切面\n\n```Java\nAnnotationAwareAspectJAutoProxyCreator creator = context.getBean(AnnotationAwareAspectJAutoProxyCreator.class);\nList<Advisor> advisors = creator.findEligibleAdvisors(Target1.class, \"target1\");\nfor (Advisor advisor : advisors) {\n    System.out.println(advisor);\n}\n```\n\n查看控制台：\n\n```Java\n// spring给我们添加的切面\norg.springframework.aop.interceptor.ExposeInvocationInterceptor.ADVISOR\n// 高级切面@Aspect转换后的低级切面，有两个。对应Aspect1类中的before1()方法和before2()方法\nInstantiationModelAwarePointcutAdvisor: expression [execution(* foo())]; advice method [public void org.springframework.aop.framework.autoproxy.A17$Aspect1.before1()]; perClauseKind=SINGLETON\nInstantiationModelAwarePointcutAdvisor: expression [execution(* foo())]; advice method [public void org.springframework.aop.framework.autoproxy.A17$Aspect1.before2()]; perClauseKind=SINGLETON\n// 低级切面，我们自己创建的DefaultPointcutAdvisor\norg.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.framework.autoproxy.A17$Config$$Lambda$117/0x0000000800d64fc0@558bdf1f]\n```\n\n#### wrapIfNecessary()\n\n此方法的功能是：是否有必要为我们的目标创建代理。\n\n思路很简单：调用`findEligibleAdvisors()`方法，如果返回值为空，那么说明不需要为这个类创建代理，反之需要创建单例。\n\n添加代码进行测试：\n\n```Java\nObject o1 = creator.wrapIfNecessary(new Target1(), \"target1\", \"target1\");\nSystem.out.println(o1.getClass());\nObject o2 = creator.wrapIfNecessary(new Target2(), \"target2\", \"target2\");\nSystem.out.println(o2.getClass());\n((Target1) o1).foo();\n```\n\n运行启动类，查看控制台：\n\n```Java\nclass org.springframework.aop.framework.autoproxy.A17$Target1$$EnhancerBySpringCGLIB$$253983d3\nclass org.springframework.aop.framework.autoproxy.A17$Target2\naspect1 before1...\naspect1 before2...\nadvice3 before...\ntarget1 foo\nadvice3 after...\n```\n\n我们发现`Target1`类已经被代理，调用`foo()`方法也能看到对方法的增强。\n\n### 代理对象创建的时机\n\n代理对象的创建位置在依赖注入之前或者是在初始化之后。\n\n暂时无法在飞书文档外展示此内容\n\n准备示例代码：\n\n```Java\npublic class A17_1 {\n\n    public static void main(String[] args) {\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(ConfigurationClassPostProcessor.class);\n        context.registerBean(Config.class);\n        context.refresh();\n        context.close();\n    }\n\n    @Configuration\n    static class Config {\n        @Bean // 解析 @Aspect、产生代理\n        public AnnotationAwareAspectJAutoProxyCreator annotationAwareAspectJAutoProxyCreator() {\n            return new AnnotationAwareAspectJAutoProxyCreator();\n        }\n\n        @Bean // 解析 @Autowired\n        public AutowiredAnnotationBeanPostProcessor autowiredAnnotationBeanPostProcessor() {\n            return new AutowiredAnnotationBeanPostProcessor();\n        }\n\n        @Bean // 解析 @PostConstruct\n        public CommonAnnotationBeanPostProcessor commonAnnotationBeanPostProcessor() {\n            return new CommonAnnotationBeanPostProcessor();\n        }\n\n        @Bean\n        public Advisor advisor(MethodInterceptor advice) {\n            AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n            pointcut.setExpression(\"execution(* foo())\");\n            return new DefaultPointcutAdvisor(pointcut, advice);\n        }\n\n        @Bean\n        public MethodInterceptor advice() {\n            return (MethodInvocation invocation) -> {\n                System.out.println(\"before...\");\n                return invocation.proceed();\n            };\n        }\n\n        @Bean\n        public Bean1 bean1() {\n            return new Bean1();\n        }\n\n        @Bean\n        public Bean2 bean2() {\n            return new Bean2();\n        }\n    }\n\n    static class Bean1 {\n        public void foo() {\n\n        }\n        public Bean1() {\n            System.out.println(\"Bean1()\");\n        }\n        @PostConstruct public void init() {\n            System.out.println(\"Bean1 init()\");\n        }\n    }\n\n    static class Bean2 {\n        public Bean2() {\n            System.out.println(\"Bean2()\");\n        }\n        @Autowired public void setBean1(Bean1 bean1) {\n            System.out.println(\"Bean2 setBean1(bean1) class is: \" + bean1.getClass());\n        }\n        @PostConstruct public void init() {\n            System.out.println(\"Bean2 init()\");\n        }\n    }\n}\n```\n\n> 上述代码Bean2依赖注入了Bean1。\n\n查看控制台：\n\n```Plain\n[INFO ] 21:59:12.415 [main] o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean 'org.springframework.aop.framework.autoproxy.A17_1$Config' of type [org.springframework.aop.framework.autoproxy.A17_1$Config$$EnhancerBySpringCGLIB$$4ebf3912] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) \n[TRACE] 21:59:12.474 [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Did not attempt to auto-proxy infrastructure class [org.springframework.aop.Advisor] \n[TRACE] 21:59:12.476 [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Did not attempt to auto-proxy infrastructure class [org.aopalliance.intercept.MethodInterceptor] \nBean1()\nBean1 init()\n[TRACE] 21:59:12.575 [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Creating implicit proxy for bean 'bean1' with 0 common interceptors and 2 specific interceptors \nBean2()\nBean2 setBean1(bean1) class is: class org.springframework.aop.framework.autoproxy.A17_1$Bean1$$EnhancerBySpringCGLIB$$2d106fac\nBean2 init()\n```\n\n发现`Bean1`的代理对象是在初始化之后被创建的。\n\n更改`Bean1`类，使其与`Bean2`循环依赖：\n\n```Java\nstatic class Bean1 {\n    public void foo() {\n\n    }\n    public Bean1() {\n        System.out.println(\"Bean1()\");\n    }\n    @Autowired public void setBean2(Bean2 bean2) {\n        System.out.println(\"Bean1 setBean2(bean2) class is: \" + bean2.getClass());\n    }\n    @PostConstruct public void init() {\n        System.out.println(\"Bean1 init()\");\n    }\n}\n```\n\n查看控制台：\n\n```Plain\n[INFO ] 22:02:35.788 [main] o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean 'org.springframework.aop.framework.autoproxy.A17_1$Config' of type [org.springframework.aop.framework.autoproxy.A17_1$Config$$EnhancerBySpringCGLIB$$4ebf3912] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) \n[TRACE] 22:02:35.850 [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Did not attempt to auto-proxy infrastructure class [org.springframework.aop.Advisor] \n[TRACE] 22:02:35.852 [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Did not attempt to auto-proxy infrastructure class [org.aopalliance.intercept.MethodInterceptor] \nBean1()\nBean2()\n[TRACE] 22:02:36.015 [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Creating implicit proxy for bean 'bean1' with 0 common interceptors and 2 specific interceptors \nBean2 setBean1(bean1) class is: class org.springframework.aop.framework.autoproxy.A17_1$Bean1$$EnhancerBySpringCGLIB$$2741d750\nBean2 init()\nBean1 setBean2(bean2) class is: class org.springframework.aop.framework.autoproxy.A17_1$Bean2\nBean1 init()\n```\n\n发现`Bean1`代理对象的创建提前在`Bean1`初始化之前了，这是因为`Bean2`需要注入的使`Bean1`的代理对象，而不是原始对象。\n\n**总结：**\n\n1. 代理的创建时机\n    1. 初始化之后 (无循环依赖时)\n    2. 实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存\n2. 依赖注入与初始化不应该被增强, 仍应被施加于原始对象\n\n### 高级切面转换为低级切面\n\n在`findEligibleAdvisors()`方法执行时，会将遇到的`Aspect`切面转换为`advisor`的实现，这里介绍将高级切面转换为低级切面的过程。\n\n编写示例代码：\n\n```Java\npublic class A17_2 {\n\n    static class Aspect {\n        @Before(\"execution(* foo())\")\n        public void before1() {\n            System.out.println(\"before1\");\n        }\n\n        @Before(\"execution(* foo())\")\n        public void before2() {\n            System.out.println(\"before2\");\n        }\n\n        public void after() {\n            System.out.println(\"after\");\n        }\n\n        public void afterReturning() {\n            System.out.println(\"afterReturning\");\n        }\n\n        public void afterThrowing() {\n            System.out.println(\"afterThrowing\");\n        }\n\n        public Object around(ProceedingJoinPoint pjp) throws Throwable {\n            try {\n                System.out.println(\"around...before\");\n                return pjp.proceed();\n            } finally {\n                System.out.println(\"around...after\");\n            }\n        }\n    }\n\n    static class Target {\n        public void foo() {\n            System.out.println(\"target foo\");\n        }\n    }\n\n    @SuppressWarnings(\"all\")\n    public static void main(String[] args) throws Throwable {\n\n        AspectInstanceFactory factory = new SingletonAspectInstanceFactory(new Aspect());\n        // 高级切面转低级切面类\n        List<Advisor> list = new ArrayList<>();\n        for (Method method : Aspect.class.getDeclaredMethods()) {\n            if (method.isAnnotationPresent(Before.class)) {\n                // 解析切点\n                String expression = method.getAnnotation(Before.class).value();\n                AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n                pointcut.setExpression(expression);\n                // 通知类\n                AspectJMethodBeforeAdvice advice = new AspectJMethodBeforeAdvice(method, pointcut, factory);\n                // 切面\n                Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice);\n                list.add(advisor);\n            }\n        }\n        for (Advisor advisor : list) {\n            System.out.println(advisor);\n        }\n\n    }\n}\n```\n\n`@Before`前置通知会被转换为原始的 `AspectJMethodBeforeAdvice `形式，该对象包含了如下信息：\n\n1. 通知代码从哪儿来\n2. 切点是什么\n3. 通知对象如何创建, 本例共用同一个`Aspect`对象\n\n除了`AspectJMethodBeforeAdvice`，类似的通知还有：\n\n1. `AspectJAroundAdvice `(环绕通知)\n2. `AspectJAfterReturningAdvice`\n3. `AspectJAfterThrowingAdvice`\n4. `AspectJAfterAdvice `(环绕通知)\n\n### @Order注解\n\n编写示例代码：\n\n```Java\npublic class A17 {\n    public static void main(String[] args) {\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"aspect1\", Aspect1.class);\n        context.registerBean(\"config\", Config.class);\n        context.registerBean(ConfigurationClassPostProcessor.class);\n        context.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);\n        context.refresh();\n        Object o1 = creator.wrapIfNecessary(new Target1(), \"target1\", \"target1\");\n        ((Target1) o1).foo();\n    }\n\n    static class Target1 {\n        public void foo() {\n            System.out.println(\"target1 foo\");\n        }\n    }\n\n    static class Target2 {\n        public void bar() {\n            System.out.println(\"target2 bar\");\n        }\n    }\n\n    @Aspect // 高级切面类\n    static class Aspect1 {\n        @Before(\"execution(* foo())\")\n        public void before1() {\n            System.out.println(\"aspect1 before1...\");\n        }\n        \n       @After(\"execution(* foo())\")\n       public void before2() {\n           System.out.println(\"aspect1 after1...\");\n       }\n    }\n\n    @Configuration\n    static class Config {\n        @Bean // 低级切面\n        public Advisor advisor3(MethodInterceptor advice3) {\n            AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n            pointcut.setExpression(\"execution(* foo())\");\n            DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, advice3);\n            return advisor;\n        }\n        @Bean\n        public MethodInterceptor advice3() {\n            return invocation -> {\n                System.out.println(\"advice3 before...\");\n                Object result = invocation.proceed();\n                System.out.println(\"advice3 after...\");\n                return result;\n            };\n        }\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nadvice3 before...\naspect1 before1...\ntarget1 foo\naspect1 after1...\nadvice3 after...\n```\n\n我们发现默认`advisor`实现的代理先执行，`@Aspect`注解实现的代理后执行，对于`@Aspect`切面方式来讲，我们可以使用`@Order`注解调整代理的优先级：\n\n```Java\n@Aspect // 高级切面类\n@Order(1)\nstatic class Aspect1 {\n    @Before(\"execution(* foo())\")\n    public void before1() {\n        System.out.println(\"aspect1 before1...\");\n    }\n    \n    @After(\"execution(* foo())\")\n    public void before2() {\n       System.out.println(\"aspect1 after1...\");\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\naspect1 before1...\nadvice3 before...\ntarget1 foo\nadvice3 after...\naspect1 after1...\n```\n\n对于`advisor`切面方式，我们可以使用`setOrder()`方法设置优先级：\n\n```Java\n@Configuration\nstatic class Config {\n    @Bean // 低级切面\n    public Advisor advisor3(MethodInterceptor advice3) {\n        AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n        pointcut.setExpression(\"execution(* foo())\");\n        DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, advice3);\n        advisor.setOrder(1);\n        return advisor;\n    }\n    @Bean\n    public MethodInterceptor advice3() {\n        return invocation -> {\n            System.out.println(\"advice3 before...\");\n            Object result = invocation.proceed();\n            System.out.println(\"advice3 after...\");\n            return result;\n        };\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nadvice3 before...\naspect1 before1...\ntarget1 foo\naspect1 after1...\nadvice3 after...\n```\n\n**缺点：**\n\n- `@Order`注解只能加在@Aspect 类上\n- 类中所有方法的`order`权值都相同\n\n## 底层的通知实现\n\n### 统一转换为环绕通知\n\n其实无论`ProxyFactory`基于哪种方式创建代理, 最后干活(调用`advice`)的是一个`MethodInvocation`对象\n\n1. 因为`advisor`有多个, 且一个套一个调用, 因此需要一个调用链对象, 即`MethodInvocation`\n2. `MethodInvocation`要知道`advice`有哪些, 还要知道目标, 调用次序如下\n\n```Plain\n将 MethodInvocation 放入当前线程\n    |-> before1 ----------------------------------- 从当前线程获取 MethodInvocation\n    |                                             |\n    |   |-> before2 --------------------          | 从当前线程获取 MethodInvocation\n    |   |                              |          |\n    |   |   |-> target ------ 目标   advice2    advice1\n    |   |                              |          |\n    |   |-> after2 ---------------------          |\n    |                                             |\n    |-> after1 ------------------------------------\n```\n\n> 从上图看出, 环绕通知才适合作为 advice, 因此其他 before、afterReturning 都会被转换成环绕通知\n\n统一转换为环绕通知, 体现的是设计模式中的适配器模式：\n\n1. 对外是为了方便使用要区分 before、afterReturning\n2. 对内统一都是环绕通知, 统一用 MethodInterceptor 表示\n\n示例代码：\n\n```Java\npublic class A18 {\n\n    static class Aspect {\n        @Before(\"execution(* foo())\")\n        public void before1() {\n            System.out.println(\"before1\");\n        }\n\n        @Before(\"execution(* foo())\")\n        public void before2() {\n            System.out.println(\"before2\");\n        }\n\n        public void after() {\n            System.out.println(\"after\");\n        }\n\n        @AfterReturning(\"execution(* foo())\")\n        public void afterReturning() {\n            System.out.println(\"afterReturning\");\n        }\n\n        @AfterThrowing(\"execution(* foo())\")\n        public void afterThrowing(Exception e) {\n            System.out.println(\"afterThrowing \" + e.getMessage());\n        }\n\n        @Around(\"execution(* foo())\")\n        public Object around(ProceedingJoinPoint pjp) throws Throwable {\n            try {\n                System.out.println(\"around...before\");\n                return pjp.proceed();\n            } finally {\n                System.out.println(\"around...after\");\n            }\n        }\n    }\n\n    static class Target {\n        public void foo() {\n            System.out.println(\"target foo\");\n        }\n    }\n\n    @SuppressWarnings(\"all\")\n    public static void main(String[] args) throws Throwable {\n\n        AspectInstanceFactory factory = new SingletonAspectInstanceFactory(new Aspect());\n        // 1. 高级切面转低级切面类\n        List<Advisor> list = new ArrayList<>();\n        for (Method method : Aspect.class.getDeclaredMethods()) {\n            if (method.isAnnotationPresent(Before.class)) {\n                // 解析切点\n                String expression = method.getAnnotation(Before.class).value();\n                AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n                pointcut.setExpression(expression);\n                // 通知类\n                AspectJMethodBeforeAdvice advice = new AspectJMethodBeforeAdvice(method, pointcut, factory);\n                // 切面\n                Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice);\n                list.add(advisor);\n            } else if (method.isAnnotationPresent(AfterReturning.class)) {\n                // 解析切点\n                String expression = method.getAnnotation(AfterReturning.class).value();\n                AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n                pointcut.setExpression(expression);\n                // 通知类\n                AspectJAfterReturningAdvice advice = new AspectJAfterReturningAdvice(method, pointcut, factory);\n                // 切面\n                Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice);\n                list.add(advisor);\n            } else if (method.isAnnotationPresent(Around.class)) {\n                // 解析切点\n                String expression = method.getAnnotation(Around.class).value();\n                AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n                pointcut.setExpression(expression);\n                // 通知类\n                AspectJAroundAdvice advice = new AspectJAroundAdvice(method, pointcut, factory);\n                // 切面\n                Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice);\n                list.add(advisor);\n            }\n        }\n        for (Advisor advisor : list) {\n            System.out.println(advisor);\n        }\n        Target target = new Target();\n        ProxyFactory proxyFactory = new ProxyFactory();\n        proxyFactory.setTarget(target);\n        proxyFactory.addAdvisors(list);\n\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\");\n        List<Object> methodInterceptorList = proxyFactory.getInterceptorsAndDynamicInterceptionAdvice(Target.class.getMethod(\"foo\"), Target.class);\n        for (Object o : methodInterceptorList) {\n            System.out.println(o);\n        }\n\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\norg.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJMethodBeforeAdvice: advice method [public void org.springframework.aop.framework.A18$Aspect.before1()]; aspect name '']\norg.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJAfterReturningAdvice: advice method [public void org.springframework.aop.framework.A18$Aspect.afterReturning()]; aspect name '']\norg.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJMethodBeforeAdvice: advice method [public void org.springframework.aop.framework.A18$Aspect.before2()]; aspect name '']\norg.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJAroundAdvice: advice method [public java.lang.Object org.springframework.aop.framework.A18$Aspect.around(org.aspectj.lang.ProceedingJoinPoint) throws java.lang.Throwable]; aspect name '']\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\norg.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@52bf72b5\norg.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor@37afeb11\norg.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@515aebb0\norg.springframework.aop.aspectj.AspectJAroundAdvice: advice method [public java.lang.Object org.springframework.aop.framework.A18$Aspect.around(org.aspectj.lang.ProceedingJoinPoint) throws java.lang.Throwable]; aspect name ''\n```\n\n我们发现`AspectJMethodBeforeAdvice`已经被转换为`MethodBeforeAdviceInterceptor`，`AspectJAfterReturningAdvice`被转换为`AfterReturningAdviceInterceptor`，`AspectJAroundAdvice`本身就是环绕通知，不用被转换。\n\n事实上只要实现`MethodInterceptor`接口的都不用转换：\n\n1. `AspectJMethodBeforeAdvice`(前置通知)：未实现`MethodInterceptor`接口。\n2. `AspectJAroundAdvice`(环绕通知)：实现了`MethodInterceptor`接口。\n3. `AspectJAfterReturningAdvice`：未实现`MethodInterceptor`接口。\n4. `AspectJAfterThrowingAdvice`：实现了`MethodInterceptor`接口。\n5. `AspectJAfterAdvice`：实现了`MethodInterceptor`接口。\n\n### 适配器模式\n\n对于通知解析，我们需要的是`MethodInterceptor`接口，但解析后可能是另外的接口，因此需要将不符合`MethodInterceptor`接口的类转换为实现`MethodInterceptor`接口的类，这就需要使用到适配器模式。\n\n1. 统一转换为 `MethodInterceptor`环绕通知, 这体现在方法名中的`Interceptors`上\n2. 适配如下：\n    1. `MethodBeforeAdviceAdapter`将`@Before` `AspectJMethodBeforeAdvice `适配为`MethodBeforeAdviceInterceptor`\n    2. `AfterReturningAdviceAdapter`将 `@AfterReturning` `AspectJAfterReturningAdvice`适配为 `AfterReturningAdviceInterceptor`\n\n我们可以查看`MethodBeforeAdviceAdapter`类：\n\n```Java\nclass MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {\n    MethodBeforeAdviceAdapter() {\n    }\n\n    /**\n    * 判断是否属于MethodBeforeAdvice \n    */\n    public boolean supportsAdvice(Advice advice) {\n        return advice instanceof MethodBeforeAdvice;\n    }\n\n    /**\n    * 将Advice转换为MethodInterceptor \n    */\n    public MethodInterceptor getInterceptor(Advisor advisor) {\n        MethodBeforeAdvice advice = (MethodBeforeAdvice)advisor.getAdvice();\n        return new MethodBeforeAdviceInterceptor(advice);\n    }\n}\n```\n\n查看`AfterReturningAdviceAdapter`类：\n\n```Java\nclass AfterReturningAdviceAdapter implements AdvisorAdapter, Serializable {\n    AfterReturningAdviceAdapter() {\n    }\n\n    /**\n    * 判断是否属于AfterReturningAdvice\n    */\n    public boolean supportsAdvice(Advice advice) {\n        return advice instanceof AfterReturningAdvice;\n    }\n\n    /**\n    * 将Advice转换为MethodInterceptor \n    */\n    public MethodInterceptor getInterceptor(Advisor advisor) {\n        AfterReturningAdvice advice = (AfterReturningAdvice)advisor.getAdvice();\n        return new AfterReturningAdviceInterceptor(advice);\n    }\n}\n```\n\n### 调用链的执行\n\n通知统一转换为环绕通知之后，需要使用调用链来进行调用，调用链=所有的环绕通知+目标。\n\n添加调用链并执行：\n\n```Java\n// 3. 创建并执行调用链 (环绕通知s + 目标)\nMethodInvocation methodInvocation = new ReflectiveMethodInvocation(\n        null, target, Target.class.getMethod(\"foo\"), new Object[0], Target.class, methodInterceptorList\n);\nmethodInvocation.proceed();\n```\n\n运行后会发现报错：\n\n```Plain\nException in thread \"main\" java.lang.IllegalStateException: No MethodInvocation found: Check that an AOP invocation is in progress and that the ExposeInvocationInterceptor is upfront in the interceptor chain. Specifically, note that advices with order HIGHEST_PRECEDENCE will execute before ExposeInvocationInterceptor! In addition, ExposeInvocationInterceptor and ExposeInvocationInterceptor.currentInvocation() must be invoked from the same thread.\n        at org.springframework.aop.interceptor.ExposeInvocationInterceptor.currentInvocation(ExposeInvocationInterceptor.java:74)\n        at org.springframework.aop.aspectj.AbstractAspectJAdvice.getJoinPointMatch(AbstractAspectJAdvice.java:658)\n        at org.springframework.aop.aspectj.AspectJMethodBeforeAdvice.before(AspectJMethodBeforeAdvice.java:44)\n        at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:57)\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\n        at org.springframework.aop.framework.A18.main(A18.java:162)\n```\n\n这是因为某些通知内部需要用到调用链对象，所以应该在最外层将调用链对象准备好，将 MethodInvocation 放入当前线程：\n\n```Java\nproxyFactory.addAdvice(ExposeInvocationInterceptor.INSTANCE); // 准备把 MethodInvocation 放入当前线程\n```\n\n完整示例代码：\n\n```Java\npublic class A18 {\n\n    static class Aspect {\n        @Before(\"execution(* foo())\")\n        public void before1() {\n            System.out.println(\"before1\");\n        }\n\n        @Before(\"execution(* foo())\")\n        public void before2() {\n            System.out.println(\"before2\");\n        }\n\n        public void after() {\n            System.out.println(\"after\");\n        }\n\n        @AfterReturning(\"execution(* foo())\")\n        public void afterReturning() {\n            System.out.println(\"afterReturning\");\n        }\n\n        @AfterThrowing(\"execution(* foo())\")\n        public void afterThrowing(Exception e) {\n            System.out.println(\"afterThrowing \" + e.getMessage());\n        }\n\n        @Around(\"execution(* foo())\")\n        public Object around(ProceedingJoinPoint pjp) throws Throwable {\n            try {\n                System.out.println(\"around...before\");\n                return pjp.proceed();\n            } finally {\n                System.out.println(\"around...after\");\n            }\n        }\n    }\n\n    static class Target {\n        public void foo() {\n            System.out.println(\"target foo\");\n        }\n    }\n\n    @SuppressWarnings(\"all\")\n    public static void main(String[] args) throws Throwable {\n\n        AspectInstanceFactory factory = new SingletonAspectInstanceFactory(new Aspect());\n        // 1. 高级切面转低级切面类\n        List<Advisor> list = new ArrayList<>();\n        for (Method method : Aspect.class.getDeclaredMethods()) {\n            if (method.isAnnotationPresent(Before.class)) {\n                // 解析切点\n                String expression = method.getAnnotation(Before.class).value();\n                AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n                pointcut.setExpression(expression);\n                // 通知类\n                AspectJMethodBeforeAdvice advice = new AspectJMethodBeforeAdvice(method, pointcut, factory);\n                // 切面\n                Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice);\n                list.add(advisor);\n            } else if (method.isAnnotationPresent(AfterReturning.class)) {\n                // 解析切点\n                String expression = method.getAnnotation(AfterReturning.class).value();\n                AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n                pointcut.setExpression(expression);\n                // 通知类\n                AspectJAfterReturningAdvice advice = new AspectJAfterReturningAdvice(method, pointcut, factory);\n                // 切面\n                Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice);\n                list.add(advisor);\n            } else if (method.isAnnotationPresent(Around.class)) {\n                // 解析切点\n                String expression = method.getAnnotation(Around.class).value();\n                AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\n                pointcut.setExpression(expression);\n                // 通知类\n                AspectJAroundAdvice advice = new AspectJAroundAdvice(method, pointcut, factory);\n                // 切面\n                Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice);\n                list.add(advisor);\n            }\n        }\n        for (Advisor advisor : list) {\n            System.out.println(advisor);\n        }\n        Target target = new Target();\n        ProxyFactory proxyFactory = new ProxyFactory();\n        proxyFactory.setTarget(target);\n        proxyFactory.addAdvice(ExposeInvocationInterceptor.INSTANCE); // 准备把 MethodInvocation 放入当前线程\n        proxyFactory.addAdvisors(list);\n\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\");\n        List<Object> methodInterceptorList = proxyFactory.getInterceptorsAndDynamicInterceptionAdvice(Target.class.getMethod(\"foo\"), Target.class);\n        for (Object o : methodInterceptorList) {\n            System.out.println(o);\n        }\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\");\n        // 3. 创建并执行调用链 (环绕通知s + 目标)\n        MethodInvocation methodInvocation = new ReflectiveMethodInvocation(\n                null, target, Target.class.getMethod(\"foo\"), new Object[0], Target.class, methodInterceptorList\n        );\n        methodInvocation.proceed();\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Java\norg.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJMethodBeforeAdvice: advice method [public void org.springframework.aop.framework.A18$Aspect.before1()]; aspect name '']\norg.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJMethodBeforeAdvice: advice method [public void org.springframework.aop.framework.A18$Aspect.before2()]; aspect name '']\norg.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJAroundAdvice: advice method [public java.lang.Object org.springframework.aop.framework.A18$Aspect.around(org.aspectj.lang.ProceedingJoinPoint) throws java.lang.Throwable]; aspect name '']\norg.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJAfterReturningAdvice: advice method [public void org.springframework.aop.framework.A18$Aspect.afterReturning()]; aspect name '']\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\norg.springframework.aop.interceptor.ExposeInvocationInterceptor@1d2adfbe\norg.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@36902638\norg.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@223d2c72\norg.springframework.aop.aspectj.AspectJAroundAdvice: advice method [public java.lang.Object org.springframework.aop.framework.A18$Aspect.around(org.aspectj.lang.ProceedingJoinPoint) throws java.lang.Throwable]; aspect name ''\norg.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor@8f4ea7c\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nbefore1\nbefore2\naround...before\ntarget foo\nafterReturning\naround...after\n```\n\n成功执行了调用链。\n\n### 模拟实现调用链\n\n调用链实际上是使用的责任链模式，示例代码实现：\n\n```Java\n/**\n * 模拟调用链过程, 是一个简单的递归过程\n *         1. proceed() 方法调用链中下一个环绕通知\n *         2. 每个环绕通知内部继续调用 proceed()\n *         3. 调用到没有更多通知了, 就调用目标方法\n */\npublic class A18_1 {\n\n    static class Target {\n        public void foo() {\n            System.out.println(\"Target.foo()\");\n        }\n    }\n\n    static class Advice1 implements MethodInterceptor {\n        public Object invoke(MethodInvocation invocation) throws Throwable {\n            System.out.println(\"Advice1.before()\");\n            Object result = invocation.proceed();// 调用下一个通知或目标\n            System.out.println(\"Advice1.after()\");\n            return result;\n        }\n    }\n\n    static class Advice2 implements MethodInterceptor {\n        public Object invoke(MethodInvocation invocation) throws Throwable {\n            System.out.println(\"Advice2.before()\");\n            Object result = invocation.proceed();// 调用下一个通知或目标\n            System.out.println(\"Advice2.after()\");\n            return result;\n        }\n    }\n\n\n    static class MyInvocation implements MethodInvocation {\n        private Object target;  // 1\n        private Method method;\n        private Object[] args;\n        List<MethodInterceptor> methodInterceptorList; // 2\n        private int count = 1; // 调用次数\n\n        public MyInvocation(Object target, Method method, Object[] args, List<MethodInterceptor> methodInterceptorList) {\n            this.target = target;\n            this.method = method;\n            this.args = args;\n            this.methodInterceptorList = methodInterceptorList;\n        }\n\n        @Override\n        public Method getMethod() {\n            return method;\n        }\n\n        @Override\n        public Object[] getArguments() {\n            return args;\n        }\n\n        @Override\n        public Object proceed() throws Throwable { // 调用每一个环绕通知, 调用目标\n            if (count > methodInterceptorList.size()) {\n                // 调用目标， 返回并结束递归\n                return method.invoke(target, args);\n            }\n            // 逐一调用通知, count + 1\n            MethodInterceptor methodInterceptor = methodInterceptorList.get(count++ - 1);\n            return methodInterceptor.invoke(this);\n        }\n\n        @Override\n        public Object getThis() {\n            return target;\n        }\n\n        @Override\n        public AccessibleObject getStaticPart() {\n            return method;\n        }\n    }\n\n    public static void main(String[] args) throws Throwable {\n        Target target = new Target();\n        List<MethodInterceptor> list = List.of(\n                new Advice1(),\n                new Advice2()\n        );\n        MyInvocation invocation = new MyInvocation(target, Target.class.getMethod(\"foo\"), new Object[0], list);\n        invocation.proceed();\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\nAdvice1.before()\nAdvice2.before()\nTarget.foo()\nAdvice2.after()\nAdvice1.after()\n```\n\n### 动态通知调用\n\n静态通知与动态通知对比：\n\n1. 静态通知调用，不带参数绑定，执行时不需要切点\n2. 动态通知调用，需要参数绑定，执行时还需要切点对象\n\n```Java\n@Aspect\nstatic class MyAspect {\n    \n    /**\n    * 静态通知调用\n    */\n    @Before(\"execution(* foo(..))\") // \n    public void before1() {\n        System.out.println(\"before1\");\n    }\n\n    /**\n    * 动态通知调用\n    */\n    @Before(\"execution(* foo(..)) && args(x)\")\n    public void before2(int x) {\n        System.out.printf(\"before2(%d)%n\", x);\n    }\n}\n```\n\n示例代码：\n\n```Java\npublic class A19 {\n\n    @Aspect\n    static class MyAspect {\n        @Before(\"execution(* foo(..))\") // 静态通知调用，不带参数绑定，执行时不需要切点\n        public void before1() {\n            System.out.println(\"before1\");\n        }\n\n        @Before(\"execution(* foo(..)) && args(x)\") // 动态通知调用，需要参数绑定，执行时还需要切点对象\n        public void before2(int x) {\n            System.out.printf(\"before2(%d)%n\", x);\n        }\n    }\n\n    static class Target {\n        public void foo(int x) {\n            System.out.printf(\"target foo(%d)%n\", x);\n        }\n    }\n\n    @Configuration\n    static class MyConfig {\n        @Bean\n        AnnotationAwareAspectJAutoProxyCreator proxyCreator() {\n            return new AnnotationAwareAspectJAutoProxyCreator();\n        }\n\n        @Bean\n        public MyAspect myAspect() {\n            return new MyAspect();\n        }\n    }\n\n    public static void main(String[] args) throws Throwable {\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(ConfigurationClassPostProcessor.class);\n        context.registerBean(MyConfig.class);\n        context.refresh();\n\n        AnnotationAwareAspectJAutoProxyCreator creator = context.getBean(AnnotationAwareAspectJAutoProxyCreator.class);\n        List<Advisor> list = creator.findEligibleAdvisors(Target.class, \"target\");\n\n        Target target = new Target();\n        ProxyFactory factory = new ProxyFactory();\n        factory.setTarget(target);\n        factory.addAdvisors(list);\n        Object proxy = factory.getProxy(); // 获取代理\n\n        List<Object> interceptorList = factory.getInterceptorsAndDynamicInterceptionAdvice(Target.class.getMethod(\"foo\", int.class), Target.class);\n        for (Object o : interceptorList) {\n            showDetail(o);\n        }\n\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>\");\n        ReflectiveMethodInvocation invocation = new ReflectiveMethodInvocation(\n                proxy, target, Target.class.getMethod(\"foo\", int.class), new Object[]{100}, Target.class, interceptorList\n        ) {};\n\n        invocation.proceed();\n    }\n\n    public static void showDetail(Object o) {\n        try {\n            Class<?> clazz = Class.forName(\"org.springframework.aop.framework.InterceptorAndDynamicMethodMatcher\");\n            if (clazz.isInstance(o)) {\n                Field methodMatcher = clazz.getDeclaredField(\"methodMatcher\");\n                methodMatcher.setAccessible(true);\n                Field methodInterceptor = clazz.getDeclaredField(\"interceptor\");\n                methodInterceptor.setAccessible(true);\n                System.out.println(\"环绕通知和切点：\" + o);\n                System.out.println(\"\\t切点为：\" + methodMatcher.get(o));\n                System.out.println(\"\\t通知为：\" + methodInterceptor.get(o));\n            } else {\n                System.out.println(\"普通环绕通知：\" + o);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[INFO ] 16:25:32.123 [main] o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean 'org.springframework.aop.framework.autoproxy.A19$MyConfig' of type [org.springframework.aop.framework.autoproxy.A19$MyConfig$$EnhancerBySpringCGLIB$$4d8924fd] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) \n普通环绕通知：org.springframework.aop.interceptor.ExposeInvocationInterceptor@63fbfaeb\n普通环绕通知：org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@2c07545f\n环绕通知和切点：org.springframework.aop.framework.InterceptorAndDynamicMethodMatcher@e57b96d\n        切点为：AspectJExpressionPointcut: (int x) execution(* foo(..)) && args(x)\n        通知为：org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@34c01041\n>>>>>>>>>>>>>>>>>>>>>>>>>>\nbefore1\nbefore2(100)\ntarget foo(100)\n```\n\n进入`InterceptorAndDynamicMethodMatcher`中，我们发现它没有实现`MethodInterceptor`接口，但其成员变量却有：\n\n```Java\n// 记录通知\nfinal MethodInterceptor interceptor;\n// 记录切点\nfinal MethodMatcher methodMatcher;\n```\n\n我们在使用`invocation`调用的时候，需要传入参数。\n\n**总结：**\n\n1. 有参数绑定的通知调用时还需要切点，对参数进行匹配及绑定\n2. 复杂程度高, 性能比无参数绑定的通知调用低\n","tags":["spring"],"categories":["原理探究"]},{"title":"Spring高级45讲【第二章】：IOC","url":"/2023/04/15/Spring高级45讲【第二章】：IOC.html","content":"\n# 容器接口\n\n以`SpringBoot`的启动类为例：\n\n```Java\n@SpringBootApplication\npublic class A01{\n    public static void main(String[] args) {\n        SpringApplication.run(A01.class, args);\n    }\n}\n```\n\n容器启动的`run()`方法是有返回值的：\n\n```Java\nConfigurableApplicationContext context = SpringApplication.run(A01.class, args);\n```\n\n在 IDEA 中使用快捷键Ctrl +Alt +U查看 `ConfigurableApplicationContext` 类的类图:\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%91%EF%BC%9AIOC/1.png)\n\n`ConfigurableApplicationContext`接口继承了`ApplicationContext`接口，而\n\n`ApplicationContext `接口又间接地继承了`BeanFactory `接口，除此之外还继承了其他很多接口，相当于对`BeanFactory `进行了拓展。\n\n到底什么是 `BeanFactory`？\n\n1. 它是 `ApplicationContext` 的父接口\n2. 它才是 `Spring` 的核心容器, 主要的 `ApplicationContext` 实现都**组合**了它的功能\n\n举一个例子：\n\n使用`context`根据名称获取`Bean`：\n\n```Java\nObject bean = context.getBean(\"Bean\");\n```\n\nCtrl +Alt +B查看实现类：\n\n进入到了`AbstractApplicationContext`类中的方法，我们发现首先获取`BeanFactory`，再调用`BeanFactory`的`getBean()`方法获取`Bean`，说明`BeanFactory`更加核心。\n\n```Java\npublic Object getBean(String name) throws BeansException {\n    this.assertBeanFactoryActive();\n    return this.getBeanFactory().getBean(name);\n}\n```\n\n## BeanFactory的功能\n\n进入`BeanFactory`接口，在IDEA中使用快捷键Ctrl + F12查看这个接口中所有的方法定义:\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%91%EF%BC%9AIOC/2.png)\n\n`BeanFactory`能干点啥？\n\n1. 表面上只有`getBean()`功能\n2. 实际上**控制反转、基本的依赖注入、直至 Bean 的生命周期的各种功能**, 都由它的实现类提供\n\n打开 `BeanFactory` 的实现类 `DefaultListableBeanFactory`，查看其类图：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%91%EF%BC%9AIOC/3.png)\n\n`DefaultListableBeanFactory`实现了`BeanFactory `接口，它能管理`Spring`中所有的`Bean`，当然也包含`Spring`容器中的那些单例对象。\n\n`DefaultListableBeanFactory`还继承了`DefaultSingletonBeanRegistry`类，这个类就是用来管理`Spring `容器中的单例对象。\n\n在IDEA提供的类图中选中 `DefaultSingletonBeanRegistry`，然后按下F4进入这个类。它有一个`Map`类型的成员变量`singleton0bjects `:\n\n```Java\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap(256);\n```\n\n`Map`的`key`就是`Bean`的名字，而`value`是对应的`Bean`，即单例对象。\n\n现有如下两个`Bean`:\n\n```Java\n@Component\npublic class Component1 {\n}\n\n@Component\npublic class Component2 {\n}\n```\n\n查看`singletonObjects`中是否存在这两个Bean的信息:\n\n```Java\n// 通过反射获取字段\nField singletonObjects = DefaultSingletonBeanRegistry.class.getDeclaredField(\"singletonObjects\");\nsingletonObjects.setAccessible(true);\nConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\nMap<String, Object> map = (Map<String, Object>) singletonObjects.get(beanFactory);\nmap.entrySet().stream().filter(e -> e.getKey().startsWith(\"component\"))\n        .forEach(e -> {\n            System.out.println(e.getKey() + \"=\" + e.getValue());\n        });\n```\n\n运行main()方法后，控制台打印出:\n\n```Plain\ncomponent1=com.itheima.a01.Component1@59498d94\ncomponent2=com.itheima.a01.Component2@35bfa1bb\n```\n\n## ApplicationContext的扩展功能\n\n回顾`ConfigurableApplicationContext`类的类图:\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%91%EF%BC%9AIOC/4.png)\n\n`ApplicationContext`除了继承`BeanFactory`外，还继承了∶\n\n- `MessageSource`：使其具备处理国际化资源的能力\n- `ResourcePatternResolver`：使其具备使用通配符进行资源匹配的能力\n- `EnvironmentCapable`：使其具备读取`Spring`环境信息、配置文件信息的能力\n- `ApplicationEventPublisher`：使其具备发布事件的能力\n\n### MessageSource\n\n`MessageSource`具备处理国际化资源的能力。\n\n在`SpringBoot`项目的`resources`目录下创建`messages.properties`、`messages_en.properties`、\n\n`messages_ja.properties`、`messages_zh.properties`四个国际化文件，除`messages.properties`外，其余三个文件内容如下:\n\n```Properties\nhi=Hello\nhi=こんにちは\nhi=你好\n```\n\n测试`MessageSource`接口中`getMessage()`方法的使用:\n\n```Java\nSystem.out.println(context.getMessage(\"hi\", null, Locale.CHINA));\nSystem.out.println(context.getMessage(\"hi\", null, Locale.ENGLISH));\nSystem.out.println(context.getMessage(\"hi\", null, Locale.JAPANESE));\n```\n\n运行`main()`方法后，控制台打印出:\n\n```Plain\n你好\nHello\nこんにちは\n```\n\n国际化资源由 `ResourceBundleMessageSource` 进行处理，我们也可以使用\"干净\"的`Spring`容器`GenericApplicationcontext`，但需要手动注册`MessageSource`类型的`Bean`:\n\n```Java\npublic class TestMessageSource {\n    public static void main(String[] args) {\n        GenericApplicationContext context = new GenericApplicationContext();\n\n        context.registerBean(\"messageSource\", MessageSource.class, () -> {\n            ResourceBundleMessageSource ms = new ResourceBundleMessageSource();\n            ms.setDefaultEncoding(\"utf-8\");\n            ms.setBasename(\"messages\");\n            return ms;\n        });\n\n        context.refresh();\n\n        System.out.println(context.getMessage(\"hi\", null, Locale.ENGLISH));\n        System.out.println(context.getMessage(\"hi\", null, Locale.CHINESE));\n        System.out.println(context.getMessage(\"hi\", null, Locale.JAPANESE));\n    }\n}\n```\n\n运行`main()`方法后，控制台打印出:\n\n```Plain\n你好\nHello\nこんにちは\n```\n\n### ResourcePatternResolver\n\n`ResourcePatternResolver`具备使用通配符进行资源匹配的能力。\n\n```Java\n// 加载类路径下的 resource\nResource[] resourceList = context.getResources(\"classpath:application.properties\");\n\nfor (Resource resource : resourceList) {\n    System.out.println(resource);\n}\n\n// 使用classpath*可以加载jar里类路径下的 resource\nResource[] resources = context.getResources(\"classpath*:META-INF/spring.factories\");\nfor (Resource resource : resources) {\n    System.out.println(resource);\n}\n```\n\n控制台输出：\n\n```Plain\nclass path resource [application.properties]\nURL [file:/F:/Java/%e9%bb%91%e9%a9%ac%e5%85%a8%e5%a5%97java%e6%95%99%e7%a8%8b/%e7%ac%ac2%e9%98%b6%e6%ae%b5%e4%bc%81%e4%b8%9a%e7%ba%a7%e5%bc%80%e5%8f%91%e2%80%94%e5%9f%ba%e7%a1%80%e6%a1%86%e6%9e%b6/7%e3%80%81spring%e9%ab%98%e7%ba%a745%e8%ae%b2/%e4%bb%a3%e7%a0%81/%e4%bb%a3%e7%a0%81/show/target/classes/META-INF/spring.factories]\nURL [jar:file:/C:/Users/WolfMan/.m2/repository/com/alibaba/druid-spring-boot-starter/1.2.8/druid-spring-boot-starter-1.2.8.jar!/META-INF/spring.factories]\nURL [jar:file:/C:/Users/WolfMan/.m2/repository/org/springframework/spring-test/5.3.10/spring-test-5.3.10.jar!/META-INF/spring.factories]\nURL [jar:file:/C:/Users/WolfMan/.m2/repository/org/springframework/boot/spring-boot/2.5.5/spring-boot-2.5.5.jar!/META-INF/spring.factories]\nURL [jar:file:/C:/Users/WolfMan/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/2.5.5/spring-boot-autoconfigure-2.5.5.jar!/META-INF/spring.factories]\nURL [jar:file:/C:/Users/WolfMan/.m2/repository/org/mybatis/spring/boot/mybatis-spring-boot-autoconfigure/2.2.0/mybatis-spring-boot-autoconfigure-2.2.0.jar!/META-INF/spring.factories]\nURL [jar:file:/C:/Users/WolfMan/.m2/repository/org/springframework/spring-beans/5.3.10/spring-beans-5.3.10.jar!/META-INF/spring.factories]\n```\n\n### EnvironmentCapable\n\n`EnvironmentCapable`其具备读取`Spring`环境信息、配置文件信息的能力 。\n\n`java_home`是从环境变量中读取, `properties.name`则是从`application.yml`配置文件中读取。\n\n```Java\nSystem.out.println(context.getEnvironment().getProperty(\"java_home\"));\nSystem.out.println(context.getEnvironment().getProperty(\"server.port\"));\n```\n\n控制台输出：\n\n```Plain\nC:\\Path\\jdk-14.0.1\n8080\n```\n\n### ApplicationEventPublisher\n\n`ApplicationEventPublisher`具备发布事件的能力。\n\n注册事件，需要继承`ApplicationEvent `，`source`为事件源(谁发的事件)：\n\n```Java\npublic class UserRegisteredEvent extends ApplicationEvent {\n    public UserRegisteredEvent(Object source) {\n        super(source);\n    }\n}\n```\n\n使用`context`发送事件：\n\n```Java\ncontext.publishEvent(new UserRegisteredEvent(context));\n```\n\n再Component中接收事件：\n\n```Java\n@Component\npublic class Component2 {\n\n    private static final Logger log = LoggerFactory.getLogger(Component2.class);\n\n    /**\n    * @EventListener表示事件监听的方法\n    */\n    @EventListener\n    public void aaa(UserRegisteredEvent event) {\n        log.debug(\"{}\", event);\n        log.debug(\"发送短信\");\n    }\n    \n}\n```\n\n控制台输出：\n\n```Plain\n[DEBUG] 15:43:30.940 [main] com.itheima.a01.Component2          - com.itheima.a01.UserRegisteredEvent[source=com.itheima.a01.Component1@26e8ff8c]\n```\n\n可以看到`component2`监听到了事件\n\n事件的发布与监听主要用于解耦，比如用户注册和发送短信。例如component1发送用户注册事件，component2监听事件并发送短信：\n\n```Java\n@Component\npublic class Component1 {\n\n    private static final Logger log = LoggerFactory.getLogger(Component1.class);\n\n    @Autowired\n    private ApplicationEventPublisher context;\n\n    public void register() {\n        log.debug(\"用户注册\");\n        context.publishEvent(new UserRegisteredEvent(this));\n    }\n\n}\n\n@Component\npublic class Component2 {\n\n    private static final Logger log = LoggerFactory.getLogger(Component2.class);\n\n    @EventListener\n    public void aaa(UserRegisteredEvent event) {\n        log.debug(\"{}\", event);\n        log.debug(\"发送短信\");\n    }\n}\n```\n\n控制台打印：\n\n```Plain\n[DEBUG] 15:43:30.939 [main] com.itheima.a01.Component1          - 用户注册 \n[DEBUG] 15:43:30.940 [main] com.itheima.a01.Component2          - com.itheima.a01.UserRegisteredEvent[source=com.itheima.a01.Component1@26e8ff8c] \n[DEBUG] 15:43:30.943 [main] com.itheima.a01.Component2          - 发送短信 \n```\n\n## **容器接口总结**\n\n- `BeanFactory`与`ApplicationContext` 并不仅仅是简单接口继承的关系, `ApplicationContext` 组合并扩展了`BeanFactory`的功能\n- 又新学一种代码之间解耦途径，即通过事件发布与监听\n\n# 容器实现\n\n## BeanFactory的实现\n\n首先了解`BeanFactory`最重要的实现`DefaultListableBeanFactory`，使用`DefaultListableBeanFactory`创建对象，我们需要告诉它`Bean`的信息，例如`Bean`的`class`、`scope`、初始化、销毁等...\n\n```Java\npublic class TestBeanFactory {\n\n    public static void main(String[] args) {\n        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n        // bean 的定义（class, scope, 初始化, 销毁）\n        AbstractBeanDefinition beanDefinition =\n                BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(\"singleton\").getBeanDefinition();\n        beanFactory.registerBeanDefinition(\"config\", beanDefinition);\n\n        for (String name : beanFactory.getBeanDefinitionNames()) {\n            System.out.println(name);\n        }\n    }\n\n    @Configuration\n    static class Config {\n        @Bean\n        public Bean1 bean1() {\n            return new Bean1();\n        }\n    \n        @Bean\n        public Bean2 bean2() {\n            return new Bean2();\n        }\n    \n    }\n    \n    static class Bean1 {\n        private static final Logger log = LoggerFactory.getLogger(Bean1.class);\n        @Autowired\n        private Bean2 bean2;\n    \n        public Bean1() {\n            log.debug(\"构造 Bean1()\");\n        }\n    \n        public Bean2 getBean2() {\n            return bean2;\n        }\n    \n    }\n    \n    static class Bean2 {\n        private static final Logger log = LoggerFactory.getLogger(Bean2.class);\n    \n        public Bean2() {\n            log.debug(\"构造 Bean2()\");\n        }\n    }\n}\n```\n\n控制台输出：\n\n```Plain\nconfig\n```\n\n通过上面的运行示例我们发现，即使`Config`类上添加了`@Configuration`注解，其内部也有两个添加了`@Bean`注解的方法，`beanFactory`中也只有一个`Bean`实例。说明`DefaultListableBeanFactory`本身不具有解析注解的能力。\n\n我们可以通过`AnnotationConfigUtils`工具类给`DefaultListableBeanFactory`添加后处理器，以扩展`DefaultListableBeanFactory`的功能。\n\n我们给`DefaultListableBeanFactory`添加后处理器：\n\n```Java\n// 给 BeanFactory 添加一些常用的后处理器\nAnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);\n```\n\n再次查看控制台：\n\n```Plain\nconfig\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\norg.springframework.context.event.internalEventListenerProcessor\norg.springframework.context.event.internalEventListenerFactory\n```\n\n我们发现多了很多的`Bean`，其中`org.springframework.context.annotation.internalConfigurationAnnotationProcessor`就是用来处理`@Configuration`、`@Bean`等注解的类。\n\n`AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory)`只是给`beanFactory`添加了后处理器，但是没有使用这些处理器的功能，下面我们获取这些处理器，并且使用它们：\n\n```Java\n// BeanFactory 后处理器主要功能，补充了一些 bean 定义\nbeanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values().forEach(beanFactoryPostProcessor -> {\n    beanFactoryPostProcessor.postProcessBeanFactory(beanFactory);\n});\n```\n\n再次查看控制台：\n\n```Plain\nconfig\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\norg.springframework.context.event.internalEventListenerProcessor\norg.springframework.context.event.internalEventListenerFactory\nbean1\nbean2\n```\n\n我们打印了`bean1`和`bean2`，说明注解已经被解析并且生效。\n\n我们执行以下代码：\n\n```Java\nSystem.out.println(beanFactory.getBean(Bean1.class).getBean2());\n```\n\n查看控制台打印：\n\n```Plain\nconfig\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\norg.springframework.context.event.internalEventListenerProcessor\norg.springframework.context.event.internalEventListenerFactory\nbean1\nbean2\n[DEBUG] 22:14:07.212 [main] c.itheima.a02.TestBeanFactory$Bean1 - 构造 Bean1() \nnull\n```\n\n发现虽然调用了`Bean1`的构造方法，但是`Bean2`却没有被注入，说明此时的`@Autowired`并没有生效。其实依赖注入的功能是由`Bean`的后处理器(注意与`BeanFactory`的后处理器区分)来处理的。例如：\n\n- `internalAutowiredAnnotationProcessor`：解析`@Autowired`注解。\n- `internalCommonAnnotationProcessor`：解析`@Resource`注解\n\n我们使用`Bean`的后处理器：\n\n```Java\n// Bean 后处理器, 针对 bean 的生命周期的各个阶段提供扩展, 例如 @Autowired @Resource ...\nbeanFactory.getBeansOfType(BeanPostProcessor.class).values().forEach(beanFactory::addBeanPostProcessor);\n```\n\n控制台输出：\n\n```Plain\nconfig\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\norg.springframework.context.event.internalEventListenerProcessor\norg.springframework.context.event.internalEventListenerFactory\nbean1\nbean2\n[DEBUG] 22:26:30.567 [main] c.itheima.a02.TestBeanFactory$Bean1 - 构造 Bean1() \n[DEBUG] 22:26:30.591 [main] c.itheima.a02.TestBeanFactory$Bean2 - 构造 Bean2() \ncom.itheima.a02.TestBeanFactory$Bean2@795509d9\n```\n\n我们发现`Bean2`成功被注入到了`Bean1`中。\n\n通过以上示例我们发现，只有`getBean()`并使用`Bean`的时候`spring`才会去初始化真正的实例。\n\n说明只有在我们用到实例对象的时候，`spring`才会去实例化这些对象，有延迟加载的效果。对于单例对象，我们一般更希望，`spring`在初始化时就给我们创建这些对象，可以使用`preInstantiateSingletons()`方法：\n\n```Java\nbeanFactory.preInstantiateSingletons(); // 准备好所有单例\nSystem.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> \");\nSystem.out.println(beanFactory.getBean(Bean1.class).getBean2());\n```\n\n观察控制台：\n\n```Plain\n...\n[DEBUG] 22:36:13.682 [main] c.itheima.a02.TestBeanFactory$Bean1 - 构造 Bean1() \n[DEBUG] 22:36:13.702 [main] c.itheima.a02.TestBeanFactory$Bean2 - 构造 Bean2() \n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> \ncom.itheima.a02.TestBeanFactory$Bean2@196a42c3\n```\n\n我们发现在调用`beanFactory.preInstantiateSingletons()`之后就已经调用了`Bean1`和`Bean2`的构造方法，实现了预先加载的功能。\n\n我们进入`AnnotationConfigUtils.registerAnnotationConfigProcessors()`方法中，\n\n```Java\npublic static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {\n    registerAnnotationConfigProcessors(registry, (Object)null);\n}\n```\n\n再进入`registerAnnotationConfigProcessors(registry, (Object)null)`方法：\n\n```Java\npublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, @Nullable Object source) {\n    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\n    if (beanFactory != null) {\n        if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n        }\n\n        if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {\n            beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n        }\n    }\n\n    Set<BeanDefinitionHolder> beanDefs = new LinkedHashSet(8);\n    RootBeanDefinition def;\n    if (!registry.containsBeanDefinition(\"org.springframework.context.annotation.internalConfigurationAnnotationProcessor\")) {\n        def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalConfigurationAnnotationProcessor\"));\n    }\n\n    if (!registry.containsBeanDefinition(\"org.springframework.context.annotation.internalAutowiredAnnotationProcessor\")) {\n        def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalAutowiredAnnotationProcessor\"));\n    }\n\n    if (jsr250Present && !registry.containsBeanDefinition(\"org.springframework.context.annotation.internalCommonAnnotationProcessor\")) {\n        def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalCommonAnnotationProcessor\"));\n    }\n\n    if (jpaPresent && !registry.containsBeanDefinition(\"org.springframework.context.annotation.internalPersistenceAnnotationProcessor\")) {\n        def = new RootBeanDefinition();\n\n        try {\n            def.setBeanClass(ClassUtils.forName(\"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\", AnnotationConfigUtils.class.getClassLoader()));\n        } catch (ClassNotFoundException var6) {\n            throw new IllegalStateException(\"Cannot load optional framework class: org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\", var6);\n        }\n\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalPersistenceAnnotationProcessor\"));\n    }\n\n    if (!registry.containsBeanDefinition(\"org.springframework.context.event.internalEventListenerProcessor\")) {\n        def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.event.internalEventListenerProcessor\"));\n    }\n\n    if (!registry.containsBeanDefinition(\"org.springframework.context.event.internalEventListenerFactory\")) {\n        def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.event.internalEventListenerFactory\"));\n    }\n\n    return beanDefs;\n}\n```\n\n这里注册了很多后处理器，其中包括解析`@Autowired`注解的`AutowiredAnnotationBeanPostProcessor`以及解析`@Resource`注解的`CommonAnnotationBeanPostProcessor`。\n\n那么在依赖注入的时候既加了`@Autowired`又加了`@Resource`，谁会优先生效呢？准备以下代码：\n\n```Java\ninterface Inter {\n\n}\n\nstatic class Bean3 implements Inter {\n\n}\n\nstatic class Bean4 implements Inter {\n\n}\n\nstatic class Bean1 {\n    private static final Logger log = LoggerFactory.getLogger(Bean1.class);\n\n    public Bean1() {\n        log.debug(\"构造 Bean1()\");\n    }\n\n    @Autowired\n    private Bean2 bean2;\n\n    public Bean2 getBean2() {\n        return bean2;\n    }\n\n    @Autowired\n    @Resource(name = \"bean4\")\n    private Inter bean3;\n\n    public Inter getInter() {\n        return bean3;\n    }\n}\n\nstatic class Bean2 {\n    private static final Logger log = LoggerFactory.getLogger(Bean2.class);\n\n    public Bean2() {\n        log.debug(\"构造 Bean2()\");\n    }\n}\n```\n\n`@Autowired`首先判断依赖注入的类型，如果有同类型的`Bean`，那么再判断属性的名称，例如：\n\n```Java\n@Autowired\nprivate Inter bean3;\n```\n\n将会注入Bean3：\n\n```Plain\ncom.itheima.a02.TestBeanFactory$Bean3@2af004b\n```\n\n`@Resource`首先判断名称，如果没有给`name`属性的话在判断类型，如果有多个类型再判断属性的名称，例如：\n\n```Java\n@Resource(name = \"bean4\")\nprivate Inter bean3;\n```\n\n将会注入Bean4：\n\n```Plain\ncom.itheima.a02.TestBeanFactory$Bean4@663c9e7a\n```\n\n当同时加`@Autowired`与`@Resource(name = \"bean4\")`：\n\n```Java\n    @Autowired\n    @Resource(name = \"bean4\")\n    private Inter bean3;\n```\n\n我们发现注入的是Bean3：\n\n```Plain\ncom.itheima.a02.TestBeanFactory$Bean3@2af004b\n```\n\n为什么呢？\n\n由于`Bean`处理器与其注册的顺序有关，`AutowiredAnnotationBeanPostProcessor`比`CommonAnnotationBeanPostProcessor`优先注册，因此优先级更高。\n\n我们可以编码查看：\n\n```Java\nbeanFactory.getBeansOfType(BeanPostProcessor.class).values().forEach(beanPostProcessor -> {\n            System.out.println(\">>>>\" + beanPostProcessor);\n            beanFactory.addBeanPostProcessor(beanPostProcessor);\n        });\n```\n\n控制台输出：\n\n```Plain\n>>>>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@1e1a0406\n>>>>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@3cebbb30\n```\n\n我们可以通过添加比较器的方式手动调整Bean的顺序：\n\n```Plain\nbeanFactory.getBeansOfType(BeanPostProcessor.class).values().stream()\n        .sorted(beanFactory.getDependencyComparator())\n        .forEach(beanPostProcessor -> {\n            System.out.println(\">>>>\" + beanPostProcessor);\n            beanFactory.addBeanPostProcessor(beanPostProcessor);\n        });\n```\n\n重新运行代码，查看控制台：\n\n```Plain\n>>>>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@6253c26\n>>>>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@49049a04\n...\ncom.itheima.a02.TestBeanFactory$Bean4@548d708a\n```\n\n我们发现处理器的顺序发生了改变，同时注入的`Bean`对象也改变了。\n\n我们通过`beanFactory.getDependencyComparator()`获取了一个比较器，说明在`beanFactory`初始化的时候设置了比较器。其实比较器是通过`AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory)`设置的，进入方法：\n\n```Java\npublic static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {\n    registerAnnotationConfigProcessors(registry, (Object)null);\n}\n```\n\n再次进入`registerAnnotationConfigProcessors(registry, (Object)null)`方法：\n\n```Java\nDefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\nif (beanFactory != null) {\n    if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n        beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n    }\n\n    if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {\n        beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n    }\n}\n//....\n```\n\n加粗部分就是在设置比较器，我们进入`AnnotationAwareOrderComparator.INSTANCE`：\n\n```Java\npublic static final AnnotationAwareOrderComparator INSTANCE = new AnnotationAwareOrderComparator();\n```\n\n发现是一个通过\"饿汉式\"初始化的比较器。\n\n我们发现`AnnotationAwareOrderComparator `继承了`OrderComparator`：\n\n```Java\npublic class AnnotationAwareOrderComparator extends OrderComparator\n```\n\n进入`OrderComparator`类：\n\n```Java\npublic class OrderComparator implements Comparator<Object>\n```\n\n发现`OrderComparator`实现了`Comparator<Object>`接口，查看`compare()`方法：\n\n```Java\npublic int compare(@Nullable Object o1, @Nullable Object o2) {\n    return this.doCompare(o1, o2, (OrderSourceProvider)null);\n}\n```\n\n进入`this.doCompare(o1, o2, (OrderSourceProvider)null)`方法中：\n\n```Java\nprivate int doCompare(@Nullable Object o1, @Nullable Object o2, @Nullable OrderSourceProvider sourceProvider) {\n    boolean p1 = o1 instanceof PriorityOrdered;\n    boolean p2 = o2 instanceof PriorityOrdered;\n    if (p1 && !p2) {\n        return -1;\n    } else if (p2 && !p1) {\n        return 1;\n    } else {\n        int i1 = this.getOrder(o1, sourceProvider);\n        int i2 = this.getOrder(o2, sourceProvider);\n        return Integer.compare(i1, i2);\n    }\n}\n```\n\n查看`AutowiredAnnotationBeanPostProcessor `类图：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%91%EF%BC%9AIOC/5.png)\n\n查看`CommonAnnotationBeanPostProcessor `类图：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%91%EF%BC%9AIOC/6.png)\n\n因为`AutowiredAnnotationBeanPostProcessor `和`CommonAnnotationBeanPostProcessor `都直接或间接地实现了`PriorityOrdered`接口，因此p1和p2都为true。\n\n接下来进入`this.getOrder()`方法：\n\n```Java\nprivate int getOrder(@Nullable Object obj, @Nullable OrderSourceProvider sourceProvider) {\n    Integer order = null;\n    if (obj != null && sourceProvider != null) {\n        Object orderSource = sourceProvider.getOrderSource(obj);\n        if (orderSource != null) {\n            if (orderSource.getClass().isArray()) {\n                Object[] var5 = ObjectUtils.toObjectArray(orderSource);\n                int var6 = var5.length;\n\n                for(int var7 = 0; var7 < var6; ++var7) {\n                    Object source = var5[var7];\n                    order = this.findOrder(source);\n                    if (order != null) {\n                        break;\n                    }\n                }\n            } else {\n                order = this.findOrder(orderSource);\n            }\n        }\n    }\n\n    return order != null ? order : this.getOrder(obj);\n}\n```\n\n由于`sourceProvider==null`，因此进入`this.getOrder()`方法：\n\n```Java\nprotected int getOrder(@Nullable Object obj) {\n    if (obj != null) {\n        Integer order = this.findOrder(obj);\n        if (order != null) {\n            return order;\n        }\n    }\n\n    return Integer.MAX_VALUE;\n}\n```\n\n进入`this.findOrder(obj)`方法，实际上是进入`AnnotationAwareOrderComparator`的`findOrder(obj)`方法：\n\n```Java\n@Nullable\nprotected Integer findOrder(Object obj) {\n    Integer order = super.findOrder(obj);\n    return order != null ? order : this.findOrderFromAnnotation(obj);\n}\n```\n\n首先调用父类`OrderComparator`的`findOrder(obj)`方法：\n\n```Java\n@Nullable\nprotected Integer findOrder(Object obj) {\n    return obj instanceof Ordered ? ((Ordered)obj).getOrder() : null;\n}\n```\n\n`AutowiredAnnotationBeanPostProcessor `和`CommonAnnotationBeanPostProcessor `都直接或间接地实现了`PriorityOrdered`接口，而`PriorityOrdered`继承了`Ordered `接口，因此调用实现类的`getOrder()`方法。\n\n查看`AutowiredAnnotationBeanPostProcessor `的`getOrder()`方法：\n\n```Java\nprivate int order = 2147483645;\npublic int getOrder() {\n    return this.order;\n}\n```\n\n查看`CommonAnnotationBeanPostProcessor`的`setOrder()`方法：\n\n```Java\nthis.setOrder(2147483644);\npublic void setOrder(int order) {\n    this.order = order;\n}\n```\n\n因此根据`AnnotationAwareOrderComparator`排序`CommonAnnotationBeanPostProcessor`要小于`AutowiredAnnotationBeanPostProcessor`。\n\n`BeanFactory`和`SpringApplicationContext`的区别？\n\n1. 不会主动调用`BeanFactory`后处理器\n2. 不会主动添加`Bean`后处理器\n3. 不会主动初始化单例\n4.  不会解析`beanFactory`\n5. 不会解析`${}`与`#{}`等表达式\n6. `bean`后处理器会有排序的逻辑\n\n## ApplicationContext的实现\n\n接下来介绍`ApplicationContext`四个比较典型的实现类：\n\n- `ClassPathXmlApplicationContext`：️较为经典的容器, 基于`classpath`下`xml`格式的配置文件来创建。\n- `FileSystemXmlApplicationContext`：基于磁盘路径下`xml`格式的配置文件来创建。\n- `AnnotationConfigApplicationContext`：较为经典的容器, 基于`java`配置类来创建。\n- `AnnotationConfigServletWebServerApplicationContext`：较为经典的容器, 基于`java`配置类来创建, 用于`web`环境。\n\n1. ClassPathXmlApplicationContext\n\n**使用演示**\n\n准备两个类：\n\n```Java\nstatic class Bean1 {\n}\n\nstatic class Bean2 {\n\n    private Bean1 bean1;\n\n    public void setBean1(Bean1 bean1) {\n        this.bean1 = bean1;\n    }\n\n    public Bean1 getBean1() {\n        return bean1;\n    }\n}\n```\n\n编写`a02.xml`配置文件：\n\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 控制反转, 让 bean1 被 Spring 容器管理 -->\n    <bean id=\"bean1\" class=\"com.itheima.a02.A02.Bean1\"/>\n\n    <!-- 控制反转, 让 bean2 被 Spring 容器管理 -->\n    <bean id=\"bean2\" class=\"com.itheima.a02.A02.Bean2\">\n        <!-- 依赖注入, 建立与 bean1 的依赖关系 -->\n        <property name=\"bean1\" ref=\"bean1\"/>\n    </bean>\n</beans>\n```\n\n读取`classpath`下`xml`格式的配置文件，获取`Bean`：\n\n```Java\n// ⬇️较为经典的容器, 基于 classpath 下 xml 格式的配置文件来创建\nprivate static void testClassPathXmlApplicationContext() {\n    ClassPathXmlApplicationContext context =\n            new ClassPathXmlApplicationContext(\"a02.xml\");\n\n    for (String name : context.getBeanDefinitionNames()) {\n        System.out.println(name);\n    }\n\n    System.out.println(context.getBean(Bean2.class).getBean1());\n}\n```\n\n控制台输出：\n\n```Plain\nbean1\nbean2\ncom.itheima.a02.A02$Bean1@1de5f259\n```\n\n我们发现Bean已经成功地被注入。\n\n**源码剖析**\n\n首先进入`ClassPathXmlApplicationContext`的构造方法：\n\n```Java\npublic ClassPathXmlApplicationContext(String configLocation) throws BeansException {\n    this(new String[]{configLocation}, true, (ApplicationContext)null);\n}\n```\n\n进入重载的构造方法：\n\n```Java\npublic ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException {\n    super(parent);\n    // 设置xml文件路径\n    this.setConfigLocations(configLocations);\n    if (refresh) {\n        this.refresh();\n    }\n}\n```\n\n进入`refresh()`方法：\n\n```Java\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized(this.startupShutdownMonitor) {\n        StartupStep contextRefresh = this.applicationStartup.start(\"spring.context.refresh\");\n        this.prepareRefresh();\n        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();\n        this.prepareBeanFactory(beanFactory);\n\n        //...\n       \n    }\n}\n```\n\n我们主要关注`beanFactory`的构造，进入`this.obtainFreshBeanFactory()`方法：\n\n```Java\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n    this.refreshBeanFactory();\n    return this.getBeanFactory();\n}\n```\n\n进入`this.refreshBeanFactory()`方法，其实进入的是`AbstractRefreshableApplicationContext`类的`refreshBeanFactory()`方法：\n\n```Java\nprotected final void refreshBeanFactory() throws BeansException {\n    if (this.hasBeanFactory()) {\n        this.destroyBeans();\n        this.closeBeanFactory();\n    }\n\n    try {\n        // 创建BeanFactory的重要实现类DefaultListableBeanFactory \n        DefaultListableBeanFactory beanFactory = this.createBeanFactory();\n        beanFactory.setSerializationId(this.getId());\n        this.customizeBeanFactory(beanFactory);\n        // 加载BeanDefinitions，会解析spring配置文件(a01.xml)\n        this.loadBeanDefinitions(beanFactory);\n        this.beanFactory = beanFactory;\n    } catch (IOException var2) {\n        throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + this.getDisplayName(), var2);\n    }\n}\n```\n\n进入`this.loadBeanDefinitions(beanFactory)`，实际上是进入`AbstractXmlApplicationContext`的`loadBeanDefinitions(DefaultListableBeanFactory beanFactory)`方法，我们看看spring如何解析配置文件：\n\n```Java\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n    // 创建XmlBeanDefinitionReader\n    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n    beanDefinitionReader.setEnvironment(this.getEnvironment());\n    beanDefinitionReader.setResourceLoader(this);\n    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n    this.initBeanDefinitionReader(beanDefinitionReader);\n    // 真正加载BeanDefinition的方法\n    this.loadBeanDefinitions(beanDefinitionReader);\n}\n```\n\n进入`this.loadBeanDefinitions(beanDefinitionReader)`方法：\n\n```Java\nprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {\n    Resource[] configResources = this.getConfigResources();\n    if (configResources != null) {\n        reader.loadBeanDefinitions(configResources);\n    }\n\n    String[] configLocations = this.getConfigLocations();\n    if (configLocations != null) {\n        reader.loadBeanDefinitions(configLocations);\n    }\n\n}\n```\n\n进入`reader.loadBeanDefinitions(configLocations)`方法：\n\n```Java\npublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {\n    Assert.notNull(locations, \"Location array must not be null\");\n    int count = 0;\n    String[] var3 = locations;\n    int var4 = locations.length;\n\n    for(int var5 = 0; var5 < var4; ++var5) {\n        String location = var3[var5];\n        count += this.loadBeanDefinitions(location);\n    }\n\n    return count;\n}\n```\n\n进入`this.loadBeanDefinitions(location)`方法：\n\n```Java\npublic int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {\n    return this.loadBeanDefinitions(location, (Set)null);\n}\n```\n\n进入重载的`this.loadBeanDefinitions(location, (Set)null)`方法：\n\n```Java\npublic int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {\n    ResourceLoader resourceLoader = this.getResourceLoader();\n    if (resourceLoader == null) {\n        throw new BeanDefinitionStoreException(\"Cannot load bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n    } else {\n        int count;\n        if (resourceLoader instanceof ResourcePatternResolver) {\n            try {\n                Resource[] resources = ((ResourcePatternResolver)resourceLoader).getResources(location);\n                count = this.loadBeanDefinitions(resources);\n                if (actualResources != null) {\n                    Collections.addAll(actualResources, resources);\n                }\n\n                if (this.logger.isTraceEnabled()) {\n                    this.logger.trace(\"Loaded \" + count + \" bean definitions from location pattern [\" + location + \"]\");\n                }\n\n                return count;\n            } catch (IOException var6) {\n                throw new BeanDefinitionStoreException(\"Could not resolve bean definition resource pattern [\" + location + \"]\", var6);\n            }\n        } else {\n            //...\n        }\n    }\n}\n```\n\n进入`this.loadBeanDefinitions(resources)`方法：\n\n```Java\npublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {\n    Assert.notNull(resources, \"Resource array must not be null\");\n    int count = 0;\n    Resource[] var3 = resources;\n    int var4 = resources.length;\n\n    for(int var5 = 0; var5 < var4; ++var5) {\n        Resource resource = var3[var5];\n        count += this.loadBeanDefinitions((Resource)resource);\n    }\n\n    return count;\n}\n```\n\n进入`this.loadBeanDefinitions((Resource)resource)`方法，实际上进入的是`XmlBeanDefinitionReader`的`loadBeanDefinitions(Resource resource)`方法：\n\n```Java\npublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {\n    return this.loadBeanDefinitions(new EncodedResource(resource));\n}\n```\n\n进入重载的`this.loadBeanDefinitions(new EncodedResource(resource))`方法：\n\n```Java\npublic int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n    Assert.notNull(encodedResource, \"EncodedResource must not be null\");\n    if (this.logger.isTraceEnabled()) {\n        this.logger.trace(\"Loading XML bean definitions from \" + encodedResource);\n    }\n\n    Set<EncodedResource> currentResources = (Set)this.resourcesCurrentlyBeingLoaded.get();\n    if (!currentResources.add(encodedResource)) {\n        throw new BeanDefinitionStoreException(\"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\");\n    } else {\n        int var6;\n        try {\n            InputStream inputStream = encodedResource.getResource().getInputStream();\n            Throwable var4 = null;\n\n            try {\n                InputSource inputSource = new InputSource(inputStream);\n                if (encodedResource.getEncoding() != null) {\n                    inputSource.setEncoding(encodedResource.getEncoding());\n                }\n\n                var6 = this.doLoadBeanDefinitions(inputSource, encodedResource.getResource());\n            } catch (Throwable var24) {\n                var4 = var24;\n                throw var24;\n            } finally {\n                //...\n            }\n        } catch (IOException var26) {\n            throw new BeanDefinitionStoreException(\"IOException parsing XML document from \" + encodedResource.getResource(), var26);\n        } finally {\n            //...\n        }\n\n        return var6;\n    }\n}\n```\n\n进入`this.doLoadBeanDefinitions(inputSource, encodedResource.getResource())`方法：\n\n```Java\nprotected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException {\n    try {\n        Document doc = this.doLoadDocument(inputSource, resource);\n        int count = this.registerBeanDefinitions(doc, resource);\n        if (this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Loaded \" + count + \" bean definitions from \" + resource);\n        }\n\n        return count;\n    } catch (BeanDefinitionStoreException var5) {\n        throw var5;\n    } catch (SAXParseException var6) {\n        throw new XmlBeanDefinitionStoreException(resource.getDescription(), \"Line \" + var6.getLineNumber() + \" in XML document from \" + resource + \" is invalid\", var6);\n    } catch (SAXException var7) {\n        throw new XmlBeanDefinitionStoreException(resource.getDescription(), \"XML document from \" + resource + \" is invalid\", var7);\n    } catch (ParserConfigurationException var8) {\n        throw new BeanDefinitionStoreException(resource.getDescription(), \"Parser configuration exception parsing XML from \" + resource, var8);\n    } catch (IOException var9) {\n        throw new BeanDefinitionStoreException(resource.getDescription(), \"IOException parsing XML document from \" + resource, var9);\n    } catch (Throwable var10) {\n        throw new BeanDefinitionStoreException(resource.getDescription(), \"Unexpected exception parsing XML document from \" + resource, var10);\n    }\n}\n```\n\n进入`this.registerBeanDefinitions(doc, resource)`方法：\n\n```Java\npublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {\n    BeanDefinitionDocumentReader documentReader = this.createBeanDefinitionDocumentReader();\n    int countBefore = this.getRegistry().getBeanDefinitionCount();\n    documentReader.registerBeanDefinitions(doc, this.createReaderContext(resource));\n    return this.getRegistry().getBeanDefinitionCount() - countBefore;\n}\n```\n\n进入`documentReader.registerBeanDefinitions(doc, this.createReaderContext(resource))`方法：\n\n```Java\npublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n    this.readerContext = readerContext;\n    this.doRegisterBeanDefinitions(doc.getDocumentElement());\n}\n```\n\n进入`this.doRegisterBeanDefinitions(doc.getDocumentElement())`方法：\n\n```Java\nprotected void doRegisterBeanDefinitions(Element root) {\n    BeanDefinitionParserDelegate parent = this.delegate;\n    this.delegate = this.createDelegate(this.getReaderContext(), root, parent);\n    if (this.delegate.isDefaultNamespace(root)) {\n        String profileSpec = root.getAttribute(\"profile\");\n        if (StringUtils.hasText(profileSpec)) {\n            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, \",; \");\n            if (!this.getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {\n                if (this.logger.isDebugEnabled()) {\n                    this.logger.debug(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec + \"] not matching: \" + this.getReaderContext().getResource());\n                }\n\n                return;\n            }\n        }\n    }\n\n    this.preProcessXml(root);\n    this.parseBeanDefinitions(root, this.delegate);\n    this.postProcessXml(root);\n    this.delegate = parent;\n}\n```\n\n进入`this.parseBeanDefinitions(root, this.delegate)`方法：\n\n```Java\nprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n    if (delegate.isDefaultNamespace(root)) {\n        NodeList nl = root.getChildNodes();\n\n        for(int i = 0; i < nl.getLength(); ++i) {\n            Node node = nl.item(i);\n            if (node instanceof Element) {\n                Element ele = (Element)node;\n                if (delegate.isDefaultNamespace(ele)) {\n                    this.parseDefaultElement(ele, delegate);\n                } else {\n                    delegate.parseCustomElement(ele);\n                }\n            }\n        }\n    } else {\n        delegate.parseCustomElement(root);\n    }\n\n}\n```\n\n进入`this.parseDefaultElement(ele, delegate)`方法：\n\n```Java\nprivate void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {\n    if (delegate.nodeNameEquals(ele, \"import\")) {\n        this.importBeanDefinitionResource(ele);\n    } else if (delegate.nodeNameEquals(ele, \"alias\")) {\n        this.processAliasRegistration(ele);\n    } else if (delegate.nodeNameEquals(ele, \"bean\")) {\n        this.processBeanDefinition(ele, delegate);\n    } else if (delegate.nodeNameEquals(ele, \"beans\")) {\n        this.doRegisterBeanDefinitions(ele);\n    }\n\n}\n```\n\n我们可以看到，这里开始解析各种标签，如import、alias、bean等...\n\n进入解析`Bean`标签的`this.processBeanDefinition(ele, delegate)`方法：\n\n```Java\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n    // 解析bean标签\n    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n    if (bdHolder != null) {\n        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n\n        try {\n            //注册BeanDefinition包括名称，类\n            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry());\n        } catch (BeanDefinitionStoreException var5) {\n            this.getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, var5);\n        }\n\n        this.getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n    }\n\n}\n```\n\n首先进入`delegate.parseBeanDefinitionElement(ele)`方法：\n\n```Java\n@Nullable\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {\n    return this.parseBeanDefinitionElement(ele, (BeanDefinition)null);\n}\n```\n\n再进入重载的`this.parseBeanDefinitionElement(ele, (BeanDefinition)null)`方法：\n\n```Java\n@Nullable\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {\n    // 获取id，我们这里的id为bean1\n    String id = ele.getAttribute(\"id\");\n    // 获取名称\n    String nameAttr = ele.getAttribute(\"name\");\n    List<String> aliases = new ArrayList();\n    if (StringUtils.hasLength(nameAttr)) {\n        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, \",; \");\n        aliases.addAll(Arrays.asList(nameArr));\n    }\n\n    String beanName = id;\n    if (!StringUtils.hasText(id) && !aliases.isEmpty()) {\n        beanName = (String)aliases.remove(0);\n        if (this.logger.isTraceEnabled()) {\n            this.logger.trace(\"No XML 'id' specified - using '\" + beanName + \"' as bean name and \" + aliases + \" as aliases\");\n        }\n    }\n\n    if (containingBean == null) {\n        this.checkNameUniqueness(beanName, aliases, ele);\n    }\n\n    AbstractBeanDefinition beanDefinition = this.parseBeanDefinitionElement(ele, beanName, containingBean);\n    if (beanDefinition != null) {\n        if (!StringUtils.hasText(beanName)) {\n            try {\n                if (containingBean != null) {\n                    beanName = BeanDefinitionReaderUtils.generateBeanName(beanDefinition, this.readerContext.getRegistry(), true);\n                } else {\n                    beanName = this.readerContext.generateBeanName(beanDefinition);\n                    String beanClassName = beanDefinition.getBeanClassName();\n                    if (beanClassName != null && beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() && !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {\n                        aliases.add(beanClassName);\n                    }\n                }\n\n                if (this.logger.isTraceEnabled()) {\n                    this.logger.trace(\"Neither XML 'id' nor 'name' specified - using generated bean name [\" + beanName + \"]\");\n                }\n            } catch (Exception var9) {\n                this.error(var9.getMessage(), ele);\n                return null;\n            }\n        }\n\n        String[] aliasesArray = StringUtils.toStringArray(aliases);\n        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n    } else {\n        return null;\n    }\n}\n```\n\n进入`this.parseBeanDefinitionElement(ele, beanName, containingBean)`方法：\n\n```Java\n@Nullable\npublic AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, @Nullable BeanDefinition containingBean) {\n    this.parseState.push(new BeanEntry(beanName));\n    String className = null;\n    //获取className，也就是类的全限定名，例如\"com.itheima.a02.A02.Bean1\"\n    if (ele.hasAttribute(\"class\")) {\n        className = ele.getAttribute(\"class\").trim();\n    }\n\n    String parent = null;\n    if (ele.hasAttribute(\"parent\")) {\n        parent = ele.getAttribute(\"parent\");\n    }\n\n    try {\n        AbstractBeanDefinition bd = this.createBeanDefinition(className, parent);\n        // 解析标签上的各种属性，如singleton、abstract、lazy-init等...\n        this.parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, \"description\"));\n        // 这里解析子元素，例如ConstructorArg、Property等...\n        this.parseMetaElements(ele, bd);\n        this.parseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n        this.parseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n        this.parseConstructorArgElements(ele, bd);\n        this.parsePropertyElements(ele, bd);\n        this.parseQualifierElements(ele, bd);\n        bd.setResource(this.readerContext.getResource());\n        bd.setSource(this.extractSource(ele));\n        AbstractBeanDefinition var7 = bd;\n        //最后返回AbstractBeanDefinition \n        return var7;\n    } catch (ClassNotFoundException var13) {\n        this.error(\"Bean class [\" + className + \"] not found\", ele, var13);\n    } catch (NoClassDefFoundError var14) {\n        this.error(\"Class that bean class [\" + className + \"] depends on not found\", ele, var14);\n    } catch (Throwable var15) {\n        this.error(\"Unexpected failure during bean definition parsing\", ele, var15);\n    } finally {\n        this.parseState.pop();\n    }\n\n    return null;\n}\n```\n\n这个方法解析了`bean`标签，包括标签上的属性，以及子标签，最后返回了一个`AbstractBeanDefinition`。\n\n回到`DefaultBeanDefinitionDocumentReader`类中的`processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)`方法：\n\n```Java\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n    if (bdHolder != null) {\n        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n\n        try {\n            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry());\n        } catch (BeanDefinitionStoreException var5) {\n            this.getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, var5);\n        }\n\n        this.getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n    }\n\n}\n```\n\n进入`BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry())`方法：\n\n```Java\npublic static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException {\n    String beanName = definitionHolder.getBeanName();\n    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n    String[] aliases = definitionHolder.getAliases();\n    if (aliases != null) {\n        String[] var4 = aliases;\n        int var5 = aliases.length;\n\n        for(int var6 = 0; var6 < var5; ++var6) {\n            String alias = var4[var6];\n            registry.registerAlias(beanName, alias);\n        }\n    }\n\n}\n```\n\n进入`registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())`方法：\n\n```Java\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException {\n    Assert.hasText(beanName, \"Bean name must not be empty\");\n    Assert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n    if (beanDefinition instanceof AbstractBeanDefinition) {\n        try {\n            ((AbstractBeanDefinition)beanDefinition).validate();\n        } catch (BeanDefinitionValidationException var8) {\n            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, \"Validation of bean definition failed\", var8);\n        }\n    }\n\n    BeanDefinition existingDefinition = (BeanDefinition)this.beanDefinitionMap.get(beanName);\n    if (existingDefinition != null) {\n        if (!this.isAllowBeanDefinitionOverriding()) {\n            throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);\n        }\n\n        if (existingDefinition.getRole() < beanDefinition.getRole()) {\n            if (this.logger.isInfoEnabled()) {\n                this.logger.info(\"Overriding user-defined bean definition for bean '\" + beanName + \"' with a framework-generated bean definition: replacing [\" + existingDefinition + \"] with [\" + beanDefinition + \"]\");\n            }\n        } else if (!beanDefinition.equals(existingDefinition)) {\n            if (this.logger.isDebugEnabled()) {\n                this.logger.debug(\"Overriding bean definition for bean '\" + beanName + \"' with a different definition: replacing [\" + existingDefinition + \"] with [\" + beanDefinition + \"]\");\n            }\n        } else if (this.logger.isTraceEnabled()) {\n            this.logger.trace(\"Overriding bean definition for bean '\" + beanName + \"' with an equivalent definition: replacing [\" + existingDefinition + \"] with [\" + beanDefinition + \"]\");\n        }\n\n        this.beanDefinitionMap.put(beanName, beanDefinition);\n    } else {\n        if (this.hasBeanCreationStarted()) {\n            synchronized(this.beanDefinitionMap) {\n                this.beanDefinitionMap.put(beanName, beanDefinition);\n                List<String> updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1);\n                updatedDefinitions.addAll(this.beanDefinitionNames);\n                updatedDefinitions.add(beanName);\n                this.beanDefinitionNames = updatedDefinitions;\n                this.removeManualSingletonName(beanName);\n            }\n        } else {\n            //将beanName与beanDefinition的映射放入beanDefinitionMap，beanDefinition中包含了类的全限定名称\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n            this.beanDefinitionNames.add(beanName);\n            this.removeManualSingletonName(beanName);\n        }\n\n        this.frozenBeanDefinitionNames = null;\n    }\n\n    if (existingDefinition == null && !this.containsSingleton(beanName)) {\n        if (this.isConfigurationFrozen()) {\n            this.clearByTypeCache();\n        }\n    } else {\n        this.resetBeanDefinition(beanName);\n    }\n\n}\n```\n\n注意这两行代码：\n\n```Java\nthis.beanDefinitionMap.put(beanName, beanDefinition);\nthis.beanDefinitionNames.add(beanName);\n```\n\n就是将`beanName`与`beanDefinition`的映射放入`beanDefinitionMap`中，`beanName`放入`beanDefinitionNames`中，我们可以在`DefaultListableBeanFactory`类中通过这两个容器拿到对应属性。\n\n2. FileSystemXmlApplicationContext\n\n**使用演示**\n\n```Java\n    // ⬇️基于磁盘路径下 xml 格式的配置文件来创建\n    private static void testFileSystemXmlApplicationContext() {\n        // 基于文件绝对路径\n//        FileSystemXmlApplicationContext context =\n//                new FileSystemXmlApplicationContext(\n//                        \"c:\\\\Users\\\\manyh\\\\Desktop\\\\demo\\\\show\\\\src\\\\main\\\\resources\\\\a02.xml\");\n        // 基于项目相对路径\n        FileSystemXmlApplicationContext context =\n                new FileSystemXmlApplicationContext(\n                        \"src\\\\main\\\\resources\\\\a02.xml\");\n        for (String name : context.getBeanDefinitionNames()) {\n            System.out.println(name);\n        }\n\n        System.out.println(context.getBean(Bean2.class).getBean1());\n    }\n```\n\n> 注意：使用相对路径时我们要指定工作目录为当前模块(默认为当前项目)：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%91%EF%BC%9AIOC/7.png)\n\n控制台输出：\n\n```Plain\nbean1\nbean2\ncom.itheima.a02.A02$Bean1@1de5f259\n```\n\n我们发现Bean已经成功地被注入。\n\n**源码剖析**\n\n大致步骤和`ClassPathXmlApplicationContext`加载配置文件过程类似，不同的是在`AbstractXmlApplicationContext`中的`loadBeanDefinitions(DefaultListableBeanFactory beanFactory)`方法：\n\n```Java\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n    beanDefinitionReader.setEnvironment(this.getEnvironment());\n    beanDefinitionReader.setResourceLoader(this);\n    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n    this.initBeanDefinitionReader(beanDefinitionReader);\n    this.loadBeanDefinitions(beanDefinitionReader);\n}\n```\n\n在`beanDefinitionReader.setResourceLoader(this)`时，使用`ClassPathXmlApplicationContext`则代表`ClassPathXmlApplicationContext`实例，使用`FileSystemXmlApplicationContext`时则代表`FileSystemXmlApplicationContext`实例。\n\n进入`this.loadBeanDefinitions(beanDefinitionReader)`方法：\n\n```Java\nprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {\n    Resource[] configResources = this.getConfigResources();\n    if (configResources != null) {\n        reader.loadBeanDefinitions(configResources);\n    }\n\n    String[] configLocations = this.getConfigLocations();\n    if (configLocations != null) {\n        reader.loadBeanDefinitions(configLocations);\n    }\n\n}\n```\n\n再进入`reader.loadBeanDefinitions(configLocations)`方法：\n\n```Java\npublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {\n    Assert.notNull(locations, \"Location array must not be null\");\n    int count = 0;\n    String[] var3 = locations;\n    int var4 = locations.length;\n\n    for(int var5 = 0; var5 < var4; ++var5) {\n        String location = var3[var5];\n        count += this.loadBeanDefinitions(location);\n    }\n\n    return count;\n}\n```\n\n再进入`this.loadBeanDefinitions(location)`方法：\n\n```Java\npublic int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {\n    return this.loadBeanDefinitions(location, (Set)null);\n}\n```\n\n再进入`this.loadBeanDefinitions(location, (Set)null)`方法\n\n```Java\npublic int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {\n    // 首先获取ResourceLoader\n    ResourceLoader resourceLoader = this.getResourceLoader();\n    if (resourceLoader == null) {\n        throw new BeanDefinitionStoreException(\"Cannot load bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n    } else {\n        int count;\n        // 判断是否实现了ResourcePatternResolver\n        if (resourceLoader instanceof ResourcePatternResolver) {\n            try {\n                // 根据ResourceLoader的getResources()方法获取resources\n                Resource[] resources = ((ResourcePatternResolver)resourceLoader).getResources(location);\n                count = this.loadBeanDefinitions(resources);\n                if (actualResources != null) {\n                    Collections.addAll(actualResources, resources);\n                }\n\n                if (this.logger.isTraceEnabled()) {\n                    this.logger.trace(\"Loaded \" + count + \" bean definitions from location pattern [\" + location + \"]\");\n                }\n\n                return count;\n            } catch (IOException var6) {\n                throw new BeanDefinitionStoreException(\"Could not resolve bean definition resource pattern [\" + location + \"]\", var6);\n            }\n        } else {\n           //...\n        }\n    }\n}\n```\n\n`ClassPathXmlApplicationContext`和`FileSystemXmlApplicationContext`既实现了`ResourceLoader`接口，又实现了`ResourcePatternResolver`接口\n\n`ClassPathXmlApplicationContext`的类结构图：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%91%EF%BC%9AIOC/8.png)\n\n`FileSystemXmlApplicationContext`的类结构图：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%91%EF%BC%9AIOC/9.png)\n\n`ClassPathXmlApplicationContext`和`FileSystemXmlApplicationContext`的间接父类`AbstractApplicationContext`实现了`getResources(location)`方法：\n\n```Java\npublic Resource[] getResources(String locationPattern) throws IOException {\n    return this.resourcePatternResolver.getResources(locationPattern);\n}\n```\n\n进入`this.resourcePatternResolver.getResources(locationPattern)`方法(实际上进入的时`PathMatchingResourcePatternResolver`方法\n\n```Java\npublic Resource[] getResources(String locationPattern) throws IOException {\n    Assert.notNull(locationPattern, \"Location pattern must not be null\");\n    if (locationPattern.startsWith(\"classpath*:\")) {\n        return this.getPathMatcher().isPattern(locationPattern.substring(\"classpath*:\".length())) ? this.findPathMatchingResources(locationPattern) : this.findAllClassPathResources(locationPattern.substring(\"classpath*:\".length()));\n    } else {\n        int prefixEnd = locationPattern.startsWith(\"war:\") ? locationPattern.indexOf(\"*/\") + 1 : locationPattern.indexOf(58) + 1;\n        return this.getPathMatcher().isPattern(locationPattern.substring(prefixEnd)) ? this.findPathMatchingResources(locationPattern) : new Resource[]{this.getResourceLoader().getResource(locationPattern)};\n    }\n}\n```\n\n注意`this.getResourceLoader().getResource(locationPattern)`，会调用`DefaultResourceLoader`类的`getResource(locationPattern)`方法：\n\n```Java\npublic Resource getResource(String location) {\n    Assert.notNull(location, \"Location must not be null\");\n    Iterator var2 = this.getProtocolResolvers().iterator();\n\n    Resource resource;\n    do {\n        if (!var2.hasNext()) {\n            if (location.startsWith(\"/\")) {\n                return this.getResourceByPath(location);\n            }\n\n            if (location.startsWith(\"classpath:\")) {\n                return new ClassPathResource(location.substring(\"classpath:\".length()), this.getClassLoader());\n            }\n\n            try {\n                URL url = new URL(location);\n                return (Resource)(ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));\n            } catch (MalformedURLException var5) {\n                return this.getResourceByPath(location);\n            }\n        }\n\n        ProtocolResolver protocolResolver = (ProtocolResolver)var2.next();\n        resource = protocolResolver.resolve(location, this);\n    } while(resource == null);\n\n    return resource;\n}\n```\n\n`ClassPathXmlApplicationContext`使用的是`DefaultResourceLoader`类的`getResourceByPath(location)`方法：\n\n```Java\nprotected Resource getResourceByPath(String path) {\n    return new ClassPathContextResource(path, this.getClassLoader());\n}\n\nprotected static class ClassPathContextResource extends ClassPathResource implements ContextResource {\n    // 调用此构造方法\n    public ClassPathContextResource(String path, @Nullable ClassLoader classLoader) {\n        super(path, classLoader);\n    }\n    // ...\n}\n\npublic class ClassPathResource extends AbstractFileResolvingResource {\n    // 调用此构造方法\n    public ClassPathResource(String path, @Nullable ClassLoader classLoader) {\n        Assert.notNull(path, \"Path must not be null\");\n        String pathToUse = StringUtils.cleanPath(path);\n        if (pathToUse.startsWith(\"/\")) {\n            pathToUse = pathToUse.substring(1);\n        }\n    \n        this.path = pathToUse;\n        this.classLoader = classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader();\n    }\n}\n```\n\n而`FileSystemXmlApplicationContext`重写了`getResourceByPath(location)`方法：\n\n```Java\nprotected Resource getResourceByPath(String path) {\n    if (path.startsWith(\"/\")) {\n        path = path.substring(1);\n    }\n\n    return new FileSystemResource(path);\n}\n\npublic class FileSystemResource extends AbstractResource implements WritableResource {\n    private final String path;\n    @Nullable\n    private final File file;\n    private final Path filePath;\n\n    // 调用此构造方法\n    public FileSystemResource(String path) {\n        Assert.notNull(path, \"Path must not be null\");\n        this.path = StringUtils.cleanPath(path);\n        this.file = new File(path);\n        this.filePath = this.file.toPath();\n    }\n    //...\n}\n```\n\n`ClassPathXmlApplicationContext`与`FileSystemXmlApplicationContext`返回的是不同的`Resource `。\n\n3. AnnotationConfigApplicationContext\n\n**使用演示**\n\n准备配置类，并加上注解：\n\n```Java\n@Configuration\nstatic class Config {\n    @Bean\n    public Bean1 bean1() {\n        return new Bean1();\n    }\n\n    @Bean\n    public Bean2 bean2(Bean1 bean1) {\n        Bean2 bean2 = new Bean2();\n        bean2.setBean1(bean1);\n        return bean2;\n    }\n}\n```\n\n测试：\n\n```Java\n// ⬇️较为经典的容器, 基于 java 配置类来创建\nprivate static void testAnnotationConfigApplicationContext() {\n    AnnotationConfigApplicationContext context =\n            new AnnotationConfigApplicationContext(Config.class);\n\n    for (String name : context.getBeanDefinitionNames()) {\n        System.out.println(name);\n    }\n\n    System.out.println(context.getBean(Bean2.class).getBean1());\n}\n```\n\n控制台输出：\n\n```Plain\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\norg.springframework.context.event.internalEventListenerProcessor\norg.springframework.context.event.internalEventListenerFactory\na02.Config\nbean1\nbean2\ncom.itheima.a02.A02$Bean1@12591ac8\n```\n\n我们发现除了注入了添加了注解的Bean，还注入了一些后处理器，这是由Spring主动给我们注入的。\n\n配置xml的时候也可以通过标签去加入这些后处理器：\n\n```XML\n<context:annotation-config/>\n```\n\n**源码剖析**\n\n```Plain\n//todo\n```\n\n4. AnnotationConfigServletWebServerApplicationContext\n\n**使用演示**\n\n准备配置类，并加上注解：\n\n```Java\n@Configuration\nstatic class WebConfig {\n    @Bean\n    public ServletWebServerFactory servletWebServerFactory(){\n        // 创建tomacat容器\n        return new TomcatServletWebServerFactory();\n    }\n    @Bean\n    public DispatcherServlet dispatcherServlet() {\n        // 创建DispatcherServlet\n        return new DispatcherServlet();\n    }\n    @Bean\n    public DispatcherServletRegistrationBean registrationBean(DispatcherServlet dispatcherServlet) {\n        // 注册DispatcherServletRegistrationBean，绑定拦截路径\n        return new DispatcherServletRegistrationBean(dispatcherServlet, \"/\");\n    }\n    @Bean(\"/hello\")\n    public Controller controller1() {\n        // 创建一个Controller \n        return (request, response) -> {\n            response.getWriter().print(\"hello\");\n            return null;\n        };\n    }\n}\n```\n\n控制台输出：\n\n```Plain\n[INFO ] 15:18:51.535 [main] o.s.b.w.e.tomcat.TomcatWebServer    - Tomcat initialized with port(s): 8080 (http) \n3�� 26, 2023 3:18:51 ���� org.apache.coyote.AbstractProtocol init\n��Ϣ: Initializing ProtocolHandler [\"http-nio-8080\"]\n3�� 26, 2023 3:18:51 ���� org.apache.catalina.core.StandardService startInternal\n��Ϣ: Starting service [Tomcat]\n3�� 26, 2023 3:18:51 ���� org.apache.catalina.core.StandardEngine startInternal\n��Ϣ: Starting Servlet engine: [Apache Tomcat/9.0.53]\n3�� 26, 2023 3:18:51 ���� org.apache.catalina.core.ApplicationContext log\n��Ϣ: Initializing Spring embedded WebApplicationContext\n[INFO ] 15:18:51.682 [main] o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 814 ms \n3�� 26, 2023 3:18:51 ���� org.apache.coyote.AbstractProtocol start\n��Ϣ: Starting ProtocolHandler [\"http-nio-8080\"]\n[INFO ] 15:18:51.804 [main] o.s.b.w.e.tomcat.TomcatWebServer    - Tomcat started on port(s): 8080 (http) with context path '' \norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\norg.springframework.context.event.internalEventListenerProcessor\norg.springframework.context.event.internalEventListenerFactory\na02.WebConfig\nservletWebServerFactory\ndispatcherServlet\nregistrationBean\n/hello\n```\n\n我们发现tomcat也打印了很多日志，监听了8080端口，尝试访问localhost:8080/hello，浏览器返回：\n\n```Plain\nhello\n```\n\n说明生效了。\n\n**源码剖析**\n\n```Plain\n//todo\n```\n\n# Bean的生命周期\n\n## Bean的生命周期\n\n准备`Component`：\n\n```Java\n@Component\npublic class LifeCycleBean {\n    private static final Logger log = LoggerFactory.getLogger(LifeCycleBean.class);\n\n    public LifeCycleBean() {\n        log.debug(\"构造\");\n    }\n\n    @Autowired\n    public void autowire(@Value(\"${JAVA_HOME}\") String home) {\n        log.debug(\"依赖注入: {}\", home);\n    }\n\n    @PostConstruct\n    public void init() {\n        log.debug(\"初始化\");\n    }\n\n    @PreDestroy\n    public void destroy() {\n        log.debug(\"销毁\");\n    }\n}\n```\n\n编写启动类：\n\n```Java\n@SpringBootApplication\npublic class A03 {\n    public static void main(String[] args) {\n        ConfigurableApplicationContext context = SpringApplication.run(A03.class, args);\n        context.close();\n    }\n}\n```\n\n运行`main()`方法，查看控制台输出：\n\n```Plain\n//...\n[DEBUG] 15:30:04.169 [main] com.itheima.a03.LifeCycleBean       - 构造 \n[DEBUG] 15:30:04.172 [main] com.itheima.a03.LifeCycleBean       - 依赖注入: C:\\Path\\jdk-14.0.1 \n[DEBUG] 15:30:04.173 [main] com.itheima.a03.LifeCycleBean       - 初始化 \n//...\n[DEBUG] 15:30:04.755 [main] com.itheima.a03.LifeCycleBean       - 销毁 \n```\n\n发现执行顺序是(即`Bean`生命周期的四个阶段)：\n\n1. 构造方法\n2. `@Autowired`依赖注入\n3. `@PostConstruct`初始化\n4. `@PreDestroy`销毁\n\n`Spring`的`BeanFactory`默认只有一些核心功能，扩展功能是通过后处理器来实现的。有`BeanFacotry`后处理器与`Bean`后处理器。`BeanFactory`后处理器主要补充`BeanFactory`的一些定义，`Bean`后处理器主要提供`Bean`的生命周期各个阶段的扩展。\n\n这里主要演示`Bean`后处理器的使用：\n\n> `InstantiationAwareBeanPostProcessor`类和`DestructionAwareBeanPostProcessor`类都继承了`BeanPostProcessor`接口\n\n```Java\n@Component\npublic class MyBeanPostProcessor implements InstantiationAwareBeanPostProcessor, DestructionAwareBeanPostProcessor {\n\n    private static final Logger log = LoggerFactory.getLogger(MyBeanPostProcessor.class);\n\n    @Override\n    public void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {\n        if (beanName.equals(\"lifeCycleBean\"))\n            log.debug(\"<<<<<< 销毁之前执行, 如 @PreDestroy\");\n    }\n\n    @Override\n    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {\n        if (beanName.equals(\"lifeCycleBean\"))\n            log.debug(\"<<<<<< 实例化之前执行, 这里返回的对象会替换掉原本的 bean\");\n        return null;\n    }\n\n    @Override\n    public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {\n        if (beanName.equals(\"lifeCycleBean\")) {\n            log.debug(\"<<<<<< 实例化之后执行, 这里如果返回 false 会跳过依赖注入阶段\");\n//            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {\n        if (beanName.equals(\"lifeCycleBean\"))\n            log.debug(\"<<<<<< 依赖注入阶段执行, 如 @Autowired、@Value、@Resource\");\n        return pvs;\n    }\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        if (beanName.equals(\"lifeCycleBean\"))\n            log.debug(\"<<<<<< 初始化之前执行, 这里返回的对象会替换掉原本的 bean, 如 @PostConstruct、@ConfigurationProperties\");\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        if (beanName.equals(\"lifeCycleBean\"))\n            log.debug(\"<<<<<< 初始化之后执行, 这里返回的对象会替换掉原本的 bean, 如代理增强\");\n        return bean;\n    }\n}\n```\n\n运行`main()`方法，查看控制台输出：\n\n```Plain\n[DEBUG] 15:42:57.321 [main] com.itheima.a03.MyBeanPostProcessor - <<<<<< 实例化之前执行, 这里返回的对象会替换掉原本的 bean \n[DEBUG] 15:42:57.323 [main] com.itheima.a03.LifeCycleBean       - 构造 \n[DEBUG] 15:42:57.325 [main] com.itheima.a03.MyBeanPostProcessor - <<<<<< 实例化之后执行, 这里如果返回 false 会跳过依赖注入阶段 \n[DEBUG] 15:42:57.325 [main] com.itheima.a03.MyBeanPostProcessor - <<<<<< 依赖注入阶段执行, 如 @Autowired、@Value、@Resource \n[DEBUG] 15:42:57.326 [main] com.itheima.a03.LifeCycleBean       - 依赖注入: C:\\Path\\jdk-14.0.1 \n[DEBUG] 15:42:57.328 [main] com.itheima.a03.MyBeanPostProcessor - <<<<<< 初始化之前执行, 这里返回的对象会替换掉原本的 bean, 如 @PostConstruct、@ConfigurationProperties \n[DEBUG] 15:42:57.328 [main] com.itheima.a03.LifeCycleBean       - 初始化 \n[DEBUG] 15:42:57.328 [main] com.itheima.a03.MyBeanPostProcessor - <<<<<< 初始化之后执行, 这里返回的对象会替换掉原本的 bean, 如代理增强 \n//...\n[DEBUG] 15:42:57.972 [main] com.itheima.a03.MyBeanPostProcessor - <<<<<< 销毁之前执行, 如 @PreDestroy \n[DEBUG] 15:42:57.973 [main] com.itheima.a03.LifeCycleBean       - 销毁 \n```\n\n可以观察到功能增强方法调用的各个时机。\n\n## 模板方法模式\n\n准备类：\n\n```Java\npublic class TestMethodTemplate {\n\n    public static void main(String[] args) {\n    }\n\n    // 模板方法  Template Method Pattern\n    static class MyBeanFactory {\n        public Object getBean() {\n            Object bean = new Object();\n            System.out.println(\"构造 \" + bean);\n            System.out.println(\"依赖注入 \" + bean);\n            System.out.println(\"初始化 \" + bean);\n            return bean;\n        }\n    }\n}\n```\n\n以上类，如果我们想要增加`getBean()`方法的功能，我们必须要更改`getBean()`方法的代码，会使得`getBean()`方法越来越臃肿。\n\n因此，我们可以在代码中织入可能增强的操作：\n\n```Java\npublic class TestMethodTemplate {\n\n    public static void main(String[] args) {\n        MyBeanFactory beanFactory = new MyBeanFactory();\n        beanFactory.addBeanPostProcessor(bean -> System.out.println(\"解析 @Autowired\"));\n        beanFactory.addBeanPostProcessor(bean -> System.out.println(\"解析 @Resource\"));\n        beanFactory.getBean();\n    }\n\n    // 模板方法  Template Method Pattern\n    static class MyBeanFactory {\n        public Object getBean() {\n            Object bean = new Object();\n            System.out.println(\"构造 \" + bean);\n            System.out.println(\"依赖注入 \" + bean); // @Autowired, @Resource\n            for (BeanPostProcessor processor : processors) {\n                processor.inject(bean);\n            }\n            System.out.println(\"初始化 \" + bean);\n            return bean;\n        }\n\n        private List<BeanPostProcessor> processors = new ArrayList<>();\n\n        public void addBeanPostProcessor(BeanPostProcessor processor) {\n            processors.add(processor);\n        }\n    }\n\n    static interface BeanPostProcessor {\n        public void inject(Object bean); // 对依赖注入阶段的扩展\n    }\n}\n```\n\n不变的代码是模板，可变的就是增强的功能，这就是模板方法模式。\n\n# Bean后处理器\n\n## 常见的Bean后处理器\n\n这里介绍常见的三个Bean后处理器：\n\n- `AutowiredAnnotationBeanPostProcessor`：主要用来解析`@Autowired`、`@Value`等注解。\n- `CommonAnnotationBeanPostProcessor`：主要用来解析`@Resource`、`@PostConstruct`、`@PreDestroy`等注解。\n- `ConfigurationPropertiesBindingPostProcessor`：主要提供属性绑定的功能。\n\n准备类：\n\n```Java\npublic class Bean1 {\n    private static final Logger log = LoggerFactory.getLogger(Bean1.class);\n\n    private Bean2 bean2;\n\n    @Autowired\n    public void setBean2(Bean2 bean2) {\n        log.debug(\"@Autowired 生效: {}\", bean2);\n        this.bean2 = bean2;\n    }\n\n    @Autowired\n    private Bean3 bean3;\n\n    @Resource\n    public void setBean3(Bean3 bean3) {\n        log.debug(\"@Resource 生效: {}\", bean3);\n        this.bean3 = bean3;\n    }\n\n    private String home;\n\n    @Autowired\n    public void setHome(@Value(\"${JAVA_HOME}\") String home) {\n        log.debug(\"@Value 生效: {}\", home);\n        this.home = home;\n    }\n\n    @PostConstruct\n    public void init() {\n        log.debug(\"@PostConstruct 生效\");\n    }\n\n    @PreDestroy\n    public void destroy() {\n        log.debug(\"@PreDestroy 生效\");\n    }\n\n    @Override\n    public String toString() {\n        return \"Bean1{\" +\n               \"bean2=\" + bean2 +\n               \", bean3=\" + bean3 +\n               \", home='\" + home + '\\'' +\n               '}';\n    }\n}\n\npublic class Bean2 {\n}\n\npublic class Bean3 {\n}\n```\n\n编写启动类：\n\n```Java\npublic class A04 {\n    public static void main(String[] args) {\n        // ⬇️GenericApplicationContext 是一个【干净】的容器\n        GenericApplicationContext context = new GenericApplicationContext();\n\n        // ⬇️用原始方法注册三个 bean\n        context.registerBean(\"bean1\", Bean1.class);\n        context.registerBean(\"bean2\", Bean2.class);\n        context.registerBean(\"bean3\", Bean3.class);\n\n       \n        // ⬇️初始化容器\n        context.refresh(); // 执行beanFactory后处理器, 添加bean后处理器, 初始化所有单例\n\n\n        // ⬇️销毁容器\n        context.close();\n    }\n}\n```\n\n启动`main()`方法，发现控制台输出为空，说明`Bean1`中的注解都没有生效。这是因为我们没有添加`Bean`的后处理器。\n\n1. AutowiredAnnotationBeanPostProcessor\n\n`AutowiredAnnotationBeanPostProcessor`主要用来解析`@Autowired`、`@Value`等注解。\n\n我们添加以下代码：\n\n```Java\n// 支持值注入\ncontext.getDefaultListableBeanFactory().setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n// @Autowired @Value\ncontext.registerBean(AutowiredAnnotationBeanPostProcessor.class); \n```\n\n启动`main()`方法，查看控制台，我们发现`@Autowired`、`@Value`等注解已经生效：\n\n```Plain\n[DEBUG] 17:49:43.017 [main] com.itheima.a04.Bean1               - @Autowired 生效: com.itheima.a04.Bean2@6bf0219d \n[DEBUG] 17:49:43.041 [main] com.itheima.a04.Bean1               - @Value 生效: C:\\Path\\jdk-14.0.1 \n```\n\n2. CommonAnnotationBeanPostProcessor\n\n`CommonAnnotationBeanPostProcessor`：主要用来解析`@Resource`、`@PostConstruct`、`@PreDestroy`等注解。\n\n我们添加以下代码：\n\n```Java\ncontext.registerBean(CommonAnnotationBeanPostProcessor.class); // @Resource @PostConstruct @PreDestroy\n```\n\n启动`main()`方法，查看控制台，发现@`Resource`、`@PostConstruct`、`@PreDestroy`等注解已经生效：\n\n```Plain\n[DEBUG] 17:53:58.129 [main] com.itheima.a04.Bean1               - @Resource 生效: com.itheima.a04.Bean3@1356d4d4 \n[DEBUG] 17:53:58.192 [main] com.itheima.a04.Bean1               - @Autowired 生效: com.itheima.a04.Bean2@3541cb24 \n[DEBUG] 17:53:58.225 [main] com.itheima.a04.Bean1               - @Value 生效: C:\\Path\\jdk-14.0.1 \n[DEBUG] 17:53:58.231 [main] com.itheima.a04.Bean1               - @PostConstruct 生效 \n[DEBUG] 17:53:58.255 [main] com.itheima.a04.Bean1               - @PreDestroy 生效 \n```\n\n3. ConfigurationPropertiesBindingPostProcessor\n\n`ConfigurationPropertiesBindingPostProcessor`主要提供属性绑定的功能。\n\n我们准备以下代码：\n\n```Java\n@ConfigurationProperties(prefix = \"java\")\npublic class Bean4 {\n\n    private String home;\n\n    private String version;\n\n    public String getHome() {\n        return home;\n    }\n\n    public void setHome(String home) {\n        this.home = home;\n    }\n\n    public String getVersion() {\n        return version;\n    }\n\n    public void setVersion(String version) {\n        this.version = version;\n    }\n\n    @Override\n    public String toString() {\n        return \"Bean4{\" +\n               \"home='\" + home + '\\'' +\n               \", version='\" + version + '\\'' +\n               '}';\n    }\n}\n```\n\n在main方法中加入：\n\n```Java\nConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory());\n//...\nSystem.out.println(context.getBean(Bean4.class));\n```\n\n启动`main()`方法，查看控制台，发现属性已经绑定到类中。\n\n```Java\n//...\nBean4{home='C:\\Path\\jdk-20', version='20'}\n//...\n```\n\n## 依赖注解后处理器执行流程\n\n本节主要对AutowiredAnnotationBeanPostProcessor的执行流程进行分析。\n\n### findAutowiringMetadata()\n\n`findAutowiringMetadata()`方法主要用来获取需要进行依赖注入的元信息。\n\n首先准备代码：\n\n```Java\npublic class DigInAutowired {\n    public static void main(String[] args) throws Throwable {\n        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n        // 创建过程,依赖注入,初始化\n        beanFactory.registerSingleton(\"bean2\", new Bean2()); \n        beanFactory.registerSingleton(\"bean3\", new Bean3());\n        beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver()); // @Value解析\n        beanFactory.addEmbeddedValueResolver(new StandardEnvironment()::resolvePlaceholders); // ${} 的解析器\n        \n        // 1. 查找哪些属性、方法加了 @Autowired, 这称之为 InjectionMetadata\n        AutowiredAnnotationBeanPostProcessor processor = new AutowiredAnnotationBeanPostProcessor();\n        processor.setBeanFactory(beanFactory);\n        \n        Bean1 bean1 = new Bean1();\n        System.out.println(bean1);\n        processor.postProcessProperties(null, bean1, \"bean1\"); // 执行依赖注入 @Autowired @Value\n        System.out.println(bean1);\n        \n    }\n}\n```\n\n启动`main()`方法，查看控制台：\n\n```Plain\nBean1{bean2=null, bean3=null, home='null'}\n[DEBUG] 18:17:08.121 [main] com.itheima.a04.Bean1               - @Autowired 生效: com.itheima.a04.Bean2@175c2241 \n[DEBUG] 18:17:08.135 [main] com.itheima.a04.Bean1               - @Value 生效: C:\\Path\\jdk-14.0.1 \nBean1{bean2=com.itheima.a04.Bean2@175c2241, bean3=com.itheima.a04.Bean3@6025e1b6, home='C:\\Path\\jdk-14.0.1'}\n```\n\n我们发现，在`processor.postProcessProperties(null, bean1, \"bean1\")`方法执行之前，Bean1并没有进行依赖注入，而执行之后成功执行了依赖注入。说明`postProcessProperties(null, bean1, \"bean1\")`方法是执行依赖注入的核心方法。\n\n进入`postProcessProperties()`方法：\n\n```Java\npublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n    // 1.首先获取需要进行依赖注入的元信息\n    InjectionMetadata metadata = this.findAutowiringMetadata(beanName, bean.getClass(), pvs);\n\n    try {\n        // 2.执行依赖注入\n        metadata.inject(bean, beanName, pvs);\n        return pvs;\n    } catch (BeanCreationException var6) {\n        throw var6;\n    } catch (Throwable var7) {\n        throw new BeanCreationException(beanName, \"Injection of autowired dependencies failed\", var7);\n    }\n}\n```\n\n我们可以使用反射手动调用`findAutowiringMetadata()`方法：\n\n```Java\npublic class DigInAutowired {\n    public static void main(String[] args) throws Throwable {\n        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n        // 创建过程,依赖注入,初始化\n        beanFactory.registerSingleton(\"bean2\", new Bean2()); \n        beanFactory.registerSingleton(\"bean3\", new Bean3());\n        beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver()); // @Value解析\n        beanFactory.addEmbeddedValueResolver(new StandardEnvironment()::resolvePlaceholders); // ${} 的解析器\n        \n        // 1. 查找哪些属性、方法加了 @Autowired, 这称之为 InjectionMetadata\n        AutowiredAnnotationBeanPostProcessor processor = new AutowiredAnnotationBeanPostProcessor();\n        processor.setBeanFactory(beanFactory);\n        \n          Bean1 bean1 = new Bean1();\n//        System.out.println(bean1);\n//        processor.postProcessProperties(null, bean1, \"bean1\"); // 执行依赖注入 @Autowired @Value\n//        System.out.println(bean1);\n\n        Method findAutowiringMetadata = AutowiredAnnotationBeanPostProcessor.class.getDeclaredMethod(\"findAutowiringMetadata\", String.class, Class.class, PropertyValues.class);\n        findAutowiringMetadata.setAccessible(true);\n        InjectionMetadata metadata = (InjectionMetadata) findAutowiringMetadata.invoke(processor, \"bean1\", Bean1.class, null);// 获取 Bean1 上加了 @Value @Autowired 的成员变量，方法参数信息\n        System.out.println(metadata);\n\n        // 2. 调用 InjectionMetadata 来进行依赖注入, 注入时按类型查找值\n        metadata.inject(bean1, \"bean1\", null);\n        System.out.println(bean1);\n        \n    }\n}\n```\n\n启动`main()`方法，查看控制台：\n\n```Java\norg.springframework.beans.factory.annotation.InjectionMetadata@7f0eb4b4\n[DEBUG] 18:20:14.969 [main] com.itheima.a04.Bean1               - @Value 生效: C:\\Path\\jdk-14.0.1 \n[DEBUG] 18:20:14.976 [main] com.itheima.a04.Bean1               - @Autowired 生效: com.itheima.a04.Bean2@1165b38 \nBean1{bean2=com.itheima.a04.Bean2@1165b38, bean3=com.itheima.a04.Bean3@4c12331b, home='C:\\Path\\jdk-14.0.1'}\n```\n\n我们发现同样成功进行了依赖注入。\n\n### inject()\n\n`inject()`方法主要用来执行依赖注入，一般有三种注入方式：\n\n- 根据字段注入\n- 根据set方法注入\n- 根据值注入\n\n准备代码：\n\n```Java\npublic class DigInAutowired {\n    public static void main(String[] args) throws Throwable {\n        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n        beanFactory.registerSingleton(\"bean2\", new Bean2()); // 创建过程,依赖注入,初始化\n        beanFactory.registerSingleton(\"bean3\", new Bean3());\n        beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver()); // @Value\n        beanFactory.addEmbeddedValueResolver(new StandardEnvironment()::resolvePlaceholders); // ${} 的解析器\n\n        // 1. 查找哪些属性、方法加了 @Autowired, 这称之为 InjectionMetadata\n        AutowiredAnnotationBeanPostProcessor processor = new AutowiredAnnotationBeanPostProcessor();\n        processor.setBeanFactory(beanFactory);\n\n        Bean1 bean1 = new Bean1();\n//        System.out.println(bean1);\n//        processor.postProcessProperties(null, bean1, \"bean1\"); // 执行依赖注入 @Autowired @Value\n//        System.out.println(bean1);\n\n        Method findAutowiringMetadata = AutowiredAnnotationBeanPostProcessor.class.getDeclaredMethod(\"findAutowiringMetadata\", String.class, Class.class, PropertyValues.class);\n        findAutowiringMetadata.setAccessible(true);\n        InjectionMetadata metadata = (InjectionMetadata) findAutowiringMetadata.invoke(processor, \"bean1\", Bean1.class, null);// 获取 Bean1 上加了 @Value @Autowired 的成员变量，方法参数信息\n        System.out.println(metadata);\n\n        // 2. 调用 InjectionMetadata 来进行依赖注入, 注入时按类型查找值\n        //metadata.inject(bean1, \"bean1\", null);\n        //System.out.println(bean1);\n\n        // 3. 如何按类型查找值\n        // 根据字段注入\n        Field bean3 = Bean1.class.getDeclaredField(\"bean3\");\n        DependencyDescriptor dd1 = new DependencyDescriptor(bean3, false);\n        Object o = beanFactory.doResolveDependency(dd1, null, null, null);\n        System.out.println(o);\n\n        // 根据set方法注入\n        Method setBean2 = Bean1.class.getDeclaredMethod(\"setBean2\", Bean2.class);\n        DependencyDescriptor dd2 =\n                new DependencyDescriptor(new MethodParameter(setBean2, 0), true);\n        Object o1 = beanFactory.doResolveDependency(dd2, null, null, null);\n        System.out.println(o1);\n\n        // 根据值注入\n        Method setHome = Bean1.class.getDeclaredMethod(\"setHome\", String.class);\n        DependencyDescriptor dd3 = new DependencyDescriptor(new MethodParameter(setHome, 0), true);\n        Object o2 = beanFactory.doResolveDependency(dd3, null, null, null);\n        System.out.println(o2);\n\n    }\n}\n```\n\n启动`main()`方法，查看控制台：\n\n```Plain\norg.springframework.beans.factory.annotation.InjectionMetadata@7f0eb4b4\ncom.itheima.a04.Bean3@7b2bbc3\ncom.itheima.a04.Bean2@1aafa419\nC:\\Path\\jdk-14.0.1\n```\n\n# BeanFactory后处理器\n\n## 常用后处理器\n\n在`com.itheima.a05.component`包下创建类：\n\n```Java\n@Component\npublic class Bean2 {\n\n    private static final Logger log = LoggerFactory.getLogger(Bean2.class);\n\n    public Bean2() {\n        log.debug(\"我被 Spring 管理啦\");\n    }\n}\n\n@Controller\npublic class Bean3 {\n\n    private static final Logger log = LoggerFactory.getLogger(Bean3.class);\n\n    public Bean3() {\n        log.debug(\"我被 Spring 管理啦\");\n    }\n}\n\npublic class Bean4 {\n\n    private static final Logger log = LoggerFactory.getLogger(Bean4.class);\n\n    public Bean4() {\n        log.debug(\"我被 Spring 管理啦\");\n    }\n}\n```\n\n在`com.itheima.a05`包下创建类：\n\n```Java\npublic class Bean1 {\n\n    private static final Logger log = LoggerFactory.getLogger(Bean1.class);\n\n    public Bean1() {\n        log.debug(\"我被 Spring 管理啦\");\n    }\n}\n\n@Configuration\n@ComponentScan(\"com.itheima.a05.component\")\npublic class Config {\n    @Bean\n    public Bean1 bean1() {\n        return new Bean1();\n    }\n\n    @Bean\n    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) {\n        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();\n        sqlSessionFactoryBean.setDataSource(dataSource);\n        return sqlSessionFactoryBean;\n    }\n\n    @Bean(initMethod = \"init\")\n    public DruidDataSource dataSource() {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"root\");\n        return dataSource;\n    }\n    \n}\n```\n\n在`com.itheima.a05`包下创建启动类：\n\n```Java\npublic class A05 {\n    private static final Logger log = LoggerFactory.getLogger(A05.class);\n\n    public static void main(String[] args) throws IOException {\n\n        // ⬇️GenericApplicationContext 是一个【干净】的容器\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"config\", Config.class);\n\n        // ⬇️初始化容器\n        context.refresh();\n\n        for (String name : context.getBeanDefinitionNames()) {\n            System.out.println(name);\n        }\n\n        // ⬇️销毁容器\n        context.close();\n    }\n}\n```\n\n启动`main()`方法，查看控制台：\n\n```Plain\nconfig\n```\n\n发现只有我们手动注册的`Config`类在`spring`容器中，`Config`类上的注解`@ComponentScan(\"com.itheima.a05.component\")`并没有生效。\n\n1. ConfigurationClassPostProcesso\n\n`ConfigurationClassPostProcessor` `BeanFactory`后处理器的作用是解析`@ComponentScan`、`@Bean`、`@Import`、`@ImportResource`等注解。\n\n我们在代码中加入`ConfigurationClassPostProcessor`后处理器：\n\n```Java\n// @ComponentScan @Bean @Import @ImportResource\ncontext.registerBean(ConfigurationClassPostProcessor.class); \n```\n\n启动`main()`方法，查看控制台：\n\n```Plain\n[DEBUG] 18:49:37.889 [main] com.itheima.a05.component.Bean2     - 我被 Spring 管理啦 \n[DEBUG] 18:49:37.896 [main] com.itheima.a05.component.Bean3     - 我被 Spring 管理啦 \n[DEBUG] 18:49:37.910 [main] com.itheima.a05.Bean1               - 我被 Spring 管理啦 \nconfig\norg.springframework.context.annotation.ConfigurationClassPostProcessor\nbean2\nbean3\nbean1\n```\n\n我们发现`@ComponentScan`注解已经生效。\n\n2. MapperScannerConfigurer\n\n`MapperScannerConfigurer` `BeanFactory`后处理器的作用是扫描`Mybatis`的`Mapper`接口。\n\n我们在`com.itheima.a05.mapper`包下创建代码：\n\n```Java\n@Mapper\npublic interface Mapper1 {\n}\n\n@Mapper\npublic interface Mapper2 {\n}\n```\n\n在启动类中添加代码：\n\n```Java\ncontext.registerBean(MapperScannerConfigurer.class, bd -> { // @MapperScanner\n    bd.getPropertyValues().add(\"basePackage\", \"com.itheima.a05.mapper\");\n});\n```\n\n启动`main()`方法，查看控制台：\n\n```Plain\n//...\nmapper1\nmapper2\n//...\n```\n\n我们发现`mapper`已被加入到`spring`中的容器中。\n\n## 模拟注解实现\n\n### @ComponentScan\n\n实现`BeanDefinitionRegistryPostProcessor`接口：\n\n```Java\npublic class ComponentScanPostProcessor implements BeanDefinitionRegistryPostProcessor {\n    @Override // context.refresh\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n\n    }\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanFactory) throws BeansException {\n        try {\n            ComponentScan componentScan = AnnotationUtils.findAnnotation(Config.class, ComponentScan.class);\n            if (componentScan != null) {\n                for (String p : componentScan.basePackages()) {\n                    System.out.println(p);\n                    // com.itheima.a05.component -> classpath*:com/itheima/a05/component/**/*.class\n                    String path = \"classpath*:\" + p.replace(\".\", \"/\") + \"/**/*.class\";\n                    System.out.println(path);\n                    CachingMetadataReaderFactory factory = new CachingMetadataReaderFactory();\n                    Resource[] resources = new PathMatchingResourcePatternResolver().getResources(path);\n                    AnnotationBeanNameGenerator generator = new AnnotationBeanNameGenerator();\n                    for (Resource resource : resources) {\n                        // System.out.println(resource);\n                        MetadataReader reader = factory.getMetadataReader(resource);\n                        // System.out.println(\"类名:\" + reader.getClassMetadata().getClassName());\n                        AnnotationMetadata annotationMetadata = reader.getAnnotationMetadata();\n                        // System.out.println(\"是否加了 @Component:\" + annotationMetadata.hasAnnotation(Component.class.getName()));\n                        // System.out.println(\"是否加了 @Component 派生:\" + annotationMetadata.hasMetaAnnotation(Component.class.getName()));\n                        if (annotationMetadata.hasAnnotation(Component.class.getName())\n                            || annotationMetadata.hasMetaAnnotation(Component.class.getName())) {\n                            AbstractBeanDefinition bd = BeanDefinitionBuilder\n                                    .genericBeanDefinition(reader.getClassMetadata().getClassName())\n                                    .getBeanDefinition();\n                            String name = generator.generateBeanName(bd, beanFactory);\n                            beanFactory.registerBeanDefinition(name, bd);\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n主要步骤：\n\n1. 获取`@ComponentScan`注解\n2. 获取`@ComponentScan`注解上的值`basePackages`\n3. 转换扫描包为真实路径\n4. 解析路径获取`resource`\n5. 根据`resource`获取元信息\n6. 判断是否直接或间接拥有`@Component`注解\n7. 注册`BeanDefinition`\n\n在`main()`方法中注册自己编写的`ComponentScanPostProcessor`类：\n\n```Java\ncontext.registerBean(ComponentScanPostProcessor.class); // 解析 @ComponentScan\n```\n\n运行`main()`方法，查看控制台，发现能够解析被`@Component`注解修饰的类：\n\n```Plain\n//...\nbean2\nbean3\n```\n\n### @Bean\n\n实现`BeanDefinitionRegistryPostProcessor`接口：\n\n```Java\npublic class AtBeanPostProcessor implements BeanDefinitionRegistryPostProcessor {\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n\n    }\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanFactory) throws BeansException {\n        try {\n            CachingMetadataReaderFactory factory = new CachingMetadataReaderFactory();\n            // 读取元信息\n            MetadataReader reader = factory.getMetadataReader(new ClassPathResource(\"com/itheima/a05/Config.class\"));\n            // 获取被@Bean注解标注的方法信息\n            Set<MethodMetadata> methods = reader.getAnnotationMetadata().getAnnotatedMethods(Bean.class.getName());\n            for (MethodMetadata method : methods) {\n                System.out.println(method);\n                // 获取初始化方法名称\n                String initMethod = method.getAnnotationAttributes(Bean.class.getName()).get(\"initMethod\").toString();\n                // 创建BeanDefinitionBuilder\n                BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition();\n                // 设置factoryBean\n                builder.setFactoryMethodOnBean(method.getMethodName(), \"config\");\n                // 设置自动装配模式\n                builder.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n                if (initMethod.length() > 0) {\n                    // 对初始化方法进行解析\n                    builder.setInitMethodName(initMethod);\n                }\n                AbstractBeanDefinition bd = builder.getBeanDefinition();\n                // 注册Bean\n                beanFactory.registerBeanDefinition(method.getMethodName(), bd);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n主要步骤：\n\n1. 根据类获取元信息\n2. 获取被`@Bean`注解标注的方法信息\n3. 创建`BeanDefinitionBuilder`\n4. 设置自动装配模式，用于依赖注入\n5. 注册`Bean`\n\n> 还可以根据需要设置初始化方法\n\n在`main()`方法中注册自己编写的`AtBeanPostProcessor`类：\n\n```Java\ncontext.registerBean(AtBeanPostProcessor.class); // 解析 @Bean\n```\n\n运行`main()`方法，查看控制台，发现Config类中被`@Bean`注解修饰的方法已经生效：\n\n```Plain\n//...\nbean1\nsqlSessionFactoryBean\ndataSource\n//...\n```\n\n### @Mapper\n\n在`Config`类中添加`Bean`：\n\n```Java\n@Bean\npublic MapperFactoryBean<Mapper1> mapper1(SqlSessionFactory sqlSessionFactory) {\n    MapperFactoryBean<Mapper1> factory = new MapperFactoryBean<>(Mapper1.class);\n    factory.setSqlSessionFactory(sqlSessionFactory);\n    return factory;\n}\n\n@Bean\npublic MapperFactoryBean<Mapper2> mapper2(SqlSessionFactory sqlSessionFactory) {\n    MapperFactoryBean<Mapper2> factory = new MapperFactoryBean<>(Mapper2.class);\n    factory.setSqlSessionFactory(sqlSessionFactory);\n    return factory;\n}\n```\n\n实现`BeanDefinitionRegistryPostProcessor`接口：\n\n```Java\npublic class MapperPostProcessor implements BeanDefinitionRegistryPostProcessor {\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanFactory) throws BeansException {\n        try {\n            // 创建resource解析器\n            PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();\n            // 获取resource\n            Resource[] resources = resolver.getResources(\"classpath:com/itheima/a05/mapper/**/*.class\");\n            AnnotationBeanNameGenerator generator = new AnnotationBeanNameGenerator();\n            CachingMetadataReaderFactory factory = new CachingMetadataReaderFactory();\n            for (Resource resource : resources) {\n                MetadataReader reader = factory.getMetadataReader(resource);\n                // 获取类元信息\n                ClassMetadata classMetadata = reader.getClassMetadata();\n                if (classMetadata.isInterface()) {\n                    // 获取BeanDefinition\n                    AbstractBeanDefinition bd = BeanDefinitionBuilder.genericBeanDefinition(MapperFactoryBean.class)\n                            // 根据名称调用MapperFactoryBean构造方法\n                            .addConstructorArgValue(classMetadata.getClassName())\n                            .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)\n                            .getBeanDefinition();\n                    // 获取接口名作为Bean的名称\n                    AbstractBeanDefinition bd2 = BeanDefinitionBuilder.genericBeanDefinition(classMetadata.getClassName()).getBeanDefinition();\n                    String name = generator.generateBeanName(bd2, beanFactory);\n                    // 注册Bean\n                    beanFactory.registerBeanDefinition(name, bd);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\n    }\n}\n```\n\n主要步骤：\n\n1. 创建`resource`解析器\n2. 获取`resource`\n3. 获取类元信息\n4. 获取`BeanDefinition`\n5. 获取接口名作为`Bean`的名称\n6. 注册`Bean`\n\n在`main()`方法中注册自己编写的`MapperPostProcessor`类：\n\n```Java\ncontext.registerBean(MapperPostProcessor.class); // 解析 Mapper 接口\n```\n\n运行`main()`方法，查看控制台，发现`com/itheima/a05/mapper`包中被`@MapperScan`注解修饰的方法已经生效：\n\n```Plain\n//...\nmapper1\nmapper2\n//...\n```\n\n# Aware接口\n\n## Aware与InitializingBean接口\n\n`Aware`接口用于注入一些与容器相关信息, 例如\n\n1. `BeanNameAware`注入`bean`的名字\n2. `BeanFactoryAware`注入`BeanFactory `容器\n3. `ApplicationContextAware`注入`ApplicationContext `容器\n4. `EmbeddedValueResolverAware`解析表达式，例如：${}\n\n`InitializingBean`接口提供内置的初始化手段。\n\n创建类`MyBean`并实现`BeanNameAware`、`ApplicationContextAware`、`InitializingBean`接口：\n\n```Java\npublic class MyBean implements BeanNameAware, ApplicationContextAware, InitializingBean {\n\n    private static final Logger log = LoggerFactory.getLogger(MyBean.class);\n\n    @Override\n    public void setBeanName(String name) {\n        log.debug(\"当前bean \" + this + \" 名字叫:\" + name);\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        log.debug(\"当前bean \" + this + \" 容器是:\" + applicationContext);\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        log.debug(\"当前bean \" + this + \" 初始化\");\n    }\n\n}\n```\n\n编写启动类：\n\n```Java\npublic class A06 {\n    private static final Logger log = LoggerFactory.getLogger(A06.class);\n\n    public static void main(String[] args) {\n        GenericApplicationContext context = new GenericApplicationContext();\n        context.registerBean(\"myBean\", MyBean.class);\n        context.refresh(); \n        context.close();\n    }\n}\n```\n\n运行`main()`方法，查看控制台：\n\n```Plain\n[DEBUG] 21:01:21.092 [main] com.itheima.a06.MyBean              - 当前bean com.itheima.a06.MyBean@20deea7f 名字叫:myBean \n[DEBUG] 21:01:21.118 [main] com.itheima.a06.MyBean              - 当前bean com.itheima.a06.MyBean@20deea7f 容器是:org.springframework.context.support.GenericApplicationContext@32464a14, started on Sun Mar 26 21:01:21 CST 2023 \n[DEBUG] 21:01:21.121 [main] com.itheima.a06.MyBean              - 当前bean com.itheima.a06.MyBean@20deea7f 初始化 \n```\n\n发现我们实现的方法都被调用。\n\n`Aware`接口的功能`@Autowired`就能实现, 为啥还要用`Aware`接口呢？\n\n1. `@Autowired`的解析需要用到`bean`后处理器, 属于扩展功能\n2. 而`Aware`接口属于内置功能, 不加任何扩展, `Spring`就能识别\n\n> 某些情况下, 扩展功能会失效, 而内置功能不会失效\n\n这里做一个测试，在`MyBean`类中添加如下方法：\n\n```Java\n@Autowired\npublic void aaa(ApplicationContext applicationContext) {\n    log.debug(\"当前bean \" + this + \" 使用@Autowired 容器是:\" + applicationContext);\n}\n\n@PostConstruct\npublic void init() {\n    log.debug(\"当前bean \" + this + \" 使用@PostConstruct 初始化\");\n}\n```\n\n我们必须在启动类中添加相应的Bean后处理器，`@Autowired`、`@PostConstruct`注解才能生效：\n\n```Java\ncontext.registerBean(AutowiredAnnotationBeanPostProcessor.class);\ncontext.registerBean(CommonAnnotationBeanPostProcessor.class);\n```\n\n查看控制台：\n\n```Plain\n[DEBUG] 21:07:23.998 [main] com.itheima.a06.MyBean              - 当前bean com.itheima.a06.MyBean@d21a74c 使用@Autowired 容器是:org.springframework.context.support.GenericApplicationContext@32464a14, started on Sun Mar 26 21:07:23 CST 2023 \n[DEBUG] 21:07:24.004 [main] com.itheima.a06.MyBean              - 当前bean com.itheima.a06.MyBean@d21a74c 名字叫:myBean \n[DEBUG] 21:07:24.004 [main] com.itheima.a06.MyBean              - 当前bean com.itheima.a06.MyBean@d21a74c 容器是:org.springframework.context.support.GenericApplicationContext@32464a14, started on Sun Mar 26 21:07:23 CST 2023 \n[DEBUG] 21:07:24.007 [main] com.itheima.a06.MyBean              - 当前bean com.itheima.a06.MyBean@d21a74c 使用@PostConstruct 初始化 \n[DEBUG] 21:07:24.008 [main] com.itheima.a06.MyBean              - 当前bean com.itheima.a06.MyBean@d21a74c 初始化 \n```\n\n## 注解失效分析\n\n准备`MyConfig1`类，注意其中添加了一个`beanFactory`后处理器：\n\n```Java\n@Configuration\npublic class MyConfig1 {\n\n    private static final Logger log = LoggerFactory.getLogger(MyConfig1.class);\n\n    @Autowired\n    public void setApplicationContext(ApplicationContext applicationContext) {\n        log.debug(\"注入 ApplicationContext\");\n    }\n\n    @PostConstruct\n    public void init() {\n        log.debug(\"初始化\");\n    }\n\n    @Bean //  beanFactory 后处理器\n    public BeanFactoryPostProcessor processor1() {\n        return beanFactory -> {\n            log.debug(\"执行 processor1\");\n        };\n    }\n\n}\n```\n\n编写启动类：\n\n```Java\npublic class A06 {\n    private static final Logger log = LoggerFactory.getLogger(A06.class);\n\n    public static void main(String[] args) {\n        GenericApplicationContext context = new GenericApplicationContext();\n        \n        context.registerBean(\"myConfig1\", MyConfig1.class);\n        \n        context.registerBean(AutowiredAnnotationBeanPostProcessor.class);\n        context.registerBean(CommonAnnotationBeanPostProcessor.class);\n        context.registerBean(ConfigurationClassPostProcessor.class);\n\n\n        context.refresh(); \n        context.close();\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 21:20:02.446 [main] com.itheima.a06.MyConfig1           - 执行 processor1 \n```\n\n发现`@Autowired`、`@PostConstruct`注解失效。\n\n`context.refresh()`的执行顺序：\n\n1. `BeanFactory`后处理器\n2. 添加`bean`后处理器\n3. 初始化单例\n\n`Java`配置类不包含`BeanFactoryPostProcessor`的情况：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%91%EF%BC%9AIOC/10.png)\n\n`Java`配置类包含`BeanFactoryPostProcessor`的情况，因此要创建其中的`BeanFactoryPostProcessor`必须提前创建`Java`配置类，而此时的`BeanPostProcessor`还未准备好，导致`@Autowired`等注解失效\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Spring%E9%AB%98%E7%BA%A745%E8%AE%B2%E3%80%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%91%EF%BC%9AIOC/11.png)\n\n使用内置的`InitializingBean`接口和`ApplicationContextAware`则不会失效：\n\n```Java\n@Configuration\npublic class MyConfig2 implements InitializingBean, ApplicationContextAware {\n\n    private static final Logger log = LoggerFactory.getLogger(MyConfig2.class);\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        log.debug(\"初始化\");\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        log.debug(\"注入 ApplicationContext\");\n    }\n\n    @Bean //  beanFactory 后处理器\n    public BeanFactoryPostProcessor processor2() {\n        return beanFactory -> {\n            log.debug(\"执行 processor2\");\n        };\n    }\n}\n```\n\n运行启动类，控制台输出：\n\n```Plain\n[DEBUG] 21:27:31.312 [main] com.itheima.a06.MyConfig2           - 注入 ApplicationContext \n[DEBUG] 21:27:31.318 [main] com.itheima.a06.MyConfig2           - 初始化 \n[INFO ] 21:27:31.321 [main] o.s.c.a.ConfigurationClassEnhancer  - @Bean method MyConfig2.processor2 is non-static and returns an object assignable to Spring's BeanFactoryPostProcessor interface. This will result in a failure to process annotations such as @Autowired, @Resource and @PostConstruct within the method's declaring @Configuration class. Add the 'static' modifier to this method to avoid these container lifecycle issues; see @Bean javadoc for complete details. \n[DEBUG] 21:27:31.333 [main] com.itheima.a06.MyConfig2           - 执行 processor2 \n```\n\n# 初始化与销毁\n\n## 初始化方法\n\n创建`Bean1`类，分别使用了三种初始化方法：\n\n1. 使用`@PostConstruct`注解初始化\n2. 实现接口`InitializingBean`的`afterPropertiesSet()`方法\n3. 使用`@Bean(initMethod = \"init3\")`注解的`initMethod`属性\n\n```Java\npublic class Bean1 implements InitializingBean {\n    private static final Logger log = LoggerFactory.getLogger(Bean1.class);\n\n    @PostConstruct\n    public void init1() {\n        log.debug(\"初始化1\");\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        log.debug(\"初始化2\");\n    }\n\n    public void init3() {\n        log.debug(\"初始化3\");\n    }\n}\n```\n\n创建启动类：\n\n```Java\n@SpringBootApplication\npublic class A07_1 {\n\n    public static void main(String[] args) {\n        ConfigurableApplicationContext context = SpringApplication.run(A07_1.class, args);\n        context.close();\n    }\n\n    @Bean(initMethod = \"init3\")\n    public Bean1 bean1() {\n        return new Bean1();\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 21:34:09.944 [main] com.itheima.a07.Bean1               - 初始化1 \n[DEBUG] 21:34:09.944 [main] com.itheima.a07.Bean1               - 初始化2 \n[DEBUG] 21:34:09.944 [main] com.itheima.a07.Bean1               - 初始化3 \n```\n\n初始化方法顺序：\n\n1. `@PostConstruct`注解初始化\n2. 接口`InitializingBean`的`afterPropertiesSet()`方法初始化\n3. `@Bean(initMethod = \"init3\")`注解的`initMethod`属性初始化\n\n## 销毁方法\n\n创建`Bean2`类，分别使用了三种销毁方法：\n\n1. 使用`@PreDestroy`注解销毁\n2. 实现接口`DisposableBean`的`destroy()`方法销毁\n3. 使用`@Bean(destroyMethod `**`= \"`**`destroy3`**`\"`**`)`注解的`destroyMethod`属性销毁\n\n```Java\npublic class Bean2 implements DisposableBean {\n    private static final Logger log = LoggerFactory.getLogger(Bean2.class);\n\n    @PreDestroy\n    public void destroy1() {\n        log.debug(\"销毁1\");\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        log.debug(\"销毁2\");\n    }\n\n    public void destroy3() {\n        log.debug(\"销毁3\");\n    }\n}\n```\n\n编写启动类：\n\n```Java\n@SpringBootApplication\npublic class A07_1 {\n\n    public static void main(String[] args) {\n        ConfigurableApplicationContext context = SpringApplication.run(A07_1.class, args);\n        context.close();\n    }\n\n    @Bean(destroyMethod = \"destroy3\")\n    public Bean2 bean2() {\n        return new Bean2();\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 21:34:10.565 [main] com.itheima.a07.Bean2               - 销毁1 \n[DEBUG] 21:34:10.566 [main] com.itheima.a07.Bean2               - 销毁2 \n[DEBUG] 21:34:10.566 [main] com.itheima.a07.Bean2               - 销毁3 \n```\n\n销毁方法执行顺序：\n\n1. `@PreDestroy`注解销毁\n2. 接口`DisposableBean`的`destroy()`方法销毁\n3. `@Bean(destroyMethod `**`= \"`**`destroy3`**`\"`**`)`注解的`destroyMethod`属性销毁\n\n# Scope\n\n## Scope的类型与销毁\n\nscope的类型有以下五种：\n\n- `singleton`：这是`Spring`默认的`scope`，表示`Spring`容器只创建唯一个`bean`的实例，所有该对象的引用都共享这个实例，并且`Spring`在创建第一次后，会在`Spring`的`IoC`容器中缓存起来，之后不再创建。这就是设计模式中的单例模式的形式。并且对该`bean`的所有后续请求和引用都将返回该缓存中的对象实例。一般情况下，无状态的`bean`使用该`scope`。\n- `prototype`：代表线程每次调用或请求这个`bean`都会创建一个新的实例，一般情况下，有状态的`bean`使用该`scope`。\n- `request`：每次`http`请求将会有各自的`bean`实例，类似于`prototype`，也就是说每个`request`作用域内的请求只创建一个实例。\n- `session`：在一个`http session`中，一个bean`定义`对应一个`bean`实例，也就是说每个`session`作用域内的请求只创建一个实例。\n- `application`：全局`web`应用级别，也是在`web`环境中使用的，一个`web`应用程序对应一个`bean`实例，通常情况下和`singleton`效果类似的，不过也有不一样的地方，`singleton`是每个`spring`容器中只有一个`bean`实例，一般我们的程序只有一个`spring`容器，但是，一个应用程序中可以创建多个`spring`容器，不同的容器中可以存在同名的`bean`，但是`scope=aplication`的时候，不管应用中有多少个`spring`容器，这个应用中同名的`bean`只有一个\n\n准备三个不同作用域的Bean：\n\n```Java\n@Scope(\"application\")\n@Component\npublic class BeanForApplication {\n    private static final Logger log = LoggerFactory.getLogger(BeanForApplication.class);\n\n    @PreDestroy\n    public void destroy() {\n        log.debug(\"destroy\");\n    }\n}\n\n@Scope(\"request\")\n@Component\npublic class BeanForRequest {\n    private static final Logger log = LoggerFactory.getLogger(BeanForRequest.class);\n\n    @PreDestroy\n    public void destroy() {\n        log.debug(\"destroy\");\n    }\n\n}\n\n@Scope(\"session\")\n@Component\npublic class BeanForSession {\n    private static final Logger log = LoggerFactory.getLogger(BeanForSession.class);\n\n    @PreDestroy\n    public void destroy() {\n        log.debug(\"destroy\");\n    }\n}\n```\n\n编写`Controller`：\n\n```Java\n@RestController\npublic class MyController {\n\n    @Lazy\n    @Autowired\n    private BeanForRequest beanForRequest;\n\n    @Lazy\n    @Autowired\n    private BeanForSession beanForSession;\n\n    @Lazy\n    @Autowired\n    private BeanForApplication beanForApplication;\n\n    @GetMapping(value = \"/test\", produces = \"text/html\")\n    public String test(HttpServletRequest request, HttpSession session) {\n        ServletContext sc = request.getServletContext();\n        String sb = \"<ul>\" +\n                    \"<li>\" + \"request scope:\" + beanForRequest + \"</li>\" +\n                    \"<li>\" + \"session scope:\" + beanForSession + \"</li>\" +\n                    \"<li>\" + \"application scope:\" + beanForApplication + \"</li>\" +\n                    \"</ul>\";\n        return sb;\n    }\n\n}\n```\n\n编写启动类：\n\n```Java\n/*\n    singleton, prototype, request, session, application\n\n    jdk >= 9 如果反射调用 jdk 中方法\n    jdk <= 8 不会有问题\n\n    演示 request, session, application 作用域\n    打开不同的浏览器, 刷新 http://localhost:8080/test 即可查看效果\n    如果 jdk > 8, 运行时请添加 --add-opens java.base/java.lang=ALL-UNNAMED\n */\n@SpringBootApplication\npublic class A08 {\n    public static void main(String[] args) {\n        SpringApplication.run(A08.class, args);\n    }\n}\n```\n\n运行启动类，访问http://localhost:8080/test，浏览器出现：\n\n```Plain\nrequest scope:com.itheima.a08.BeanForRequest@14742c57\nsession scope:com.itheima.a08.BeanForSession@2f6cff45\napplication scope:com.itheima.a08.BeanForApplication@3b82843b\n```\n\n每当我们刷新一次页面`BeanForRequest`的地址就会变化，说明`request`作用范围在一次请求中。当`session`会话过期，我们刷新页面`BeanForSession`的地址也会变化，说明`session`作用范围在一次会话中。当我们停止启动类，`BeanForApplication`会被销毁，说明`application`作用范围与容器生命周期一样长。\n\n## Scope失效解决方法\n\n**Scope失效情况演示**\n\n准备如下类：\n\n```Java\n//E为单例，依赖F1类(为多例)\n@Component\npublic class E {\n\n    @Autowired\n    private F1 f1;\n    \n    public F1 getF1() {\n        return f1;\n    }\n\n}\n\n//F1为多例\n@Scope(\"prototype\")\n@Component\npublic class F1 {\n}\n\n//启动类\n@ComponentScan(\"com.itheima.a08.sub\")\npublic class A08_1 {\n\n    private static final Logger log = LoggerFactory.getLogger(A08_1.class);\n\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(A08_1.class);\n\n        E e = context.getBean(E.class);\n        log.debug(\"{}\", e.getF1());\n        log.debug(\"{}\", e.getF1());\n        log.debug(\"{}\", e.getF1());\n\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Java\n[DEBUG] 23:17:58.864 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@30bce90b \n[DEBUG] 23:17:58.864 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@30bce90b \n[DEBUG] 23:17:58.864 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@30bce90b \n```\n\n我们发现E中的F1类地址始终为一个，说明多例失效了。\n\n### 解决方式一\n\n添加`@Lazy`注解：\n\n```Java\n@Component\npublic class E {\n\n    @Lazy\n    @Autowired\n    private F1 f1;\n    \n    public F1 getF1() {\n        return f1;\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 23:21:02.385 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@4196c360 \n[DEBUG] 23:21:02.409 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@225129c \n[DEBUG] 23:21:02.410 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@573906eb \n```\n\n我们发现E中的F1类地址每次都变化，说明多例生效了。\n\n事实上使用`@Lazy`注解，`spring`会为我们创建一个代理类，打印F类实例：\n\n```Java\nlog.debug(\"{}\", e.getF1().getClass());\n```\n\n查看输出：\n\n```Plain\n[DEBUG] 23:21:02.378 [main] com.itheima.a08.A08_1               - class com.itheima.a08.sub.F1$$EnhancerBySpringCGLIB$$21b324fd \n```\n\n发现是一个使用了`cglib`代理的类。\n\n### 解决方式二\n\n设置`proxyMode=ScopedProxyMode.TARGET_CLASS`，例如：\n\n```Java\n@Scope(value = \"prototype\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n@Component\npublic class F1 {\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 23:26:28.666 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@7c214cc0 \n[DEBUG] 23:26:28.696 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@609db546 \n[DEBUG] 23:26:28.696 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@56c4278e \n```\n\n`spring`同样为我们创建了代理类：\n\n```Plain\n[DEBUG] 23:26:28.658 [main] com.itheima.a08.A08_1               - class com.itheima.a08.sub.F1$$EnhancerBySpringCGLIB$$21b324fd \n```\n\n### 解决方式三\n\n使用`ObjectFactory`工厂，例如：\n\n```Java\n@Component\npublic class E {\n\n    @Autowired\n    private ObjectFactory<F3> f1;\n\n    public F3 getF1() {\n        return f1.getObject();\n    }\n    \n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 23:30:58.390 [main] com.itheima.a08.A08_1               - class com.itheima.a08.sub.F1\n[DEBUG] 23:30:58.390 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@59cba5a \n[DEBUG] 23:30:58.390 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@6f19ac19 \n[DEBUG] 23:30:58.390 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@71329995 \n```\n\n我们发现这种方式没有给我们创建代理。\n\n### 解决方式四\n\n使用`ApplicationContext`，例如：\n\n```Java\n@Component\npublic class E {\n    @Autowired\n    private ApplicationContext context;\n\n    public F4 getF1() {\n        return context.getBean(F1.class);\n    }\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n[DEBUG] 23:34:15.926 [main] com.itheima.a08.A08_1               - class com.itheima.a08.sub.F1 \n[DEBUG] 23:34:15.926 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@768fc0f2 \n[DEBUG] 23:34:15.926 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@5454d35e \n[DEBUG] 23:34:15.926 [main] com.itheima.a08.A08_1               - com.itheima.a08.sub.F1@20c0a64d \n```\n\n我们发现这种方式没有给我们创建代理。\n\n> 以上解决方式实际上都是延迟了多例对象的创建，使其在运行时创建，而不是在一开始就初始化完成。\n","tags":["spring"],"categories":["原理探究"]},{"title":"Spring高级45讲【第一章】：导学","url":"/2023/04/15/Spring高级45讲【第一章】：导学.html","content":"\n参考视频：[黑马程序员Spring视频教程，深度讲解spring5底层原理](https://www.bilibili.com/video/BV1P44y1N7QG?p=1&vd_source=c8a7fcd414305af438603cd6232e6259)\n\n源码仓库：[spring-test](https://gitee.com/lei-yongjian/spring-test)\n\n学习`Spring`的必须性？\n\n1. `Spring`是整个`Java`体系最核心的框架，没有之一\n2. 面试必备(`spring`的核心原理、`springmvc`的执行流程、`springboot`的自动装配...)\n3. 技术、思想提升(设计模式、高新技术发展...)\n\n阅读源码的错误姿势？\n\n1. 对`Spring`功能还不了解，还不会用呢，却要强读。不要轻易装B，轻则耗费心神，重则挫败放弃。**先会用，再研究。**\n2. 没有目的，一上来就`debug`，看到哪分析到哪。没有目的的`debug`，会让你迷失在源码当中，翻一百遍也是枉然。**明确要研究的问题，带着问题看代码。**\n3. 不分主次，分析一个问题时，引入另一个陌生问题。**抓住重点，逐个击破。**\n4. 只讲源码功能，不做单元测试。**眼过千遍，不如手过一遍**\n\n如何学习`Spring`？\n\n1. 了解要研究的组件（类）基本使用\n2. 用单元测试研究组件的特性\n3. 试着自己实现类似功能（选讲）\n4. 最后再深入阅读该组件的源码（避免讲）\n\n需要具备的前置知识？\n\n1. `Spring`的基础知识\n2. 想探究`Spring`原理的好奇心\n\n学习`Spring`有什么收获?\n\n1. 培养正确的学习源码方法\n2. 睥睨其它程序员的资本\n3. 唯一认清`Spring`的机会\n\n课程的主要内容？\n\n1. IOC\n2. AOP\n3. WEB\n4. BOOT\n5. OTHER\n","tags":["spring"],"categories":["原理探究"]},{"title":"并查集的介绍","url":"/2023/04/12/并查集的介绍.html","content":"\n# 并查集定义\n\n1. 并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题。\n2. 并查集通常包含两种操作\n    1. 查找(Find)：查询两个元素是否在同一个集合中\n    2. 合并(Union)：把两个不相交的集合合并为一个集合\n\n# 并查集思想\n\n请看以下示例：[116. 省份数量](https://leetcode.cn/problems/bLyHh0/submissions/388838513/)\n\n有n个城市，其中一些彼此相连，另一些没有相连。如果城市a与城市b直接相连，且城市b与城市c直接相连，那么城市a与城市c间接相连。\n\n**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。\n\n给出一个n x n的矩阵`isConnected`，其中`isConnected[i][j] = 1`表示第i个城市和第j个城市直接相连，而`isConnected[i][j] = 0`表示二者不直接相连。\n\n给出任意的两个城市i和j，判断是否为同一省份。\n\n并查集的思想就是将每个城市看作一个节点，如果节点之间有联系，那么就选择一个节点为其父节点，例如：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/1.jpg)\n\n若节点0和1有关联，那么随机选择0作为1的父节点：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/2.jpg)\n\n若1和2有关联，那么就找到1的根节点0，即0与2有关联，随机选择0作为父节点：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/3.jpg)\n\n同理，3与4有关联，我们选择4为父节点：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/4.jpg)\n\n3与5有关联，那么就找到3的根节点4，即4与5有关联，我们选择5为父节点：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/5.jpg)\n\n最后2与4有关联，那么我们找到2的根节点0，4的根节点5，随机选择5为根节点：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/6.jpg)\n\n最后所有节点都变成一棵树了，那么如何判断随机给出的两个节点是否为同一集合呢？其实只需要找到其根节点，判断根节点是否一致即可。\n\n并查集的思想就是将每一个不同的集合抽象成一棵棵不同树，对于任意的两个节点，查找其根节点，判断其根节点是否一致即可判断这两个节点是否在同一集合中。\n\n这种算法相对于深度查找与广度查找这种遍历来讲，它只需要朝一个方向去找，在优化树的高度情况下，查找效率更高；而深度广度查找需要查询所有关联的节点，效率相对较低。\n\n# 并查集代码\n\n## 初始化\n\n在实现并查集的时候使用数组即可：\n\n```Java\nparent[i] = j\n```\n\n其中parent数组下标i代表当前节点，j代表此节点的父节点下标。\n\n例如：\n\n```Java\nparent[0] = 1\n```\n\n代表下标为0的节点的父节点为下标为1的节点。\n\n在初始化的时候我们设置每个节点的父节点为当前节点。\n\n```Java\nint[] parent;\n\n/**\n * 初始化当前节点父节点为当前节点\n * @param n\n */\npublic void init(int n) {\n    parent = new int[n];\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n    }\n}\n```\n\n此时节点示意图如下：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/7.jpg)\n\n## 查找\n\n查找方法的目的是查找某个节点的根节点，我们可以使用递归查询。如果当前的根节点的父节点为自身则返回，否则递归查询父节点的根节点。\n\n```Java\n/**\n * 递归查询根节点\n *\n * @param index\n * @return\n */\npublic int find(int index) {\n    if (parent[index] != index) {\n        return index;\n    }\n    return find(parent[index]);\n}\n```\n\n要判断两个元素是否属于同一个集合，只需要看它们的根结点是否相同即可。\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/8.jpg)\n\n例如我们要查找1节点的根节点：\n\n1. 判断1节点的父节点是否为本身，1节点的父节点为0，不是本身\n2. 判断0节点的父节点是否为本身，0节点的父节点为5，不是本身\n3. 判断5节点的父节点是否为本身，是，返回\n\n## 合并\n\n要合并i节点与j节点，并不是直接合并，而是找到其根节点再进行合并。\n\n```Java\n/**\n * 合并节点，将i节点的根节点的父节点设置为j节点的根节点\n * @param i\n * @param j\n */\npublic void merge(int i, int j) {\n    parent[find(i)] = find(j);\n}\n```\n\n例如当前节点状态如下：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/9.jpg)\n\n要合并2和4节点，那么我们找到2的根节点0，4的根节点5，再进行合并：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/10.jpg)\n\n那么我们直接合并2和4节点会怎样呢？\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/11.jpg)\n\n我们发现上图中4节点有两个父节点，那么我们没法保证任意节点都有唯一的根节点，也就没法利用比较根节点这样的性质去判断两个节点是否为同一集合了。\n\n## 代码\n\n目前为止，并查集的完整代码如下：\n\n```Java\npublic class DisJointSetUnion {\n\n    int[] parent;\n\n    /**\n     * 初始化当前节点父节点为当前节点\n     *\n     * @param n\n     */\n    public void init(int n) {\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    /**\n     * 合并节点，将i节点的根节点的父节点设置为j节点的根节点\n     * @param i\n     * @param j\n     */\n    public void merge(int i, int j) {\n        parent[find(i)] = find(j);\n    }\n\n    /**\n     * 递归查询根节点\n     *\n     * @param index\n     * @return\n     */\n    public int find(int index) {\n        if (parent[index] != index) {\n            return index;\n        }\n        return find(parent[index]);\n    }\n}\n```\n\n# 并查集优化\n\n## 路径压缩\n\n路径压缩主要是压缩树的高度，用于提高并查集的效率。\n\n考虑以下场景：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/12.jpg)\n\n所有节点退化成了链表，这样还不如每个每个节点与其根节点直接产生联系：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/13.jpg)\n\n这样查询效率更高。\n\n我们可以考虑在查找的过程中，把沿途节点的父结点都设为根结点，进行路径压缩。\n\n```Java\n/**\n * 递归查询根节点\n *\n * @param index\n * @return\n */\npublic int find(int index) {\n    if (parent[index] != index) {\n        // 路径压缩\n        parent[index] = find(parent[index]);\n    }\n    return parent[index] ;\n}\n```\n\n这样一来，从查找的当前节点到根节点这一条路径都会被压缩，为后续的查询提高效率。\n\n## 按秩合并\n\n路径压缩只在查找的时候进行，也只压缩一条路径，所以并查集的最终结构仍然可能是比较复杂的，除非我们定时去压缩所有路径，例如：\n\n```Java\n/**\n * 压缩所有路径\n *\n * @return\n */\npublic void compress() {\n    for (int i = 0; i < parent.length; i++) {\n        find(i);\n    }\n}\n```\n\n假设，我们现在有一颗比较复杂的树，需要和一个单个元素的集合进行合并，需要如何选择根节点？\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/14.jpg)\n\n1. 如果选择6为根节点，最终的树结构如下：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/15.jpg)\n\n2. 如果选择5为根节点，最终的树结构如下：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/16.jpg)\n\n观察以上两种情况，我们发现第一种方式树的深度变高了，这意味着查询效率将会降低，而第二种方式树的高度不变。这启发我们要把深度小的树合并到深度大的树中。\n\n具体做法为：\n\n用rank[]数组来记录每个根结点对应的树的深度（如果不是根结点，则rank中的元素大小表示的是以当前结点作为根结点的子树的深度）；一开始，把所有元素的rank设为1，即自己就为一颗树，且深度为1；合并的时候，比较两个根结点，把rank较小者合并到较大者中去。\n\n```Java\n/**\n * 合并节点，将i节点的根节点的父节点设置为j节点的根节点\n *\n * @param i\n * @param j\n */\npublic void merge(int i, int j) {\n    int x = find(i), y = find(j);\n    if (x != y) {\n        // 按秩合并\n        if (rank[x] < rank[y]) {\n            parent[x] = y;\n        } else {\n            parent[y] = x;\n        }\n        // 如果深度相同，深度+1\n        if (rank[x] == rank[y]) {\n            rank[x]++;\n        }\n    }\n}\n```\n\n值得注意的是，两个节点深度相同时，才增加某个节点的深度，如果不相同，合并后两个节点的深度都不变。\n\n1. 深度相同，进行合并，合并后深度+1\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/17.jpg)\n\n2. 深度不同，进行合并，深度小的节点合并到深度大的节点上，合并后深度不变\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BB%8B%E7%BB%8D/18.jpg)\n\n# 代码通用模板\n\n```Java\npublic class DisJointSetUnion {\n\n    int[] rank;\n    int[] parent;\n\n    /**\n     * 初始化当前节点父节点为当前节点，初始化深度\n     *\n     * @param n\n     */\n    public void init(int n) {\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            rank[i] = 1;\n            parent[i] = i;\n        }\n    }\n\n    /**\n     * 合并节点，将i节点的根节点的父节点设置为j节点的根节点\n     *\n     * @param i\n     * @param j\n     */\n    public void merge(int i, int j) {\n        int x = find(i), y = find(j);\n        if (x != y) {\n            // 按秩合并\n            if (rank[x] < rank[y]) {\n                parent[x] = y;\n            } else {\n                parent[y] = x;\n            }\n            // 如果深度相同，深度+1\n            if (rank[x] == rank[y]) {\n                rank[x]++;\n            }\n        }\n\n    }\n\n    /**\n     * 递归查询根节点\n     *\n     * @param index\n     * @return\n     */\n    public int find(int index) {\n        if (parent[index] != index) {\n            // 路径压缩\n            parent[index] = find(parent[index]);\n        }\n        return parent[index];\n    }\n\n    /**\n     * 压缩所有路径\n     *\n     * @return\n     */\n    public void compress() {\n        for (int i = 0; i < parent.length; i++) {\n            find(i);\n        }\n    }\n}\n```\n","tags":["并查集"],"categories":["数据结构"]},{"title":"小于n的最大数","url":"/2023/04/11/小于n的最大数.html","content":"\n# 题目描述\n\n数组nums中给定可以使用的1~9的数，返回由数组nums中的元素组成的小于n的最大数。\n\n示例 1：\n\n```Plain\n输入：nums = {1, 2, 9, 4}，n = 2533\n输出：2499\n```\n\n示例 2：\n\n```Plain\n输入：nums = {1, 2, 5, 4}，n = 2543\n输出：2542\n```\n\n示例 3：\n\n```Plain\n输入：nums = {1, 2, 5, 4}，n = 2541\n输出：2525\n```\n\n示例 4：\n\n```Plain\n输入：nums = {1, 2, 9, 4}，n = 2111\n输出：1999\n```\n\n示例 5：\n\n```Plain\n输入：nums = {5, 9}，n = 5555\n输出：999\n```\n\n示例 6：\n\n```Plain\n输入：nums = {5, 9}，n = 3\n输出：-1\n```\n\n# 我的解法\n\n## 思路\n\n1. 对每一位先尝试使用相同数字\n2. 如果没有相同数字，判断是否存在比当前数字更小的数字，如果有，则选择更小数字中的最大数，剩余的数字用最大数字\n3. 如果没有，向前查找前一个数字有没有更小的数字\n4. 直到回溯到第一个数字，就用位数更少但全部都是最大的数\n\n## 代码\n\n在实际代码编写中我们添加一个标志末尾字符，当遍历到此字符时必定会向前查找，统一因缺少数字与所有数字都包含的情况，例如：\n\n1. 缺少数字\n\n```Plain\n输入：nums = {1, 2, 9, 4}，n = 2533\n输出：2499\n```\n\n2533遍历到第一个3时，因为nums数组中不存在3，因此需要向前一位查找更小的数字\n\n2. 所有数字都包含\n\n```Plain\n输入：nums = {1, 2, 9, 4}，n = 2111\n输出：1999\n```\n\n2111遍历完毕，所有的数字都包含，最后结果为2111，因此需要再向前一位查找更小的数字\n\n添加一个标志末尾字符的目的就是统一以上两种情况，避免重复编码，值得注意的是添加的标志字符的ASCII码值应小于'0'，必须使set.lower(num)返回为null。\n\n```Java\nclass Solution {\n\n    public int getMaxNumBelowN(int[] nums, int n) {\n        TreeSet<Integer> set = new TreeSet<>();\n        Arrays.stream(nums).forEach(set::add);\n        StringBuilder result = new StringBuilder();\n        int max = Arrays.stream(nums).max().getAsInt();\n        StringBuilder s = new StringBuilder(String.valueOf(n)).append('!');\n        for (int i = 0; i < s.length(); i++) {\n            int num1 = s.charAt(i) - '0';\n            result.append(s.charAt(i));\n            if (!set.contains(num1)) {\n                // 从当前位置向前查找\n                for (int j = result.length() - 1; j >= 0; j--) {\n                    int num = result.charAt(j) - '0';\n                    result.deleteCharAt(j);\n                    Integer lower = set.lower(num);\n                    if (lower != null) {\n                        result.append(lower);\n                        while (result.length() < s.length() - 1) {\n                            result.append(max);\n                        }\n                        return Integer.parseInt(result.toString());\n                    }\n                }\n                // 不存在小于n的最大数\n                int length = s.length() - 2;\n                if (length == 0) {\n                    return -1;\n                }\n                // 向前未找到小于n的最大数\n                return Integer.parseInt(String.valueOf(max).repeat(length));\n            }\n        }\n        return -1;\n    }\n\n}\n```\n\n## 测试\n\n添加测试用例：\n\n```Java\nclass Test {\n    int[] nums;\n    int n;\n    int expect;\n\n    public Test(int[] nums, int n, int expect) {\n        this.nums = nums;\n        this.n = n;\n        this.expect = expect;\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        Test[] testList = new Test[]{\n                new Test(new int[]{1, 2, 9, 4}, 2533, 2499),\n                new Test(new int[]{1, 2, 5, 4}, 2543, 2542),\n                new Test(new int[]{1, 2, 5, 4}, 2541, 2525),\n                new Test(new int[]{1, 2, 9, 4}, 2111, 1999),\n                new Test(new int[]{1, 2, 9, 4}, 1111, 999),\n                new Test(new int[]{5, 9}, 5555, 999),\n                new Test(new int[]{5, 9}, 33, 9),\n                new Test(new int[]{5, 9}, 3, -1),\n                new Test(new int[]{5, 9, 7}, 9, 7),\n                new Test(new int[]{6, 7, 8}, 1200, 888),\n                new Test(new int[]{1, 2, 4, 9}, 4921, 4919),\n        };\n        for (Test test : testList) {\n            int maxNumBelowN = solution.getMaxNumBelowN(test.nums, test.n);\n            System.out.println((maxNumBelowN == test.expect) + \"------>\" + maxNumBelowN);\n        }\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\ntrue------>2542\ntrue------>2525\ntrue------>1999\ntrue------>999\ntrue------>999\ntrue------>9\ntrue------>-1\ntrue------>7\ntrue------>888\ntrue------>4919\n```\n","tags":["算法题"],"categories":["算法练习"]},{"title":"懂车帝二面复盘","url":"/2023/04/11/懂车帝二面复盘.html","content":"\n时间：2023年04月10日 17:00\n\n# 场景\n\n数据推送到内存中，如何做到不产生并发问题。\n\n请看以下示例：\n\n```Java\npublic class Main {\n\n    public static void main(String[] args) throws InterruptedException {\n        Test test = new Test();\n        Thread readThread = new Thread(new Runnable1(test));\n        readThread.start();\n        Thread writeThread = new Thread(new Runnable2(test));\n        writeThread.start();\n        Thread.currentThread().join();\n    }\n\n}\n\n\n@Data\nclass Runnable2 implements Runnable {\n\n    private Random random = new Random();\n\n    private Test test;\n\n    public Runnable2(Test test) {\n        this.test = test;\n    }\n\n    /**\n     * 修改test中的数据\n     */\n    @SneakyThrows\n    @Override\n    public void run() {\n        while (true) {\n            int n = random.nextInt(20);\n            ArrayList<Integer> newData = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                newData.add(random.nextInt(20));\n            }\n            test.updateData(newData);\n            System.out.println(\"替换数据为：\" + newData);\n            Thread.sleep(1000);\n        }\n    }\n}\n\n\n@Data\nclass Runnable1 implements Runnable {\n\n    private Random random = new Random();\n\n    private Test test;\n\n    public Runnable1(Test test) {\n        this.test = test;\n    }\n\n    /**\n     * 打印test中的数据\n     */\n    @SneakyThrows\n    @Override\n    public void run() {\n        while (true) {\n            System.out.println(\"打印之前：\" + test.getData());\n            test.printData();\n            System.out.println(\"打印之后：\" + test.getData());\n        }\n    }\n}\n\n\n@Data\nclass Test {\n    private volatile List<Integer> data = new ArrayList<>();\n\n    @SneakyThrows\n    public void printData() {\n        for (int i = 0; i < data.size(); i++) {\n            System.out.print(data.get(i) + \" \");\n            Thread.sleep(300);\n        }\n        System.out.println();\n    }\n\n    public void updateData(List<Integer> data) {\n        this.data = data;\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n打印之前：[19, 16, 5, 13]\n19 16 5 替换数据为：[7, 13, 4, 18, 17, 3, 8, 8, 11, 12, 2, 17, 5]\n18 17 3 8 替换数据为：[18, 14]\n\n打印之后：[18, 14]\n```\n\n发现这样替换数据会产生并发问题，也就是在打印过程中，数据源直接被替换，那么打印的数据也就被替换了。其实解决方案很简单，就是使用一个局部变量接收共享变量的值，使用局部变量进行遍历，这个局部变量只有两种状态，要么是旧数据要么是新数据，不会被改变。\n\n修改`printData()`方法：\n\n```Java\n@SneakyThrows\npublic void printData() {\n    // 使用局部变量记录数据\n    List<Integer> data = this.data;\n    for (int i = 0; i < data.size(); i++) {\n        System.out.print(data.get(i) + \" \");\n        Thread.sleep(300);\n    }\n    System.out.println();\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\n打印之前：[10, 14, 15, 6, 15, 4, 16, 18, 7, 2, 14, 0, 5, 9, 14, 18, 18]\n10 14 15 6 替换数据为：[19]\n15 4 16 替换数据为：[11, 9, 1, 10, 16, 1, 15, 13, 16, 10, 15, 12, 17]\n18 7 2 替换数据为：[14, 10, 7, 2]\n14 0 5 9 替换数据为：[18]\n14 18 18 替换数据为：[15, 18, 10, 7, 1, 9, 5, 4, 18]\n\n打印之后：[15, 18, 10, 7, 1, 9, 5, 4, 18]\n```\n\n我们发现原始数据已经被更新多次，但打印的数据还是旧数据，状态一致，保证了并发的安全性，同时无锁也保证了并发度。\n\n# 算法\n\n数组nums中给定可以使用的1~9的数，返回由数组nums中的元素组成的小于n的最大数。\n\n此题leetcode上也有讨论贴：[小于n的最大数](https://leetcode.cn/circle/discuss/fbhhev/)\n\n示例 1：\n\n```Plain\n输入：nums = {1, 2, 9, 4}，n = 2533\n输出：2499\n```\n\n示例 2：\n\n```Plain\n输入：nums = {1, 2, 5, 4}，n = 2543\n输出：2542\n```\n\n示例 3：\n\n```Plain\n输入：nums = {1, 2, 5, 4}，n = 2541\n输出：2525\n```\n\n示例 4：\n\n```Plain\n输入：nums = {1, 2, 9, 4}，n = 2111\n输出：1999\n```\n\n示例 5：\n\n```Plain\n输入：nums = {5, 9}，n = 5555\n输出：999\n```\n\n示例 6：\n\n```Plain\n输入：nums = {5, 9}，n = 3\n输出：-1\n```\n\n## 思路\n\n1. 对每一位先尝试使用相同数字\n2. 如果没有相同数字，判断是否存在比当前数字更小的数字，如果有，则选择更小数字中的最大数，剩余的数字用最大数字\n3. 如果没有，向前查找前一个数字有没有更小的数字\n4. 直到回溯到第一个数字，就用位数更少但全部都是最大的数\n\n## 代码\n\n在实际代码编写中我们添加一个标志末尾字符，当遍历到此字符时必定会向前查找，统一因缺少数字与所有数字都包含的情况，例如：\n\n1. 缺少数字\n\n```Plain\n输入：nums = {1, 2, 9, 4}，n = 2533\n输出：2499\n```\n\n2533遍历到第一个3时，因为nums数组中不存在3，因此需要向前一位查找更小的数字\n\n2. 所有数字都包含\n\n```Plain\n输入：nums = {1, 2, 9, 4}，n = 2111\n输出：1999\n```\n\n2111遍历完毕，所有的数字都包含，最后结果为2111，因此需要再向前一位查找更小的数字\n\n添加一个标志末尾字符的目的就是统一以上两种情况，避免重复编码，值得注意的是添加的标志字符的ASCII码值应小于'0'，必须使set.lower(num)返回为null。\n\n```Java\nclass Solution {\n\n    public int getMaxNumBelowN(int[] nums, int n) {\n        TreeSet<Integer> set = new TreeSet<>();\n        Arrays.stream(nums).forEach(set::add);\n        StringBuilder result = new StringBuilder();\n        int max = Arrays.stream(nums).max().getAsInt();\n        StringBuilder s = new StringBuilder(String.valueOf(n)).append('!');\n        for (int i = 0; i < s.length(); i++) {\n            int num1 = s.charAt(i) - '0';\n            result.append(s.charAt(i));\n            if (!set.contains(num1)) {\n                // 从当前位置向前查找\n                for (int j = result.length() - 1; j >= 0; j--) {\n                    int num = result.charAt(j) - '0';\n                    result.deleteCharAt(j);\n                    Integer lower = set.lower(num);\n                    if (lower != null) {\n                        result.append(lower);\n                        while (result.length() < s.length() - 1) {\n                            result.append(max);\n                        }\n                        return Integer.parseInt(result.toString());\n                    }\n                }\n                // 不存在小于n的最大数\n                int length = s.length() - 2;\n                if (length == 0) {\n                    return -1;\n                }\n                // 向前未找到小于n的最大数\n                return Integer.parseInt(String.valueOf(max).repeat(length));\n            }\n        }\n        return -1;\n    }\n\n}\n```\n\n## 测试\n\n添加测试用例：\n\n```Java\nclass Test {\n    int[] nums;\n    int n;\n    int expect;\n\n    public Test(int[] nums, int n, int expect) {\n        this.nums = nums;\n        this.n = n;\n        this.expect = expect;\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        Test[] testList = new Test[]{\n                new Test(new int[]{1, 2, 9, 4}, 2533, 2499),\n                new Test(new int[]{1, 2, 5, 4}, 2543, 2542),\n                new Test(new int[]{1, 2, 5, 4}, 2541, 2525),\n                new Test(new int[]{1, 2, 9, 4}, 2111, 1999),\n                new Test(new int[]{1, 2, 9, 4}, 1111, 999),\n                new Test(new int[]{5, 9}, 5555, 999),\n                new Test(new int[]{5, 9}, 33, 9),\n                new Test(new int[]{5, 9}, 3, -1),\n                new Test(new int[]{5, 9, 7}, 9, 7),\n                new Test(new int[]{6, 7, 8}, 1200, 888),\n                new Test(new int[]{1, 2, 4, 9}, 4921, 4919),\n        };\n        for (Test test : testList) {\n            int maxNumBelowN = solution.getMaxNumBelowN(test.nums, test.n);\n            System.out.println((maxNumBelowN == test.expect) + \"------>\" + maxNumBelowN);\n        }\n    }\n\n}\n```\n\n运行启动类，查看控制台：\n\n```Plain\ntrue------>2542\ntrue------>2525\ntrue------>1999\ntrue------>999\ntrue------>999\ntrue------>9\ntrue------>-1\ntrue------>7\ntrue------>888\ntrue------>4919\n```\n","tags":["面试经验"],"categories":["面试经验"]},{"title":"Java中i=i++问题","url":"/2023/04/04/Java中i=i-问题.html","content":"\n猜猜以下代码的输出：\n\n```Java\npublic class Test {\n\n    public static void main(String[] args) {\n        int i = 0;\n        for (int j = 0; j < 100; j++) {\n            i = i++;\n        }\n        System.out.println(\"result = \" + i);\n    }\n\n}\n```\n\n输出为：\n\n```Plain\nresult = 0\n```\n\n刚开始还以为是答案错误，在idea中运行了一下发现，还真是这样。\n\n按照一般的思路，i = i ++ 应该分为两步:\n\n1. i = i \n2. i ++\n\n结果应该为：\n\n```Plain\nresult = 100\n```\n\n上网查了一下：\n\ni = i ++ 的步骤其实分为三步：\n\n1. 把变量i的值取出来，放在一个临时变量里(记作temp)；\n2. 把变量i的值进行自加操作；\n3. 把临时变量temp的值作为自增运算前i的值使用;\n\n经过以上三步操作以后，虽然变量i在第2步操作中进行了自增运算，但第3步操作以后又把原来的值赋给了它，故最后输出结果为0。\n\n> 这个说法蛮靠谱的，我又使用c语言测试了一下，输出也为相同的结果。\n\n参考博客：\n\n- [i = i++问题](https://blog.csdn.net/brooksychen/article/details/1624753)\n","tags":["java基础"],"categories":["java"]},{"title":"排序算法","url":"/2023/04/04/排序算法.html","content":"\n# 算法概述\n\n排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。\n\n常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png)\n\n各算法对比：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png)\n\n# 冒泡排序\n\n## 算法思想\n\n冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢\"浮\"到数列的顶端。\n\n## 算法步骤\n\n1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，数组末尾会形成有序区\n3. 针对无序区域元素重复以上的步骤，最多重复数组长度-1次\n\n## 代码实现\n\n```Java\n/**\n * 原始实现\n *\n * @param array\n */\npublic static void sort1(int[] array) {\n    for (int i = 0; i < array.length - 1; i++) {\n        for (int j = 0; j < array.length - i - 1; j++) {\n            if (array[j] > array[j + 1]) {\n                int temp = array[j];\n                array[j] = array[j + 1];\n                array[j + 1] = temp;\n            }\n        }\n    }\n}\n```\n\n## 优化版本\n\n### 提前退出\n\n基本思想是当某一次比较没有产生交换时，表明数组已经是有序了，因此可以设置一个变量进行判断。\n\n```Java\n/**\n * 使用变量提前结束\n *\n * @param array\n */\npublic static void sort2(int[] array) {\n    for (int i = 0; i < array.length - 1; i++) {\n        boolean f = true;\n        for (int j = 0; j < array.length - i - 1; j++) {\n            if (array[j] > array[j + 1]) {\n                int temp = array[j];\n                array[j] = array[j + 1];\n                array[j + 1] = temp;\n                f = false;\n            }\n        }\n        if (f) {\n            break;\n        }\n    }\n}\n```\n\n### 记录边界\n\n原始冒泡排序默认无序序列的边界为`array.length-i-1`，而实际情况不一定，我们可以通过变量记录每次交换后的无序序列的边界，加快排序速度。\n\n```Java\n/**\n * 记录无序序列的边界\n *\n * @param array\n */\npublic static void sort3(int[] array) {\n\n    int sortBorder = array.length - 1;\n\n    for (int i = 0; i < array.length - 1; i++) {\n        boolean f = true;\n        int lastChange = sortBorder;\n        for (int j = 0; j < sortBorder; j++) {\n            if (array[j] > array[j + 1]) {\n                int temp = array[j];\n                array[j] = array[j + 1];\n                array[j + 1] = temp;\n                f = false;\n                lastChange = j;\n            }\n        }\n        sortBorder = lastChange;\n        if (f) {\n            break;\n        }\n    }\n}\n```\n\n### 双向冒泡\n\n观察以下示例：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.png)\n\n我们发现2，3，4，5，6，7，8其实是相对又续了的，但因为1的存在却还进行了七轮冒泡，因此我们可以双向冒泡，奇数轮从左到右，偶数轮从右到左冒泡，这也叫鸡尾酒排序。\n\n```Java\n/**\n * 鸡尾酒排序，基于冒泡排序的双向版本\n *\n * @param array\n */\npublic static void sort4(int[] array) {\n\n    for (int i = 0; i < array.length / 2; i++) {\n        boolean f = true;\n        for (int j = i; j < array.length - i - 1; j++) {\n            if (array[j] > array[j + 1]) {\n                int temp = array[j];\n                array[j] = array[j + 1];\n                array[j + 1] = temp;\n                f = false;\n            }\n        }\n        if (f) {\n            break;\n        }\n        f = true;\n        for (int j = array.length - i - 1; j > i; j--) {\n            if (array[j - 1] > array[j]) {\n                int temp = array[j];\n                array[j] = array[j - 1];\n                array[j - 1] = temp;\n                f = false;\n            }\n        }\n        if (f) {\n            break;\n        }\n    }\n}\n```\n\n# 选择排序\n\n## 算法思想\n\n选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。\n\n## 算法步骤\n\n1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。\n2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n3. 重复第二步，直到所有元素均排序完毕。\n\n## 代码实现\n\n```Java\npublic static void sort(int[] array) {\n    for (int i = 0; i < array.length - 1; i++) {\n        int index = i;\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[j] < array[index]) {\n                index = j;\n            }\n        }\n        if (index != i) {\n            int temp = array[i];\n            array[i] = array[index];\n            array[index] = temp;\n        }\n    }\n}\n```\n\n# 插入排序\n\n## 算法思想\n\n插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n\n## 算法步骤\n\n1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n3. 直到整个序列有序\n\n## 代码实现\n\n```Java\npublic static void sort(int[] array) {\n    for (int i = 1; i < array.length; i++) {\n        int insertValue = array[i];\n        int j = i - 1;\n        while (j >= 0 && insertValue < array[j]) {\n            array[j + 1] = array[j];\n            j--;\n        }\n        array[j + 1] = insertValue;\n    }\n}\n```\n\n# 希尔排序\n\n## 算法思想\n\n希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n\n- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；\n- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；\n\n希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录\"基本有序\"时，再对全体记录进行依次直接插入排序。\n\n## 算法步骤\n\n1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；\n2. 按增量序列个数 k，对序列进行 k 趟排序；\n3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n## 代码实现\n\n```Java\npublic static void sort(int[] array) {\n    int d = array.length;\n    while (d > 1) {\n        d /= 2;\n        for (int i = 0; i < d; i++) {\n            for (int j = i + d; j < array.length; j += d) {\n                int insertValue = array[j];\n                int k = j - d;\n                while (k >= 0 && array[k] > insertValue) {\n                    array[k + d] = array[k];\n                    k -= d;\n                }\n                array[k + d] = insertValue;\n            }\n        }\n    }\n\n}\n```\n\n# 归并排序\n\n## 算法思想\n\n归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。\n\n作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：\n\n- 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；\n- 自下而上的迭代；\n\n## 算法步骤\n\n1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n4. 重复步骤 3 直到某一指针达到序列尾；\n5. 将另一序列剩下的所有元素直接复制到合并序列尾。\n\n## 代码实现\n\n```Java\npublic static void mergeSort(int[] array, int start, int end) {\n    if (start >= end) {\n        return;\n    }\n    int mid = (start + end) / 2;\n    mergeSort(array, start, mid);\n    mergeSort(array, mid + 1, end);\n    merge(array, start, mid, end);\n}\n\npublic static void merge(int[] array, int start, int mid, int end) {\n    int[] result = new int[end - start + 1];\n    int index = 0;\n    int p1 = start;\n    int p2 = mid + 1;\n    while (p1 <= mid && p2 <= end) {\n        if (array[p1] < array[p2]) {\n            result[index++] = array[p1++];\n        } else {\n            result[index++] = array[p2++];\n        }\n    }\n    while (p1 <= mid) {\n        result[index++] = array[p1++];\n    }\n    while (p2 <= end) {\n        result[index++] = array[p2++];\n    }\n    for (int i = 0; i < result.length; i++) {\n        array[start + i] = result[i];\n    }\n}\n```\n\n# 快速排序\n\n## 算法思想\n\n快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n²) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。\n\n快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。\n\n快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。\n\n## 算法步骤\n\n1. 从数列中挑出一个元素，称为 \"基准\"（pivot）;\n2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n\n## 代码实现\n\n### 双边循环法\n\n```Java\n/**\n * 快速排序，双边循环法\n *\n * @param array\n * @param startIndex\n * @param endIndex\n */\npublic static void sort1(int[] array, int startIndex, int endIndex) {\n    if (startIndex >= endIndex) {\n        return;\n    }\n    int left = startIndex;\n    int right = endIndex;\n    while (left < right) {\n        while (array[right] >= array[startIndex] && left < right) {\n            right--;\n        }\n        while (array[left] <= array[startIndex] && left < right) {\n            left++;\n        }\n        int temp = array[left];\n        array[left] = array[right];\n        array[right] = temp;\n    }\n    //交换标记位置\n    int temp = array[startIndex];\n    array[startIndex] = array[left];\n    array[left] = temp;\n    sort1(array, startIndex, left - 1);\n    sort1(array, left + 1, endIndex);\n}\n```\n\n### 单边循环法\n\n```Java\n/**\n * 快速排序，单边循环法\n *\n * @param array\n * @param startIndex\n * @param endIndex\n */\npublic static void sort2(int[] array, int startIndex, int endIndex) {\n    if (startIndex >= endIndex) {\n        return;\n    }\n    int mark = startIndex;\n    for (int i = startIndex + 1; i <= endIndex; i++) {\n        if (array[i] < array[startIndex]) {\n            mark++;\n            int temp = array[i];\n            array[i] = array[mark];\n            array[mark] = temp;\n        }\n    }\n    int temp = array[startIndex];\n    array[startIndex] = array[mark];\n    array[mark] = temp;\n    sort1(array, startIndex, mark - 1);\n    sort1(array, mark + 1, endIndex);\n}\n```\n\n### 非递归版本\n\n```Java\n/**\n * 非递归快速排序\n *\n * @param array\n * @param startIndex\n * @param endIndex\n */\npublic static void sort3(int[] array, int startIndex, int endIndex) {\n    Stack<HashMap<String, Integer>> stack = new Stack<>();\n    HashMap<String, Integer> map = new HashMap<>(2);\n    map.put(\"startIndex\", startIndex);\n    map.put(\"endIndex\", endIndex);\n    stack.push(map);\n    while (!stack.isEmpty()) {\n        HashMap<String, Integer> pop = stack.pop();\n        Integer s = pop.get(\"startIndex\");\n        Integer e = pop.get(\"endIndex\");\n        if (s >= e) {\n            continue;\n        }\n        int mark = s;\n        for (int i = s + 1; i <= e; i++) {\n            if (array[i] < array[s]) {\n                mark++;\n                int temp = array[i];\n                array[i] = array[mark];\n                array[mark] = temp;\n            }\n        }\n        int temp = array[s];\n        array[s] = array[mark];\n        array[mark] = temp;\n        HashMap<String, Integer> m1 = new HashMap<>(2);\n        HashMap<String, Integer> m2 = new HashMap<>(2);\n        m1.put(\"startIndex\", s);\n        m1.put(\"endIndex\", mark - 1);\n        m2.put(\"startIndex\", mark + 1);\n        m2.put(\"endIndex\", e);\n        stack.push(m1);\n        stack.push(m2);\n    }\n\n}\n```\n\n# 堆排序\n\n## 算法思想\n\n堆排序（HeapSort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：\n\n1. 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；\n2. 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；\n\n堆排序的平均时间复杂度为 Ο(nlogn)。\n\n## 算法步骤\n\n1. 创建一个堆 H[0……n-1]；\n2. 把堆首（最大值）和堆尾互换；\n3. 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；\n4. 重复步骤 2，直到堆的尺寸为 1。\n\n## 代码实现\n\n```Java\npublic static void downAdjust(int[] array, int parentIndex, int length) {\n    int childIndex = parentIndex * 2 + 1;\n    int temp = array[parentIndex];\n    while (childIndex < length) {\n        if (childIndex + 1 < length && array[childIndex + 1] < array[childIndex]) {\n            childIndex++;\n        }\n        if (temp <= array[childIndex]) {\n            break;\n        }\n        array[parentIndex] = array[childIndex];\n        parentIndex = childIndex;\n        childIndex = childIndex * 2 + 1;\n    }\n    array[parentIndex] = temp;\n}\n\npublic static void heapSort(int[] array) {\n    //构建小顶堆\n    for (int i = (array.length - 2) / 2; i >= 0; i--) {\n        downAdjust(array, i, array.length);\n    }\n    for (int i = array.length - 1; i > 0; i--) {\n        int temp = array[0];\n        array[0] = array[i];\n        array[i] = temp;\n        downAdjust(array, 0, i);\n    }\n\n}\n```\n\n# 计数排序\n\n## 算法思想\n\n计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\n\n当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。\n\n由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。\n\n## 算法步骤\n\n1. 找出待排序的数组中最大和最小的元素\n2. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项\n3. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）\n4. 反向填充目标数组将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1\n\n## 代码实现\n\n### 原始版本\n\n```Java\n/**\n * 原始计数排序\n *\n * @param array\n * @return\n */\npublic static int[] sort1(int[] array) {\n    //判空\n    if (array == null || array.length == 0) {\n        return array;\n    }\n    //得到数列最大值\n    int max = array[0];\n    for (int k : array) {\n        if (max < k) {\n            max = k;\n        }\n    }\n    //统计出现次数\n    int[] countSort = new int[max + 1];\n    for (int k : array) {\n        countSort[k]++;\n    }\n    int index = 0;\n    int[] result = new int[array.length];\n    //构造结果数组\n    for (int i = 0; i < countSort.length; i++) {\n        for (int j = 0; j < countSort[i]; j++) {\n            result[index++] = i;\n        }\n    }\n    return result;\n}\n```\n\n### 稳定版本\n\n```Java\n/**\n * 优化版本计数排序（数组长度，稳定）\n *\n * @param array\n * @return\n */\npublic static int[] sort2(int[] array) {\n    //判空\n    if (array == null || array.length == 0) {\n        return array;\n    }\n    //找出最大最小值\n    int max = array[0];\n    int min = array[0];\n    for (int v : array) {\n        if (max < v) {\n            max = v;\n        }\n        if (min > v) {\n            min = v;\n        }\n    }\n    //创建统计数组\n    int[] countArray = new int[max - min + 1];\n    for (int v : array) {\n        countArray[v - min]++;\n    }\n    //统计数组变形\n    for (int i = 1; i < countArray.length; i++) {\n        countArray[i] += countArray[i - 1];\n    }\n    int[] result = new int[array.length];\n    //倒序遍历原始数组\n    for (int i = array.length - 1; i >= 0; i--) {\n        result[countArray[array[i] - min] - 1] = array[i];\n        countArray[array[i] - min]--;\n    }\n    return result;\n}\n```\n\n# 桶排序\n\n## 算法思想\n\n桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：\n\n1. 在额外空间充足的情况下，尽量增大桶的数量\n2. 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中\n\n同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。\n\n## 算法步骤\n\n1. 划分桶，将元素加入桶中\n2. 将每个桶内的元素排序\n3. 按顺序取出元素\n\n## 代码实现\n\n```Java\npublic static double[] sort(double[] array) {\n    //判空\n    if (array == null || array.length == 0) {\n        return array;\n    }\n    //找出最大最小值\n    double max = array[0];\n    double min = array[0];\n    for (double value : array) {\n        if (max < value) {\n            max = value;\n        }\n        if (min > value) {\n            min = value;\n        }\n    }\n    //初始化桶\n    double d = max - min;\n    int bucketNum = array.length;\n    ArrayList<LinkedList<Double>> bucketList = new ArrayList<>(bucketNum);\n    for (int i = 0; i < bucketNum; i++) {\n        bucketList.add(new LinkedList<>());\n    }\n\n    //将元素加入桶\n    for (double v : array) {\n        int num = (int) ((v - min) * (bucketNum - 1) / d);\n        bucketList.get(num).add(v);\n    }\n\n    //对每个桶内元素进行排序\n    for (LinkedList<Double> doubleLinkedList : bucketList) {\n        Collections.sort(doubleLinkedList);\n    }\n\n    //输出结果\n    int index = 0;\n    double[] result = new double[array.length];\n    for (LinkedList<Double> doubles : bucketList) {\n        for (Double aDouble : doubles) {\n            result[index++] = aDouble;\n        }\n    }\n    return result;\n}\n```\n\n# 基数排序\n\n## 算法思想\n\n基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n\n**基数排序 vs 计数排序 vs 桶排序**\n\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\n\n- 基数排序：根据键值的每位数字来分配桶；\n- 计数排序：每个桶只存储单一键值；\n- 桶排序：每个桶存储一定范围的数值；\n\n## 算法步骤\n\n1. 根据不同位进行计数排序\n2. 汇总排序元素\n\n## 代码实现\n\n```Java\n/**\n * @Title\n * @Description\n * @Author WolfMan\n * @Date 2021/12/5 21:11\n * @Email 2370032534@qq.com\n */\npublic class Main {\n\n    public static final int ASCII_RANGE = 128;\n\n    public static void main(String[] args) {\n        String[] array = {\"qd\", \"abc\", \"qwe\", \"hhh\", \"a\", \"cws\", \"ope\"};\n        System.out.println(Arrays.toString(radixSort(array, 3)));\n    }\n\n    public static String[] radixSort(String[] array, int maxLength) {\n        String[] sortedArray = new String[array.length];\n        for (int k = maxLength - 1; k >= 0; k--) {\n            //计数排序\n            int[] count = new int[ASCII_RANGE];\n            for (int i = 0; i < array.length; i++) {\n                count[getCharIndex(array[i], k)]++;\n            }\n            //计数排序变形\n            for (int i = 1; i < count.length; i++) {\n                count[i] += count[i - 1];\n            }\n            for (int i = array.length - 1; i >= 0; i--) {\n                int index = getCharIndex(array[i], k);\n                sortedArray[count[index] - 1] = array[i];\n                count[index]--;\n            }\n            array = sortedArray.clone();\n        }\n        return array;\n    }\n\n    public static int getCharIndex(String str, int k) {\n        if (str.length() < (k + 1)) {\n            return 0;\n        }\n        return str.charAt(k);\n    }\n}\n```\n\n参考文章：\n\n- [十大经典排序算法](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)\n- [漫画算法](https://blog.csdn.net/bjweimengshu/article/details/99669921)\n","tags":["排序算法"],"categories":["算法学习"]},{"title":"二叉树的遍历","url":"/2023/04/04/二叉树的遍历.html","content":"\n二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点最多有2个孩子节点。注意，这里是最多有2个，也可能只有1个，或者没有孩子节点。\n\n代码定义：\n\n```Java\n/**\n * 二叉树\n */\nprivate static class TreeNode {\n    int data;\n    TreeNode leftChild;\n    TreeNode rightChild;\n\n    public TreeNode(int data) {\n        this.data = data;\n    }\n}\n```\n\n# 深度优先遍历\n\n## 递归遍历\n\n### 前序遍历\n\n二叉树的前序遍历，输出顺序是根节点、左子树、右子树。\n\n```Java\n/**\n * 前序遍历\n *\n * @param root\n */\npublic static void preOrderTraversal(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    System.out.print(root.data + \" \");\n    preOrderTraversal(root.leftChild);\n    preOrderTraversal(root.rightChild);\n}\n```\n\n### 中序遍历\n\n二叉树的中序遍历，输出顺序是左子树、根节点、右子树。\n\n```Java\n/**\n * 中序遍历\n *\n * @param root\n */\npublic static void inOrderTraversal(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    inOrderTraversal(root.leftChild);\n    System.out.print(root.data + \" \");\n    inOrderTraversal(root.rightChild);\n}\n```\n\n### 后序遍历\n\n二叉树的后序遍历，输出顺序是左子树、右子树、根节点。\n\n```Java\n/**\n * 后序遍历\n *\n * @param root\n */\npublic static void postOrderTraversal(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    postOrderTraversal(root.leftChild);\n    postOrderTraversal(root.rightChild);\n    System.out.print(root.data + \" \");\n}\n```\n\n## 辅助栈遍历\n\n其实二叉树遍历这里，辅助栈遍历才是重点！！！\n\n### 前序遍历\n\n```Java\n/**\n * 辅助栈前序遍历\n *\n * @param root\n */\npublic static void preOrderTraversalWithStack(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode p = root;\n    while (p != null || !stack.isEmpty()) {\n        while (p != null) {\n            System.out.print(p.data + \" \");\n            stack.push(p);\n            p = p.leftChild;\n        }\n        if (!stack.isEmpty()) {\n            p = stack.pop();\n            p = p.rightChild;\n        }\n    }\n}\n```\n\n### 中序遍历\n\n```Java\n/**\n * 辅助栈中序遍历\n *\n * @param root\n */\npublic static void inOrderTraversalWithStack(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode p = root;\n    while (p != null || !stack.isEmpty()) {\n        while (p != null) {\n            stack.push(p);\n            p = p.leftChild;\n        }\n        if (!stack.isEmpty()) {\n            p = stack.pop();\n            System.out.print(p.data + \" \");\n            p = p.rightChild;\n        }\n    }\n}\n```\n\n### 后序遍历\n\n辅助栈后序遍历难点在于遍历时需要判断当前节点是否属于右子树。\n\n```Java\n/**\n * 辅助栈后序遍历\n *\n * @param root\n */\npublic static void postOrderTraversalWithStack(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode p = root;\n    TreeNode pre = null;\n    while (p != null || !stack.isEmpty()) {\n        while (p != null) {\n            stack.push(p);\n            p = p.leftChild;\n        }\n        p = stack.peek();\n        if (p.rightChild == null || p.rightChild == pre) {\n            stack.pop();\n            System.out.print(p.data);\n            pre = p;\n            p = null;\n        } else {\n            p = p.rightChild;\n        }\n    }\n}\n```\n\n## Morris算法\n\n### 算法介绍\n\nMorris算法充分利用了二叉树叶子节点下的空间，从而可以在时间复杂度为O(N)，**空间复杂度为O(1)** 的条件下，前中后序遍历二叉树(不是完全二叉树也可以使用)。\n\n而常见的遍历二叉树的方法为递归和栈迭代，这两种方法的时间复杂度虽然也为O(N),但是空间复杂度需要O(N),因此Morris算法可以极大节省空间。\n\n### 前序遍历\n\n#### 算法步骤\n\n1. 如果当前节点的左子节点为空时，**输出当前节点**，并将当前节点置为该节点的右子节点；\n2. 如果当前节点的左子节点不为空，找到当前节点左子树的最右节点（该节点为当前节点中序遍历的前驱节点）；\n3. 如果最右节点的右指针为空(right=null)，将最右节点的右指针指向当前节点，**并输出当前节点（在此处输出）**，当前节点置为其左子节点；\n4. 如果最右节点的右指针不为空，将最右节点右指针重新置为空(恢复树的原状)，并将当前节点置为其右节点；\n5. 重复1~2，直到当前节点为空。\n\n#### 图片演示\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/1.png)\n\n#### 代码实现\n\n```Java\n/**\n * Morris算法前序遍历\n *\n * @param root\n */\npublic static void preOrderTraversalWithMorris(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    TreeNode cur = root;\n    while (cur != null) {\n        if (cur.leftChild == null) {\n            System.out.print(cur.data + \" \");\n            cur = cur.rightChild;\n        } else {\n            TreeNode t = cur.leftChild;\n            while (t.rightChild != null && t.rightChild != cur) {\n                t = t.rightChild;\n            }\n            if (t.rightChild == null) {\n                System.out.print(cur.data + \" \");\n                t.rightChild = cur;\n                cur = cur.leftChild;\n            } else {\n                t.rightChild = null;\n                cur = cur.rightChild;\n            }\n        }\n    }\n\n}\n```\n\n### 中序遍历\n\n#### 算法步骤\n\n1. 如果当前节点的左子节点为空时，**输出当前节点**，并将当前节点置为该节点的右子节点；\n2. 如果当前节点的左子节点不为空，找到当前节点左子树的最右节点（该节点为当前节点中序遍历的前驱节点）；\n3. 如果最右节点的右指针为空(right=null)，将最右节点的右指针指向当前节点，当前节点置为其左子节点；\n4. 如果最右节点的右指针不为空，将最右节点右指针重新置为空(恢复树的原状)，**输出当前节点**，并将当前节点置为其右节点；\n5. 重复1~2，直到当前节点为空。\n\n#### 图片演示\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/2.png)\n\n#### 代码实现\n\n```Java\n/**\n * Morris算法中序遍历\n *\n * @param root\n */\npublic static void inOrderTraversalWithMorris(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    TreeNode cur = root;\n    while (cur != null) {\n        if (cur.leftChild == null) {\n            System.out.print(cur.data + \" \");\n            cur = cur.rightChild;\n        } else {\n            TreeNode t = cur.leftChild;\n            while (t.rightChild != null && t.rightChild != cur) {\n                t = t.rightChild;\n            }\n            if (t.rightChild == null) {\n                t.rightChild = cur;\n                cur = cur.leftChild;\n            } else {\n                t.rightChild = null;\n                System.out.print(cur.data + \" \");\n                cur = cur.rightChild;\n            }\n        }\n    }\n\n}\n```\n\n### 后序遍历\n\n后序遍历较前两者比较麻烦，**需要建立一个临时节点，并令该节点的左子节点为root**，并且需要一个子过程，倒序输出某两个节点之间路径上的各个节点。\n\n> morris后序遍历严格意义上来说空间复杂度不为O(1)。\n\n#### 算法步骤\n\n1. 如果当前节点的左子节点为空时，则将其右子节点作为当前节点；\n2. 如果当前节点的左子节点不为空，找到当前节点左子树的最右节点（该节点为当前节点中序遍历的前驱节点）；\n3. 如果最右节点的右指针为空(right=null)，将最右节点的右指针指向当前节点，当前节点置为其左子节点；\n4. 如果最右节点的右指针不为空，将最右节点右指针重新置为空(恢复树的原状)，倒序输出从当前节点的左子节点到该最右节点路径上的所有节点，并将当前节点置为其右节点；\n5. 重复1~2，直到当前节点为空。\n\n#### 图片演示\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/3.png)\n\n#### 代码实现\n\n```Java\n/**\n * Morris算法后序遍历\n *\n * @param root\n */\npublic static void postOrderTraversalWithMorris(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    TreeNode virNode = new TreeNode(-1);\n    virNode.leftChild = root;\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode cur = virNode;\n    while (cur != null) {\n        if (cur.leftChild == null) {\n            cur = cur.rightChild;\n        } else {\n            TreeNode tmp = cur.leftChild;\n            while (tmp.rightChild != null && tmp.rightChild != cur) {\n                tmp = tmp.rightChild;\n            }\n            if (tmp.rightChild == null) {\n                tmp.rightChild = cur;\n                cur = cur.leftChild;\n            } else {\n                tmp.rightChild = null;\n                TreeNode t = cur.leftChild;\n                while (t != null) {\n                    stack.push(t);\n                    t = t.rightChild;\n                }\n                while (!stack.isEmpty()) {\n                    System.out.print(stack.pop().data + \" \");\n                }\n                cur = cur.rightChild;\n            }\n        }\n    }\n}\n```\n\n# 广度优先遍历\n\n广度优先遍历使用队列将其子节点加入队列即可。\n\n```Java\n/***\n * 广度优先遍历\n * @param root\n */\npublic static void bfs(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    LinkedList<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    while (!queue.isEmpty()) {\n        TreeNode r = queue.poll();\n        System.out.println(r.data);\n        if (r.leftChild != null) {\n            queue.offer(r.leftChild);\n        }\n        if (r.rightChild != null) {\n            queue.offer(r.rightChild);\n        }\n    }\n}\n```\n\n参考文章：\n\n- [漫画算法2](https://baike.baidu.com/item/漫画算法2：小灰的算法进阶/57152551?fr=aladdin)\n- [二叉树三种非递归遍历以及代码实现](https://blog.csdn.net/qq_45665172/article/details/109602935)\n- [Morris算法进行二叉树遍历](https://blog.csdn.net/yangfeisc/article/details/45673947)\n","tags":["二叉树"],"categories":["数据结构"]},{"title":"二叉查找树","url":"/2023/04/03/二叉查找树.html","content":"\n# 二叉查找树\n\n## 定义\n\n二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称[二叉搜索树](https://baike.baidu.com/item/二叉搜索树/7077855)。是[数据结构](https://baike.baidu.com/item/数据结构/1450)中的一类。在一般情况下，查询效率比链表结构要高。\n\n一棵空树，或者是具有下列性质的[二叉树](https://baike.baidu.com/item/二叉树)：\n\n（1）若左子树不空，则左子树上所有[结点](https://baike.baidu.com/item/结点/9794643)的值均小于它的[根结点](https://baike.baidu.com/item/根结点/9795570)的值；\n\n（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n\n（3）左、右子树也分别为二叉排序树；\n\n（4）没有[键值](https://baike.baidu.com/item/键值/10086175)相等的结点。\n\n二叉查找树的中序遍历按照升序进行排序。\n\n定义节点类：\n\n```Java\n/**\n * 结点类\n */\nprivate class Node {\n    int data;\n    Node right;\n    Node left;\n\n    Node(int data) {\n        this.data = data;\n    }\n}\n```\n\n## 查找\n\n```Java\n/**\n * 查找结点\n *\n * @param data\n * @return\n */\npublic Node search(int data) {\n    Node r = root;\n    while (r != null) {\n        if (r.data == data) {\n            System.out.println(\"找到该节点\");\n            return r;\n        } else if (r.data > data) {\n            r = r.left;\n        } else {\n            r = r.right;\n        }\n    }\n    System.out.println(\"未找到该节点\");\n    return null;\n}\n```\n\n## 插入\n\n```Java\n/**\n * 插入结点\n *\n * @param data\n * @return\n */\npublic boolean insert(int data) {\n    Node targetNode = new Node(data);\n    if (root == null) {\n        root = targetNode;\n        return true;\n    }\n    Node r = root;\n    Node t = r;\n    while (r != null) {\n        t = r;\n        if (r.data == data) {\n            System.out.println(\"二叉查找树中已存在此节点！\");\n            return false;\n        } else if (r.data > data) {\n            r = r.left;\n        } else {\n            r = r.right;\n        }\n    }\n    if (t.data > data) {\n        t.left = targetNode;\n    } else {\n        t.right = targetNode;\n    }\n    return true;\n}\n```\n\n## 删除\n\n删除二叉查找树中，值得注意的是，当目标节点有两个子节点时，可以选择左子树最大的节点代替，或者选择右子树最小的节点来代替，以保证二叉查找树的性质，这里选择右子树最小的节点代替。需要注意当目标节点的右子树没有左子树的情况。\n\n```Java\n/**\n * 删除结点\n *\n * @param data\n * @return\n */\npublic boolean delete(int data) {\n    //判断该节点是否存在\n    Node targetNode = root;\n    Node parentNode = new Node(data);\n    //判断待删除结点是否存在\n    while (targetNode.data != data) {\n        parentNode = targetNode;\n        if (data > targetNode.data) {\n            targetNode = targetNode.right;\n        } else {\n            targetNode = targetNode.left;\n        }\n        if (targetNode == null) {\n            // 没有找到待删除结点\n            return false;\n        }\n    }\n    //待删除结点没有子节点\n    if (targetNode.left == null && targetNode.right == null) {\n        if (targetNode == root) {\n            root = null;\n            return true;\n        } else {\n            if (parentNode.left == targetNode) {\n                parentNode.left = null;\n            } else {\n                parentNode.right = null;\n            }\n        }\n    }\n    //待删除结点有一个子结点（右）\n    else if (targetNode.left == null) {\n        if (targetNode == root) {\n            root = root.right;\n        } else {\n            if (parentNode.left == targetNode) {\n                parentNode.left = targetNode.right;\n            } else {\n                parentNode.right = targetNode.right;\n            }\n        }\n    }\n    //待删除结点有一个子结点（左）\n    else if (targetNode.right == null) {\n        if (targetNode == root) {\n            root = root.left;\n        } else {\n            if (parentNode.left == targetNode) {\n                parentNode.left = targetNode.left;\n            } else {\n                parentNode.right = targetNode.left;\n            }\n        }\n    }\n    //待删除结点有两个子结点\n    else {\n        //待删除结点的后继结点的父结点\n        Node successParentNode = targetNode;\n        //待删除结点的后继结点\n        Node successNode = targetNode.right;\n        while (successNode.left != null) {\n            successParentNode = successNode;\n            successNode = successNode.left;\n        }\n        //把后继结点复制到待删除结点位置\n        targetNode.data = successNode.data;\n        //删除后继结点\n        if (successParentNode.right == successNode) {\n            successParentNode.right = successNode.right;\n        } else {\n            successParentNode.left = successNode.right;\n        }\n    }\n    //待删除结点有两个子结点\n    return true;\n}\n```\n\n参考文章：\n\n- [百度百科](https://baike.baidu.com/)\n- [漫画算法2](https://baike.baidu.com/item/漫画算法2：小灰的算法进阶/57152551?fr=aladdin)","tags":["二叉树"],"categories":["数据结构"]},{"title":"驾驶证科目一扣分规则记忆技巧","url":"/2023/03/24/驾驶证科目一扣分规则记忆技巧.html","content":"\n# 扣分规则详情\n\n《道路交通安全违法行为记分管理办法》规定，机动车驾驶人有下列交通违法行为之一\n\n一次**记1分**：\n\n1. 驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路以外的道路上行驶超过规定时速百分之十以上未达到百分之二十的；\n2. 驾驶机动车不按规定会车，或者在高速公路、城市快速路**以外**的道路上不按规定倒车、掉头的；\n3. 驾驶机动车不按规定使用灯光的；\n4. 驾驶机动车违反禁令标志、禁止标线指示的；\n5. 驾驶机动车载货长度、宽度、高度超过规定的；\n6. 驾驶载货汽车载物超过最大允许总质量未达到百分之三十的；\n7. 驾驶未按规定定期进行安全技术检验的公路客运汽车、旅游客运汽车、危险物品运输车辆**以外**的机动车上道路行驶的；\n8. 驾驶擅自改变已登记的结构、构造或者特征的载货汽车上道路行驶的；\n9. 驾驶机动车在道路上行驶时，机动车驾驶人未按规定系安全带的；\n10. 驾驶摩托车，不戴安全头盔的。\n\n一次**记3分**：\n\n1. 驾驶校车、公路客运汽车、旅游客运汽车、7座以上载客汽车以外的其他载客汽车载人超过核定人数百分之二十以上未达到百分之五十的；\n2. 驾驶校车、中型以上载客载货汽车、危险物品运输车辆以外的机动车在高速公路、城市快速路以外的道路上行驶超过规定时速百分之二十以上未达到百分之五十的；\n3. 驾驶机动车在高速公路或者城市快速路上**不按规定车道行驶**的；\n4. 驾驶机动车不按规定超车、让行，或者在高速公路、城市快速路以外的道路上**逆行**的；\n5. 驾驶机动车遇前方机动车停车排队或者缓慢行驶时，借道超车或者占用对面车道、穿插等候车辆的；\n6. 驾驶机动车有拨打、接听手持电话等妨碍安全驾驶的行为的；\n7. 驾驶机动车行经人行横道**不按规定减速、停车、避让行人**的；\n8. 驾驶机动车**不按规定避让校车**的；\n9. 驾驶载货汽车载物超过最大允许总质量百分之三十以上未达到百分之五十的，或者**违反规定载客**的；\n10. 驾驶**不按规定安装机动车号牌**的机动车上道路行驶的；\n11. 在道路上车辆发生故障、事故停车后，不按规定使用灯光或者设置警告标志的；\n12. 驾驶未按规定定期进行安全技术检验的公路客运汽车、旅游客运汽车、危险物品运输车辆上道路行驶的；\n13. 驾驶校车上道路行驶前，未对校车车况是否符合安全技术要求进行检查，或者驾驶存在安全隐患的校车上道路行驶的；\n14. 连续驾驶载货汽车超过4小时未停车休息或者停车休息时间少于20分钟的；\n15. 驾驶机动车**在高速公路上行驶低于规定最低时速**的。\n\n一次**记6分**：\n\n1. 驾驶校车、公路客运汽车、旅游客运汽车载人超过核定人数未达到百分之二十，或者驾驶7座以上载客汽车载人超过核定人数百分之二十以上未达到百分之五十，或者驾驶其他载客汽车载人超过核定人数百分之五十以上未达到百分之百的；\n2. 驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路上行驶超过规定时速未达到百分之二十，或者在高速公路、城市快速路以外的道路上行驶超过规定时速百分之二十以上未达到百分之五十的；\n3. 驾驶校车、中型以上载客载货汽车、危险物品运输车辆以外的机动车在高速公路、城市快速路上行驶超过规定时速百分之二十以上未达到百分之五十，或者在高速公路、城市快速路以外的道路上行驶超过规定时速百分之五十以上的；\n4. 驾驶载货汽车载物超过最大允许总质量百分之五十以上的；\n5. 驾驶机动车载运爆炸物品、易燃易爆化学物品以及剧毒、放射性等危险物品，未按指定的时间、路线、速度行驶或者未悬挂警示标志并采取必要的安全措施的；\n6. 驾驶机动车运载超限的不可解体的物品，未按指定的时间、路线、速度行驶或者未悬挂警示标志的；\n7. 驾驶机动车运输危险化学品，未经批准进入危险化学品运输车辆限制通行的区域的；\n8. 驾驶机动车**不按交通信号灯指示通行**的；\n9. **机动车驾驶证被暂扣或者扣留期间**驾驶机动车的；\n10. 造成致人轻微伤或者财产损失的交通事故后逃逸，尚不构成犯罪的；\n11. 驾驶机动车在高速公路或者城市快速路上**违法占用应急车道**行驶的。\n\n一次**记9分**：\n\n1. 驾驶7座以上载客汽车载人超过核定人数百分之五十以上未达到百分之百的；\n2. 驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路以外的道路上行驶超过规定时速百分之五十以上的；\n3. 驾驶机动车在高速公路或者城市快速路上**违法停车**的；\n4. 驾驶未悬挂机动车号牌或者**故意遮挡、污损**机动车号牌的机动车上道路行驶的；\n5. **驾驶与准驾车型不符**的机动车的；\n6. 未取得校车驾驶资格驾驶校车的；\n7. 连续驾驶中型以上载客汽车、危险物品运输车辆超过4小时未停车休息或者停车休息时间少于20分钟的。\n\n一次**记12分**：\n\n1. 饮酒后驾驶机动车的；\n2. 造成致人轻伤以上或者死亡的交通事故后逃逸，尚不构成犯罪的；\n3. 使用**伪造、变造**的机动车号牌、行驶证、驾驶证、校车标牌或者使用其他机动车号牌、行驶证的；\n4. 驾驶校车、公路客运汽车、旅游客运汽车载人超过核定人数百分之二十以上，或者驾驶其他载客汽车载人超过核定人数百分之百以上的；\n5. 驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路上行驶超过规定时速百分之二十以上，或者驾驶其他机动车在高速公路、城市快速路上行驶超过规定时速百分之五十以上的；\n6. 驾驶机动车在高速公路、城市快速路上**倒车、逆行、穿越中央分隔带掉头**的；\n7. 代替实际机动车驾驶人接受交通违法行为处罚和记分牟取经济利益的。\n\n# 超速扣分规则\n\n| 校车、中型以上载客载货汽车、危险物品运输车辆 | 高速公路、城市快速路 | 速度    | 扣分 |\n| :------------------------------------------- | :------------------- | :------ | :--- |\n| 是                                           | 是                   | <20%    | 6    |\n| 是                                           | 是                   | >20%    | 12   |\n| 是                                           | 否                   | 10%~20% | 1    |\n| 是                                           | 否                   | 20%~50% | 6    |\n| 是                                           | 否                   | >50%    | 9    |\n| 否                                           | 否                   | 20%~50% | 3    |\n| 否                                           | 否                   | >50%    | 6    |\n| 否                                           | 是                   | 20%~50% | 6    |\n| 否                                           | 是                   | >50%    | 12   |\n\n# 超载扣分规则\n\n## 载人\n\n| 驾驶校车、公路客运汽车、旅游客运汽车 | 7座以上载客汽车 | 载人     | 扣分 |\n| :----------------------------------- | :-------------- | :------- | :--- |\n| 是                                   | 否              | <20%     | 6    |\n| 是                                   | 否              | >20%     | 12   |\n| 否                                   | 否              | 20%~50%  | 3    |\n| 否                                   | 否              | >50%     | 6    |\n| 否                                   | 是or否          | >100%    | 12   |\n| 否                                   | 是              | 20%~50%  | 6    |\n| 否                                   | 是              | 50%~100% | 9    |\n\n## 载物\n\n| 载货汽车 | 载物    | 扣分 |\n| :------- | :------ | :--- |\n| 是       | <30%    | 1    |\n| 是       | 30%~50% | 3    |\n| 是       | >50%    | 6    |\n","tags":["驾驶证考试"]},{"title":"简易版即时通讯系统","url":"/2023/03/24/简易版即时通讯系统.html","content":"\n# 写在前面\n\n之前了解了即时通讯设计的基本方案，感觉蛮有意思，但一直没有实现；这两天参照网上的教程实现了一些小功能，**此项目未经严格测试，仅供娱乐，切勿当真！**。\n\n# 技术架构\n\n主要技术：vue+springboot+mybatis-plus\n\n网上教程是前后端不分离项目，我还是想做前后端分离的，之后可以考虑集成到其他项目中去。\n\n# 交互设计\n\n## 数据库设计\n\n**用户表：**\n\n记录用户基本信息，这里给出必要的几个字段即可\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%AE%80%E6%98%93%E7%89%88%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/5.png)\n\n**消息表：**\n\n主要用于记录用户之间发送的消息，其中包括，发送者id，接收者id，发送内容等\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%AE%80%E6%98%93%E7%89%88%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/2.png)\n\n## 接口设计\n\n因为即时通讯系统需要前后端互相配合，因此接口的设计和传输对象的设计比较重要，这里给出po和vo的设计\n\n**持久化对象：**\n\n1. 用户对象\n\n```Java\npackage com.wolfman.wolfchat.po;\n\nimport com.baomidou.mybatisplus.annotation.IdType;\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.baomidou.mybatisplus.extension.activerecord.Model;\nimport lombok.Data;\nimport lombok.EqualsAndHashCode;\n\n/**\n * @Title\n * @Description\n * @Author WolfMan\n * @Date 2022/1/14 12:54\n * @Email 2370032534@qq.com\n */\n@Data\n@TableName(\"user\")\n@EqualsAndHashCode(callSuper = true)\npublic class User extends Model<User> {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * 主键id\n     */\n    @TableId(value = \"id\", type = IdType.AUTO)\n    private Integer id;\n    /**\n     * 用户名\n     */\n    private String username;\n    /**\n     * 密码\n     */\n    private String password;\n    /**\n     * 头像\n     */\n    private String avatar;\n}\n```\n\n1. 消息对象\n\n```Java\npackage com.wolfman.wolfchat.po;\n\nimport com.baomidou.mybatisplus.annotation.IdType;\nimport com.baomidou.mybatisplus.annotation.TableField;\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.baomidou.mybatisplus.extension.activerecord.Model;\nimport lombok.Data;\nimport lombok.EqualsAndHashCode;\n\nimport java.util.Date;\n\n/**\n * @Title\n * @Description\n * @Author WolfMan\n * @Date 2022/1/15 0:41\n * @Email 2370032534@qq.com\n */\n@Data\n@TableName(\"message\")\n@EqualsAndHashCode(callSuper = true)\npublic class Message extends Model<Message> {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * 主键id\n     */\n    @TableId(value = \"id\", type = IdType.AUTO)\n    private Integer id;\n\n    /**\n     * 发送者id\n     */\n    @TableField(\"fromUserId\")\n    private Integer fromUserId;\n    /**\n     * 接收者id\n     */\n    @TableField(\"toUserId\")\n    private Integer toUserId;\n    /**\n     * 发送内容\n     */\n    private String message;\n\n    /**\n     * 发送时间\n     */\n    @TableField(\"createTime\")\n    private Date createTime;\n\n\n    /*-------------------非持久化属性-------------------*/\n    /**\n     * 是否为系统消息\n     */\n    @TableField(exist = false)\n    private Boolean isSystem;\n\n    /**\n     * 发送者\n     */\n    @TableField(exist = false)\n    private User fromUser;\n}\n```\n\n1. **值传输对象：**\n\n```Java\npackage com.wolfman.wolfchat.vo;\n\nimport lombok.Data;\n\n/**\n * @Title\n * @Description\n * @Author WolfMan\n * @Date 2022/1/15 0:42\n * @Email 2370032534@qq.com\n */\n@Data\npublic class Result {\n\n    /**\n     * 操作是否成功\n     */\n    private boolean flag;\n    /**\n     * 信息\n     */\n    private String message;\n    /**\n     * 数据\n     */\n    private Object data;\n\n    private Result(Object data) {\n        this.flag = true;\n        this.message = \"success\";\n        this.data = data;\n    }\n\n    private Result(String message, Object data) {\n        this.flag = true;\n        this.message = message;\n        this.data = data;\n    }\n\n    private Result(String message) {\n        this.flag = false;\n        if (message == null) {\n            return;\n        }\n        this.message = message;\n    }\n\n    public static Result success(Object data) {\n        return new Result(data);\n    }\n\n    public static Result success(String message, Object data) {\n        return new Result(message, data);\n    }\n\n    public static Result error(String message) {\n        return new Result(message);\n    }\n\n    @Override\n    public String toString() {\n        return \"Result{\" +\n                \"flag=\" + flag +\n                \", message='\" + message + '\\'' +\n                \", data=\" + data +\n                '}';\n    }\n}\n```\n\n# 主要实现\n\n主要使用websocket完成，通过前后端分别实现websocket的几个关键方法，即可实现交互。关键方法有：\n\n- onOpen，当连接建立时，调用此方法\n- onMessage，当消息发送时，调用此方法\n- onClose，当连接断开时，调用此方法\n- onError，当链接错误时，调用此方法\n\n通过配合以上方法，即可实现简易的即时通讯系统。\n\n## 后台实现\n\n### 引入webSocket坐标\n\n```Java\n<!-- websocket -->\n <dependency>\n         <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-websocket</artifactId>\n</dependency>\n```\n\n### 配置webSocket\n\n```Java\npackage com.wolfman.wolfchat.config;\n\nimport com.wolfman.wolfchat.component.WebSocketServer;\nimport com.wolfman.wolfchat.service.MessageService;\nimport com.wolfman.wolfchat.service.UserService;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.socket.server.standard.ServerEndpointExporter;\n\nimport javax.annotation.Resource;\n\n/**\n * @Title\n * @Description\n * @Author WolfMan\n * @Date 2022/1/15 0:41\n * @Email 2370032534@qq.com\n */\n@Configuration\npublic class WebSocketConfig {\n\n    @Resource\n    UserService userService;\n\n    @Resource\n    MessageService messageService;\n\n    /**\n     * 注入一个ServerEndpointExporter,该Bean会自动注册使用@ServerEndpoint注解申明的websocket endpoint\n     */\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n        return new ServerEndpointExporter();\n    }\n\n    @Bean\n    public void setBeanList() {\n        WebSocketServer.userService = userService;\n        WebSocketServer.messageService = messageService;\n    }\n}\n```\n\n配置文件中除了注入了ServerEndpointExporter外，还注入了两个service，用于我们之后对消息的持久化。\n\n### 实现ServerEndpointExporter\n\n我们需要实现一个带@ServerEndpoint注解的类，之后该类会自动注入到spring容器中。主要实现为：\n\n```Java\npackage com.wolfman.wolfchat.component;\n\nimport com.alibaba.fastjson.JSON;\nimport com.wolfman.wolfchat.annotation.NeedAuthentication;\nimport com.wolfman.wolfchat.po.Message;\nimport com.wolfman.wolfchat.po.User;\nimport com.wolfman.wolfchat.service.MessageService;\nimport com.wolfman.wolfchat.service.UserService;\nimport org.springframework.stereotype.Component;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\n\n/**\n * @Title\n * @Description\n * @Author WolfMan\n * @Date 2022/1/14 14:40\n * @Email 2370032534@qq.com\n */\n@Component\n@ServerEndpoint(value = \"/wolfchat/{userId}\")\npublic class WebSocketServer {\n\n    /**\n     * 记录当前在线连接数\n     */\n    public static final Map<Integer, Session> sessionMap = new ConcurrentHashMap<>();\n\n    /**\n     * 记录当前在线用户信息\n     */\n    public static final Map<Integer, User> userMap = new ConcurrentHashMap<>();\n\n    /**\n     * 用于查询用户\n     */\n    public static UserService userService;\n\n    /**\n     * 用于持久化消息\n     */\n    public static MessageService messageService;\n\n    /**\n     * 连接建立成功调用的方法\n     *\n     * @param session\n     * @param userId\n     */\n    @OnOpen\n    @NeedAuthentication\n    public void onOpen(Session session, @PathParam(\"userId\") Integer userId) throws IOException {\n        User user = userService.selectByUserId(userId);\n        if (user == null) {\n            return;\n        }\n        //加入当前在线链接用户\n        userMap.put(userId, user);\n        sessionMap.put(userId, session);\n        // 后台发送消息给所有的客户端\n        sendMessageToAll();\n    }\n\n\n    /**\n     * 连接关闭调用的方法\n     */\n    @OnClose\n    @NeedAuthentication\n    public void onClose(@PathParam(\"userId\") Integer userId) throws IOException {\n        userMap.remove(userId);\n        sessionMap.remove(userId);\n        //推送最新在线信息\n        sendMessageToAll();\n    }\n\n    /**\n     * 收到客户端消息后调用的方法\n     *\n     * @param content\n     */\n    @OnMessage\n    @NeedAuthentication\n    public void onMessage(String content) throws IOException {\n        Message message = JSON.parseObject(content, Message.class);\n        User u = userService.selectByUserId(message.getToUserId());\n        //用户不存在\n        if (u == null) {\n            return;\n        }\n        //不是系统消息\n        message.setIsSystem(false);\n        //保存到数据库\n        message.setCreateTime(new Date());\n        messageService.save(message);\n        // 根据 to用户名来获取 session，再通过session发送消息文本\n        Session targetSession = sessionMap.get(message.getToUserId());\n        if (targetSession == null) {\n            return;\n        }\n        //重新构建消息\n        User fromUser = userMap.get(message.getFromUserId());\n        HashMap<String, Object> map = new HashMap<>(2);\n        map.put(\"fromUser\", fromUser);\n        map.put(\"message\", message.getMessage());\n        message.setMessage(JSON.toJSONString(map));\n        sendMessageToOne(message, targetSession);\n    }\n\n    /**\n     * 连接错误调用的方法\n     *\n     * @param error\n     */\n    @OnError\n    @NeedAuthentication\n    public void onError(Throwable error) {\n        error.printStackTrace();\n    }\n\n    /**\n     * 向所有用户发送信息\n     *\n     * @throws IOException\n     */\n    private void sendMessageToAll() throws IOException {\n        List<User> userList = new ArrayList<>(userMap.values());\n        Message message = new Message();\n        //是系统消息\n        message.setIsSystem(true);\n        message.setMessage(JSON.toJSONString(userList));\n        for (Session session : sessionMap.values()) {\n            sendMessageToOne(message, session);\n        }\n    }\n\n    /**\n     * 向某个用户发送信息\n     *\n     * @param message\n     * @param targetSession\n     */\n    private synchronized void sendMessageToOne(Message message, Session targetSession) throws IOException {\n        targetSession.getBasicRemote().sendText(JSON.toJSONString(message));\n    }\n\n}\n```\n\n`@ServerEndpoint(value = \"/wolfchat/{userId}\")`注解的value值，指明了之后前端需要建立连接时的链接，可附带参数变量。\n\n## 前台实现\n\n前台实现要比后台麻烦很多，需要各种判断。\n\n### 建立连接\n\n建立连接非常简单，new 一个WebSocket对象即可，参数就是目标链接：\n\n```Java\nlet socketUrl = \"ws://localhost:8888/wolfchat/\" + this.currentUser.id;\nthis.socket = new WebSocket(socketUrl);\n```\n\n接下来便是一系列的消息处理：\n\n```Java\n//打开连接\nthis.onopen();\n//接收消息\nthis.onmessage();\n//关闭连接\nthis.onclose();\n//发生错误\nthis.onerror();\n```\n\n### 消息处理\n\n以下是各个消息处理的实现：\n\n**一、onopen()**\n\n```Java\nonopen() {\n    //打开事件\n    this.socket.onopen = function () {\n        console.log(\"websocket已打开\");\n    };\n},\n```\n\n**二、onclose()**\n\n```Java\nonclose() {\n    //关闭事件\n    this.socket.onclose = function () {\n        console.log(\"websocket已关闭\");\n    };\n},\n```\n\n**三、onerror()**\n\n```Java\nonerror() {\n    //发生了错误事件\n    this.socket.onerror = function () {\n        console.log(\"websocket发生了错误\");\n    }\n},\n```\n\n**四、onmessage()**\n\n```Java\nonmessage() {\n    let _this = this;\n    //  浏览器端收消息，获得从服务端发送过来的文本消息\n    this.socket.onmessage = function (message) {\n        // 对收到的json数据进行解析\n        message = JSON.parse(message.data)\n        // 如果是系统消息\n        if (message.isSystem) {\n            // 获取当前连接的所有用户信息\n            // _this.userList = JSON.parse(message.message);\n            _this.addUserList(JSON.parse(message.message));\n        } else {\n            //更新最新消息\n            _this.updateLatestMessage(message);\n            //构建消息内容\n            message = JSON.parse(message.message)\n            // 如果是用户消息\n            if (message.fromUser.id === _this.targetUser.id) {\n                // 构建消息内容\n                _this.messageList.push(message);\n            }\n            _this.scrollToBottom();\n        }\n    };\n},\n```\n\n在此方法中，需要判断当前接收到的消息是广播消息，还是单播消息。\n\n# 效果演示\n\n一、注册界面\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%AE%80%E6%98%93%E7%89%88%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/4.png)\n\n二、登录界面\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%AE%80%E6%98%93%E7%89%88%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/3.png)\n\n三、聊天界面\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%AE%80%E6%98%93%E7%89%88%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/1.png)\n\n# 写在最后\n\n写完后读了一遍，我讲的啥玩意儿😥😥，希望谅解谅解，感谢你能看到最后，**最后附上源码，一句话——All in the code**\n\n前台代码：[简易版即时通讯系统-前台代码](https://gitee.com/lei-yongjian/wolchat-pages)\n\n后台代码：[简易版即时通讯系统-后台代码](https://gitee.com/lei-yongjian/wolfchat)\n\n参考链接：\n\n- https://www.bilibili.com/video/BV1r54y1D72U\n- https://www.bilibili.com/video/BV12Q4y1q7VP\n","tags":["websocket"]},{"title":"Nacos默认使用内网注册问题","url":"/2023/03/23/Nacos默认使用内网注册问题.html","content":"\n# 问题描述\n\n如下图所示，服务1和网关部署在服务器1上，服务2和nacos部署在服务器2上。网关调用服务1成功，调用服务2失败。报错如下：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Nacos%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%91%E6%B3%A8%E5%86%8C%E9%97%AE%E9%A2%98/1.jpg)\n\n```Java\nio.netty.channel.ConnectTimeoutException: connection timed out: /10.0.0.12:8888\n        at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$2.run(AbstractEpollChannel.java:576) ~[netty-transport-native-epoll-4.1.59.Final-linux-x86_64.jar!/:4.1.59.Final]\n        Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: \nError has been observed at the following site(s):\n        |_ checkpoint ⇢ org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter [DefaultWebFilterChain]\n        |_ checkpoint ⇢ HTTP GET \"/app/blog/selectBlogPageByViews?pageNum=1&pageSize=15\" [ExceptionHandlingWebHandler]\nStack trace:\n                at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$2.run(AbstractEpollChannel.java:576) ~[netty-transport-native-epoll-4.1.59.Final-linux-x86_64.jar!/:4.1.59.Final]\n                at io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98) ~[netty-common-4.1.59.Final.jar!/:4.1.59.Final]\n                at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:170) ~[netty-common-4.1.59.Final.jar!/:4.1.59.Final]\n                at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.59.Final.jar!/:4.1.59.Final]\n                at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.59.Final.jar!/:4.1.59.Final]\n                at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:384) ~[netty-transport-native-epoll-4.1.59.Final-linux-x86_64.jar!/:4.1.59.Final]\n                at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.59.Final.jar!/:4.1.59.Final]\n                at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.59.Final.jar!/:4.1.59.Final]\n                at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.59.Final.jar!/:4.1.59.Final]\n                at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_312]\n```\n\n# 问题排查\n\n注意报错第一行：\n\n```Java\nio.netty.channel.ConnectTimeoutException: connection timed out: /10.0.0.12:8888\n```\n\n调用ip为10.0.0.12**，**为网卡地址：\n\n```Java\neth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 10.0.0.12  netmask 255.255.252.0  broadcast 10.0.3.255\n        inet6 fe80::5054:ff:fe8d:bde  prefixlen 64  scopeid 0x20<link>\n        ether 52:54:00:8d:0b:de  txqueuelen 1000  (Ethernet)\n        RX packets 1405478  bytes 959876907 (915.4 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 1095472  bytes 217959210 (207.8 MiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Nacos%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%91%E6%B3%A8%E5%86%8C%E9%97%AE%E9%A2%98/2.png)\n\n说明nacos默认使用内网ip注册，不同内网之间不互通，因此调用失败。\n\n# 解决方式\n\n参考文档：[spring-cloud-starter-alibaba-nacos-discovery文档](https://github.com/alibaba/spring-cloud-alibaba/blob/2021.x/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example/readme-zh.md)\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/Nacos%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%91%E6%B3%A8%E5%86%8C%E9%97%AE%E9%A2%98/3.png)\n\n服务注册到Nacos时，**默认使用的是网卡地址，为内网**。服务运行在不同的服务器上，内网不互通，因此调用失败。我们可以在服务注册时，手动配置注册ip地址，填写公网即可。\n\n```YAML\nspring:\n  cloud:\n    nacos:\n      discovery:\n        ip: xxxx  # 填写公网ip\n```\n","tags":["问题排查"]},{"title":"简单权限管理模型介绍","url":"/2023/03/23/简单权限管理模型介绍.html","content":"\n# 前言\n\n风、宇个人博客的权限管理也是一个亮点，实现了接口管理与菜单管理，将前后端的权限都封装为可配置，此文简单总结一下基本使用。\n\n# 权限管理方案\n\n## 基本介绍\n\n授权是用户认证通过根据用户的权限来控制用户访问资源的过程，拥有资源的访问权限则正常访问，没有\n\n权限则拒绝访问。\n\n## 基于角色\n\nRBAC基于角色的访问控制（Role-Based Access Control）是按角色进行授权，比如：主体的角色为总经理可以查询企业运营报表，查询员工工资信息等，访问控制流程如下：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%AE%80%E5%8D%95%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/1.jpg)\n\n根据上图中的判断逻辑，授权代码可表示如下：\n\n```Java\nif(主体.hasRole(\"总经理角色id\")){ \n    查询工资 \n} \n```\n\n如果上图中查询工资所需要的角色变化为总经理和部门经理，此时就需要修改判断逻辑为“判断用户的角色是否是\n\n总经理或部门经理”，修改代码如下\n\n```Java\nif(主体.hasRole(\"总经理角色id\") || 主体.hasRole(\"部门经理角色id\")){ \n    查询工资 \n} \n```\n\n我们可以发现当需要修改角色的权限时就需要修改授权的相关代码，系统可扩展性差。考虑是否做成动态配置的？\n\n## 基于资源\n\nRBAC基于资源的访问控制（Resource-Based Access Control）是按资源（或权限）进行授权，比如：用户必须\n\n具有查询工资权限才可以查询员工工资信息等，访问控制流程如下：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%AE%80%E5%8D%95%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/2.jpg)\n\n\n根据上图中的判断，授权代码可以表示为：\n\n```Java\nif(主体.hasPermission(\"查询工资权限标识\")){ \n    查询工资 \n} \n```\n\n优点：系统设计时定义好查询工资的权限标识，即使查询工资所需要的角色变化为总经理和部门经理也不需要修改\n\n授权代码，系统可扩展性强。接口管理粒度更小，可对外提供动态配置。\n\n# 具体实现流程\n\n## 后端接口管理\n\n### 权限表\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%AE%80%E5%8D%95%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/3.jpg)\n\n\n### 验证流程\n\n1. 获取用户角色\n2. 获取用户角色具有的资源权限\n3. 验证访问的当前接口是否在用户权限列表中\n\n## 前端菜单管理\n\n### 权限表\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E7%AE%80%E5%8D%95%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/4.jpg)\n\n\n### 验证流程\n\n1. 获取用户角色\n2. 获取用户角色所能访问的菜单栏\n3. 动态生成菜单栏\n","tags":["权限管理"]},{"title":"策略模式+模板方法模式介绍","url":"/2023/03/23/策略模式-模板方法模式介绍.html","content":"\n# 前言\n\n风、宇的个人博客中针对第三方登录、文件上传等功能使用了策略模式+模板方法模式进行编写，是非常良好的编程习惯，这样在新增策略时只需要添加新类即可，同时也避免了复杂的条件判断。\n\n这里总结一下策略模式与模板方法模式的结合使用。\n\n>  值得提到的是，对于设计模式的学习我更偏向于结合具体的场景进行理解，以便今后灵活应用，而不是死板地记忆各种类角色。\n\n# 策略模式\n\n在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。\n\n例如我们要创建一个计算策略，通过传入不同的策略执行不同的逻辑：\n\n1. 创建一个接口\n\n```Java\npublic interface Strategy {\n   public int doOperation(int num1, int num2);\n}\n```\n\n2. 创建实现接口的实体类，封装了具体地执行逻辑，也就是不同的策略\n\n```Java\npublic class OperationAdd implements Strategy{\n   @Override\n   public int doOperation(int num1, int num2) {\n      return num1 + num2;\n   }\n}\npublic class OperationSubtract implements Strategy{\n   @Override\n   public int doOperation(int num1, int num2) {\n      return num1 - num2;\n   }\n}\npublic class OperationMultiply implements Strategy{\n   @Override\n   public int doOperation(int num1, int num2) {\n      return num1 * num2;\n   }\n}\n```\n\n3. 创建 Context 类，此类帮助我们注入不同的策略，并执行策略内容\n\n```Java\npublic class Context {\n   private Strategy strategy;\n \n   public Context(Strategy strategy){\n      this.strategy = strategy;\n   }\n \n   public int executeStrategy(int num1, int num2){\n      return strategy.doOperation(num1, num2);\n   }\n}\n```\n\n4. 当我们使用不同的策略时，执行逻辑也不同\n\n```Java\npublic class StrategyPatternDemo {\n   public static void main(String[] args) {\n      Context context = new Context(new OperationAdd());    \n      System.out.println(\"10 + 5 = \" + context.executeStrategy(10, 5));\n \n      context = new Context(new OperationSubtract());      \n      System.out.println(\"10 - 5 = \" + context.executeStrategy(10, 5));\n \n      context = new Context(new OperationMultiply());    \n      System.out.println(\"10 * 5 = \" + context.executeStrategy(10, 5));\n   }\n}\n```\n\n输出：\n\n```Java\n10 + 5 = 15\n10 - 5 = 5\n10 * 5 = 50\n```\n\n你可能会疑惑为什么要使用策略模式，上面的内容其实使用if判断也可以得到想要的内容，但设计模式的初衷在于如何让代码变得整洁优雅，实现设计模式的终极目标——对扩展开放，对修改封闭。使用if判断的缺点在于代码变得冗长晦涩，更糟糕的是在我们需要添加逻辑时需要修改if判断，对原有代码造成侵入。\n\n# 模板方法模式\n\n在模板方法模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。\n\n模板方法模式的主要目的是将方法调用中的共有部分抽离出来，独有部分做成暴露出来，供子类重写。其终极目标不言而喻——代码复用。\n\n例如我们模拟一个玩游戏的过程：\n\n1. 创建一个抽象类，它的模板方法被设置为 final，防止被重写，固定的流程（开始游戏与结束游戏）也做成final函数。startPlay()为抽象函数，必须子类实现。\n\n```Java\npublic abstract class Game {\n\n   abstract void startPlay();\n   \n   void final initialize(){\n       System.out.println(\"初始化游戏\");\n   }\n   \n   void final endPlay(){\n       System.out.println(\"结束游戏\");\n   }\n \n   //模板\n   public final void play(){\n \n      //初始化游戏\n      initialize();\n \n      //开始游戏\n      startPlay();\n \n      //结束游戏\n      endPlay();\n   }\n}\n```\n\n2. 实现不同的游戏，即玩的是不同的游戏\n\n```Java\npublic class Cricket extends Game {\n\n   @Override\n   void startPlay() {\n      System.out.println(\"Cricket Game Started. Enjoy the game!\");\n   }\n   \n}\npublic class Football extends Game {\n\n   @Override\n   void startPlay() {\n      System.out.println(\"Football Game Started. Enjoy the game!\");\n   }\n   \n}\n```\n\n3. 模拟玩游戏的过程\n\n```Java\npublic class TemplatePatternDemo {\n   public static void main(String[] args) {\n      Game game = new Cricket();\n      game.play();\n      game = new Football();\n      game.play();      \n   }\n}\n```\n\n输出：\n\n```Java\nCricket Game Started. Enjoy the game!\nFootball Game Started. Enjoy the game!\n```\n\n以上就是模拟玩游戏的全过程，我们将玩游戏的流程抽离出来，将固定的流程做成模板，而灵活可变的流程留给子类实现，达到了代码复用的功效。\n\n# 策略模式+模板方法模式\n\n策略模式与模板方法模式的结合使用，综合了这两种设计模式的优点，这里以风、宇博客中的第三方登录为例：\n\n1. 策略接口，只定义一个登录接口\n\n```Java\npublic interface SocialLoginStrategy {\n\n    /**\n     * 登录\n     *\n     * @param data 数据\n     * @return {@link UserInfoDTO} 用户信息\n     */\n    UserInfoDTO login(String data);\n\n}\n```\n\n2. 模板方法模式，抽取三方登录固有流程，其中抽象方法必须子类实现（黄色背景）\n\n```Java\npublic abstract class AbstractSocialLoginStrategyImpl implements SocialLoginStrategy {\n    @Autowired\n    private UserAuthDao userAuthDao;\n    @Autowired\n    private UserInfoDao userInfoDao;\n    @Autowired\n    private UserRoleDao userRoleDao;\n    @Autowired\n    private UserDetailsServiceImpl userDetailsService;\n    @Resource\n    private HttpServletRequest request;\n\n    @Override\n    public UserInfoDTO login(String data) {\n        // 创建登录信息\n        UserDetailDTO userDetailDTO;\n        // 获取第三方token信息\n        SocialTokenDTO socialToken = getSocialToken(data);\n        // 获取用户ip信息\n        String ipAddress = IpUtils.getIpAddress(request);\n        String ipSource = IpUtils.getIpSource(ipAddress);\n        // 判断是否已注册\n        UserAuth user = getUserAuth(socialToken);\n        if (Objects.nonNull(user)) {\n            // 返回数据库用户信息\n            userDetailDTO = getUserDetail(user, ipAddress, ipSource);\n        } else {\n            // 获取第三方用户信息，保存到数据库返回\n            userDetailDTO = saveUserDetail(socialToken, ipAddress, ipSource);\n        }\n        // 判断账号是否禁用\n        if (userDetailDTO.getIsDisable().equals(TRUE)) {\n            throw new BizException(\"账号已被禁用\");\n        }\n        // 将登录信息放入springSecurity管理\n        UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(userDetailDTO, null, userDetailDTO.getAuthorities());\n        SecurityContextHolder.getContext().setAuthentication(auth);\n        // 返回用户信息\n        return BeanCopyUtils.copyObject(userDetailDTO, UserInfoDTO.class);\n    }\n\n    /**\n     * 获取第三方token信息\n     *\n     * @param data 数据\n     * @return {@link SocialTokenDTO} 第三方token信息\n     */\n    public abstract SocialTokenDTO getSocialToken(String data);\n\n    /**\n     * 获取第三方用户信息\n     *\n     * @param socialTokenDTO 第三方token信息\n     * @return {@link SocialUserInfoDTO} 第三方用户信息\n     */\n    public abstract SocialUserInfoDTO getSocialUserInfo(SocialTokenDTO socialTokenDTO);\n\n    /**\n     * 获取用户账号\n     *\n     * @return {@link UserAuth} 用户账号\n     */\n    private UserAuth getUserAuth(SocialTokenDTO socialTokenDTO) {\n        return userAuthDao.selectOne(new LambdaQueryWrapper<UserAuth>()\n                .eq(UserAuth::getUsername, socialTokenDTO.getOpenId())\n                .eq(UserAuth::getLoginType, socialTokenDTO.getLoginType()));\n    }\n\n    /**\n     * 获取用户信息\n     *\n     * @param user      用户账号\n     * @param ipAddress ip地址\n     * @param ipSource  ip源\n     * @return {@link UserDetailDTO} 用户信息\n     */\n    private UserDetailDTO getUserDetail(UserAuth user, String ipAddress, String ipSource) {\n        // 更新登录信息\n        userAuthDao.update(new UserAuth(), new LambdaUpdateWrapper<UserAuth>()\n                .set(UserAuth::getLastLoginTime, LocalDateTime.now())\n                .set(UserAuth::getIpAddress, ipAddress)\n                .set(UserAuth::getIpSource, ipSource)\n                .eq(UserAuth::getId, user.getId()));\n        // 封装信息\n        return userDetailsService.convertUserDetail(user, request);\n    }\n\n    /**\n     * 新增用户信息\n     *\n     * @param socialToken token信息\n     * @param ipAddress   ip地址\n     * @param ipSource    ip源\n     * @return {@link UserDetailDTO} 用户信息\n     */\n    private UserDetailDTO saveUserDetail(SocialTokenDTO socialToken, String ipAddress, String ipSource) {\n        // 获取第三方用户信息\n        SocialUserInfoDTO socialUserInfo = getSocialUserInfo(socialToken);\n        // 保存用户信息\n        UserInfo userInfo = UserInfo.builder()\n                .nickname(socialUserInfo.getNickname())\n                .avatar(socialUserInfo.getAvatar())\n                .build();\n        userInfoDao.insert(userInfo);\n        // 保存账号信息\n        UserAuth userAuth = UserAuth.builder()\n                .userInfoId(userInfo.getId())\n                .username(socialToken.getOpenId())\n                .password(socialToken.getAccessToken())\n                .loginType(socialToken.getLoginType())\n                .lastLoginTime(LocalDateTime.now(ZoneId.of(SHANGHAI.getZone())))\n                .ipAddress(ipAddress)\n                .ipSource(ipSource)\n                .build();\n        userAuthDao.insert(userAuth);\n        // 绑定角色\n        UserRole userRole = UserRole.builder()\n                .userId(userInfo.getId())\n                .roleId(RoleEnum.USER.getRoleId())\n                .build();\n        userRoleDao.insert(userRole);\n        return userDetailsService.convertUserDetail(userAuth, request);\n    }\n\n}\n```\n\n3. 第三方登录实现\n\n```Java\npublic class QQLoginStrategyImpl extends AbstractSocialLoginStrategyImpl {\n    @Autowired\n    private QQConfigProperties qqConfigProperties;\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @Override\n    public SocialTokenDTO getSocialToken(String data) {\n        QQLoginVO qqLoginVO = JSON.parseObject(data, QQLoginVO.class);\n        // 校验QQ token信息\n        checkQQToken(qqLoginVO);\n        // 返回token信息\n        return SocialTokenDTO.builder()\n                .openId(qqLoginVO.getOpenId())\n                .accessToken(qqLoginVO.getAccessToken())\n                .loginType(LoginTypeEnum.QQ.getType())\n                .build();\n    }\n\n    @Override\n    public SocialUserInfoDTO getSocialUserInfo(SocialTokenDTO socialTokenDTO) {\n        // 定义请求参数\n        Map<String, String> formData = new HashMap<>(3);\n        formData.put(QQ_OPEN_ID, socialTokenDTO.getOpenId());\n        formData.put(ACCESS_TOKEN, socialTokenDTO.getAccessToken());\n        formData.put(OAUTH_CONSUMER_KEY, qqConfigProperties.getAppId());\n        // 获取QQ返回的用户信息\n        QQUserInfoDTO qqUserInfoDTO = JSON.parseObject(restTemplate.getForObject(qqConfigProperties.getUserInfoUrl(), String.class, formData), QQUserInfoDTO.class);\n        // 返回用户信息\n        return SocialUserInfoDTO.builder()\n                .nickname(Objects.requireNonNull(qqUserInfoDTO).getNickname())\n                .avatar(qqUserInfoDTO.getFigureurl_qq_1())\n                .build();\n    }\n\n    /**\n     * 校验qq token信息\n     *\n     * @param qqLoginVO qq登录信息\n     */\n    private void checkQQToken(QQLoginVO qqLoginVO) {\n        // 根据token获取qq openId信息\n        Map<String, String> qqData = new HashMap<>(1);\n        qqData.put(SocialLoginConst.ACCESS_TOKEN, qqLoginVO.getAccessToken());\n        try {\n            String result = restTemplate.getForObject(qqConfigProperties.getCheckTokenUrl(), String.class, qqData);\n            QQTokenDTO qqTokenDTO = JSON.parseObject(CommonUtils.getBracketsContent(Objects.requireNonNull(result)), QQTokenDTO.class);\n            // 判断openId是否一致\n            if (!qqLoginVO.getOpenId().equals(qqTokenDTO.getOpenid())) {\n                throw new BizException(QQ_LOGIN_ERROR);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new BizException(QQ_LOGIN_ERROR);\n        }\n    }\n\n}\npublic class WeiboLoginStrategyImpl extends AbstractSocialLoginStrategyImpl {\n    @Autowired\n    private WeiboConfigProperties weiboConfigProperties;\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @Override\n    public SocialTokenDTO getSocialToken(String data) {\n        WeiboLoginVO weiBoLoginVO = JSON.parseObject(data, WeiboLoginVO.class);\n        // 获取微博token信息\n        WeiboTokenDTO weiboToken = getWeiboToken(weiBoLoginVO);\n        // 返回token信息\n        return SocialTokenDTO.builder()\n                .openId(weiboToken.getUid())\n                .accessToken(weiboToken.getAccess_token())\n                .loginType(LoginTypeEnum.WEIBO.getType())\n                .build();\n    }\n\n    @Override\n    public SocialUserInfoDTO getSocialUserInfo(SocialTokenDTO socialTokenDTO) {\n        // 定义请求参数\n        Map<String, String> data = new HashMap<>(2);\n        data.put(UID, socialTokenDTO.getOpenId());\n        data.put(ACCESS_TOKEN, socialTokenDTO.getAccessToken());\n        // 获取微博用户信息\n        WeiboUserInfoDTO weiboUserInfoDTO = restTemplate.getForObject(weiboConfigProperties.getUserInfoUrl(), WeiboUserInfoDTO.class, data);\n        // 返回用户信息\n        return SocialUserInfoDTO.builder()\n                .nickname(Objects.requireNonNull(weiboUserInfoDTO).getScreen_name())\n                .avatar(weiboUserInfoDTO.getAvatar_hd())\n                .build();\n    }\n\n    /**\n     * 获取微博token信息\n     *\n     * @param weiBoLoginVO 微博登录信息\n     * @return {@link WeiboTokenDTO} 微博token\n     */\n    private WeiboTokenDTO getWeiboToken(WeiboLoginVO weiBoLoginVO) {\n        // 根据code换取微博uid和accessToken\n        MultiValueMap<String, String> weiboData = new LinkedMultiValueMap<>();\n        // 定义微博token请求参数\n        weiboData.add(CLIENT_ID, weiboConfigProperties.getAppId());\n        weiboData.add(CLIENT_SECRET, weiboConfigProperties.getAppSecret());\n        weiboData.add(GRANT_TYPE, weiboConfigProperties.getGrantType());\n        weiboData.add(REDIRECT_URI, weiboConfigProperties.getRedirectUrl());\n        weiboData.add(CODE, weiBoLoginVO.getCode());\n        HttpEntity<MultiValueMap<String, String>> requestEntity = new HttpEntity<>(weiboData, null);\n        try {\n            return restTemplate.exchange(weiboConfigProperties.getAccessTokenUrl(), HttpMethod.POST, requestEntity, WeiboTokenDTO.class).getBody();\n        } catch (Exception e) {\n            throw new BizException(WEIBO_LOGIN_ERROR);\n        }\n    }\n\n}\n```\n\n4. 暴露context供用户调用\n\n```Java\npublic class SocialLoginStrategyContext {\n\n    @Autowired\n    private Map<String, SocialLoginStrategy> socialLoginStrategyMap;\n\n    /**\n     * 执行第三方登录策略\n     *\n     * @param data          数据\n     * @param loginTypeEnum 登录枚举类型\n     * @return {@link UserInfoDTO} 用户信息\n     */\n    public UserInfoDTO executeLoginStrategy(String data, LoginTypeEnum loginTypeEnum) {\n        return socialLoginStrategyMap.get(loginTypeEnum.getStrategy()).login(data);\n    }\n\n}\n```\n","categories":["设计模式"]},{"title":"手写简易版spring web框架","url":"/2023/03/23/手写简易版spring-web框架.html","content":"\n# 前言\n\nspring框架给java工程师们提供了极大的便利，只需要添加相应的配置即可快速搭建项目骨架，将更多重心放在业务逻辑的开发中。spring具有两大核心功能：\n\n1. 控制反转（IoC，Inversion of Control）\n\n   传统的JAVA开发模式中，当需要一个对象时，我们使用new或者通过getInstance等直接或者间接调用构造方法创建一个对象，而在spring开发模式中，spring容器使用工厂模式为我们创建了所需要的对象，不需要我们自己去创建了，直接调用spring提供的对象就可以了，这就是控制反转。控制反转的好处有：\n     1. 使用方便，不用开发者大量使用new\n     2. 解耦合，实例对象交给容器管理\n\n2. 面向切面编程（AOP）\n\n    在面向对象编程（OOP）中，我们将事务纵向抽成一个个的对象，而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如**权限控制，事务管理，日志记录**等公用操作处理的过程，就是面向切面编程的思想。\n\n# 实现ioc\n\n## 主要流程图\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93%E7%89%88spring-web%E6%A1%86%E6%9E%B6/1.jpg)\n\n## 加载类文件\n\n首先我们需要加载包下的类文件，包名我们可以手动配置，因此提供配置文件：\n\n```Java\n/**\n * @Title\n * @Description 提供相关配置项常量\n * @Author WolfMan\n * @Date 2023/3/4 19:53\n * @Email 2370032534@qq.com\n */\npublic interface ConfigConstant {\n\n    /**\n     * 配置文件名\n     */\n    String CONFIG_FILE = \"wolf.properties\";\n\n    /**\n     * 数据库驱动\n     */\n    String JDBC_DRIVER = \"wolf.framework.jdbc.driver\";\n\n    /**\n     * 数据库连接\n     */\n    String JDBC_URL = \"wolf.framework.jdbc.url\";\n\n    /**\n     * 数据库用户\n     */\n    String JDBC_USERNAME = \"wolf.framework.jdbc.username\";\n\n    /**\n     * 数据库密码\n     */\n    String JDBC_PASSWORD = \"wolf.framework.jdbc.password\";\n\n    /**\n     * 项目包名（扫包需要）\n     */\n    String APP_BASE_PACKAGE = \"wolf.framework.app.base_package\";\n\n    /**\n     * jsp配置路径\n     */\n    String APP_JSP_PATH = \"wolf.framework.app.jsp_path\";\n\n    /**\n     * 静态资源路径\n     */\n    String APP_ASSET_PATH = \"wolf.framework.app.asset_path\";\n\n    /**\n     * 文件上传大小限制\n     */\n    String APP_UPLOAD_LIMIT = \"wolf.framework.app.upload_limit\";\n\n}\n```\n\n提供properties工具类：\n\n```Java\n/**\n * @Title\n * @Description 属性文件工具类\n * @Author WolfMan\n * @Date 2023/3/4 20:01\n * @Email 2370032534@qq.com\n */\npublic final class PropsUtil {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(PropsUtil.class);\n\n    /**\n     * 加载属性文件\n     *\n     * @param fileName\n     * @return\n     */\n    public static Properties loadProps(String fileName) {\n        Properties props = null;\n        InputStream is = null;\n        try {\n            is = ClassUtil.getClassLoader().getResourceAsStream(fileName);\n            if (is == null) {\n                throw new FileNotFoundException(fileName + \" file is not found\");\n            }\n            props = new Properties();\n            props.load(is);\n        } catch (IOException e) {\n            LOGGER.error(\"load properties file failure\", e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    LOGGER.error(\"close input stream failure\", e);\n                }\n            }\n        }\n        return props;\n    }\n\n    /**\n     * 获取String类型的属性值（默认为空字符串）\n     *\n     * @param props\n     * @param key\n     * @return\n     */\n    public static String getString(Properties props, String key) {\n        return getString(props, key, \"\");\n    }\n\n    /**\n     * 获取String类型的属性值（可指定默认值）\n     *\n     * @param props\n     * @param key\n     * @param defaultValue\n     * @return\n     */\n    public static String getString(Properties props, String key, String defaultValue) {\n        String value = defaultValue;\n        if (props.contains(key)) {\n            value = props.getProperty(key);\n        }\n        return value;\n    }\n\n    /**\n     * 获取 int 类型的属性值（默认值为 0）\n     */\n    public static int getInt(Properties props, String key) {\n        return getInt(props, key, 0);\n    }\n\n    /**\n     * 获取 int 类型的属性值（可指定默认值）\n     *\n     * @param props\n     * @param key\n     * @param defaultValue\n     * @return\n     */\n    public static int getInt(Properties props, String key, int defaultValue) {\n        int value = defaultValue;\n        if (props.contains(key)) {\n            value = CastUtil.castInt(props.getProperty(key));\n        }\n        return value;\n    }\n\n    /**\n     * 获取 boolean 类型属性（默认值为 false）\n     */\n    public static boolean getBoolean(Properties props, String key) {\n        return getBoolean(props, key, false);\n    }\n\n    /**\n     * 获取 boolean 类型属性（可指定默认值）\n     */\n    public static boolean getBoolean(Properties props, String key, boolean defaultValue) {\n        boolean value = defaultValue;\n        if (props.containsKey(key)) {\n            value = CastUtil.castBoolean(props.getProperty(key));\n        }\n        return value;\n    }\n}\n```\n\n通过配置文件我们可以知道包名，因此也能拿到类文件的地址。接下来提供一个class工具类，主要目的为加载类，返回所有类信息。\n\n```Java\n/**\n * @Title\n * @Description 类操作工具类\n * @Author WolfMan\n * @Date 2023/3/4 20:05\n * @Email 2370032534@qq.com\n */\npublic final class ClassUtil {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ClassUtil.class);\n\n    /**\n     * 获取类加载器\n     *\n     * @return\n     */\n    public static ClassLoader getClassLoader() {\n        return Thread.currentThread().getContextClassLoader();\n    }\n\n    /**\n     * 加载类\n     *\n     * @param className\n     * @param isInitialized\n     * @return\n     */\n    public static Class<?> loadClass(String className, boolean isInitialized) {\n        Class<?> cls;\n        try {\n            cls = Class.forName(className, isInitialized, getClassLoader());\n        } catch (ClassNotFoundException e) {\n            LOGGER.error(\"load class failure\", e);\n            throw new RuntimeException(e);\n        }\n        return cls;\n    }\n\n    /**\n     * 加载类（默认将初始化类）\n     *\n     * @param className\n     * @return\n     */\n    public static Class<?> loadClass(String className) {\n        return loadClass(className, true);\n    }\n\n    public static Set<Class<?>> getClassSet(String packageName) {\n        Set<Class<?>> classSet = new HashSet<Class<?>>();\n        try {\n            Enumeration<URL> urls = getClassLoader().getResources(packageName.replace(\".\", \"/\"));\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                if (url != null) {\n                    String protocol = url.getProtocol();\n                    if (\"file\".equals(protocol)) {\n                        String packagePath = url.getPath().replaceAll(\"%20\", \" \");\n                        addClass(classSet, packagePath, packageName);\n                    } else if (\"jar\".equals(protocol)) {\n                        JarURLConnection jarURLConnection = (JarURLConnection) url.openConnection();\n                        if (jarURLConnection != null) {\n                            JarFile jarFile = jarURLConnection.getJarFile();\n                            if (jarFile != null) {\n                                Enumeration<JarEntry> jarEntries = jarFile.entries();\n                                while (jarEntries.hasMoreElements()) {\n                                    JarEntry jarEntry = jarEntries.nextElement();\n                                    String jarEntryName = jarEntry.getName();\n                                    if (jarEntryName.endsWith(\".class\")) {\n                                        String className = jarEntryName.substring(0, jarEntryName.lastIndexOf(\".\")).replaceAll(\"/\", \".\");\n                                        doAddClass(classSet, className);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n        } catch (Exception e) {\n            LOGGER.error(\"get class set failure\", e);\n            throw new RuntimeException(e);\n        }\n        return classSet;\n    }\n\n\n    private static void addClass(Set<Class<?>> classSet, String packagePath, String packageName) {\n        File[] files = new File(packagePath).listFiles(new FileFilter() {\n            @Override\n            public boolean accept(File file) {\n                return (file.isFile() && file.getName().endsWith(\".class\")) || file.isDirectory();\n            }\n        });\n        for (File file : files) {\n            String fileName = file.getName();\n            if (file.isFile()) {\n                String className = fileName.substring(0, fileName.lastIndexOf(\".\"));\n                if (StringUtil.isNotEmpty(packageName)) {\n                    className = packageName + \".\" + className;\n                }\n                doAddClass(classSet, className);\n            } else {\n                String subPackagePath = fileName;\n                if (StringUtil.isNotEmpty(packagePath)) {\n                    subPackagePath = packagePath + \"/\" + subPackagePath;\n                }\n                String subPackageName = fileName;\n                if (StringUtil.isNotEmpty(packageName)) {\n                    subPackageName = packageName + \".\" + subPackageName;\n                }\n                addClass(classSet, subPackagePath, subPackageName);\n            }\n        }\n    }\n\n    private static void doAddClass(Set<Class<?>> classSet, String className) {\n        Class<?> cls = loadClass(className, false);\n        classSet.add(cls);\n    }\n\n\n}\n```\n\n## 生成实例对象\n\n我们已经拿到了类的信息，因此可以实例化类并用map保存起来，实例化的对象就叫bean。并不是所有的类都需要实例化，因此提供ClassHelper，供我们筛选指定的目标，例如带有service注解的类：\n\n```Java\n/**\n * @Title\n * @Description 类操作助手类\n * @Author WolfMan\n * @Date 2023/3/4 21:13\n * @Email 2370032534@qq.com\n */\npublic final class ClassHelper {\n\n    /**\n     * 定义类集合（用于存放所加载的类）\n     */\n    private static final Set<Class<?>> CLASS_SET;\n\n    static {\n        String basePackage = ConfigHelper.getAppBasePackage();\n        CLASS_SET = ClassUtil.getClassSet(basePackage);\n    }\n\n    /**\n     * 获取应用包名下的所有类\n     */\n    public static Set<Class<?>> getClassSet() {\n        return CLASS_SET;\n    }\n\n    /**\n     * 获取应用包名下所有 Service 类\n     */\n    public static Set<Class<?>> getServiceClassSet() {\n        Set<Class<?>> classSet = new HashSet<Class<?>>();\n        for (Class<?> cls : CLASS_SET) {\n            if (cls.isAnnotationPresent(Service.class)) {\n                classSet.add(cls);\n            }\n        }\n        return classSet;\n    }\n\n    /**\n     * 获取应用包名下所有 Controller 类\n     */\n    public static Set<Class<?>> getControllerClassSet() {\n        Set<Class<?>> classSet = new HashSet<Class<?>>();\n        for (Class<?> cls : CLASS_SET) {\n            if (cls.isAnnotationPresent(Controller.class)) {\n                classSet.add(cls);\n            }\n        }\n        return classSet;\n    }\n\n    /**\n     * 获取应用包名下所有 Bean 类（包括：Service、Controller 等）\n     */\n    public static Set<Class<?>> getBeanClassSet() {\n        Set<Class<?>> beanClassSet = new HashSet<Class<?>>();\n        beanClassSet.addAll(getServiceClassSet());\n        beanClassSet.addAll(getControllerClassSet());\n        return beanClassSet;\n    }\n\n    /**\n     * 获取应用包名下某父类（或接口）的所有子类（或实现类）\n     */\n    public static Set<Class<?>> getClassSetBySuper(Class<?> superClass) {\n        Set<Class<?>> classSet = new HashSet<Class<?>>();\n        for (Class<?> cls : CLASS_SET) {\n            if (superClass.isAssignableFrom(cls) && !superClass.equals(cls)) {\n                classSet.add(cls);\n            }\n        }\n        return classSet;\n    }\n\n    /**\n     * 获取应用包名下带有某注解的所有类\n     */\n    public static Set<Class<?>> getClassSetByAnnotation(Class<? extends Annotation> annotationClass) {\n        Set<Class<?>> classSet = new HashSet<Class<?>>();\n        for (Class<?> cls : CLASS_SET) {\n            if (cls.isAnnotationPresent(annotationClass)) {\n                classSet.add(cls);\n            }\n        }\n        return classSet;\n    }\n}\n/**\n * @Title\n * @Description Bean助手类\n * @Author WolfMan\n * @Date 2023/3/4 21:20\n * @Email 2370032534@qq.com\n */\npublic final class BeanHelper {\n\n    private static final Map<Class<?>, Object> BEAN_MAP = new HashMap<Class<?>, Object>();\n\n    static {\n        Set<Class<?>> beanClassSet = ClassHelper.getBeanClassSet();\n        for (Class<?> beanClass : beanClassSet) {\n            Object obj = ReflectionUtil.newInstance(beanClass);\n            BEAN_MAP.put(beanClass, obj);\n        }\n    }\n\n    /**\n     * 获取 Bean 映射\n     */\n    public static Map<Class<?>, Object> getBeanMap() {\n        return BEAN_MAP;\n    }\n\n    /**\n     * 获取 Bean 实例\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T getBean(Class<T> cls) {\n        if (!BEAN_MAP.containsKey(cls)) {\n            throw new RuntimeException(\"can not get bean by class: \" + cls);\n        }\n        return (T) BEAN_MAP.get(cls);\n    }\n\n    /**\n     * 设置 Bean 实例\n     */\n    public static void setBean(Class<?> cls, Object obj) {\n        BEAN_MAP.put(cls, obj);\n    }\n\n}\n```\n\n## 依赖注入\n\n上述操作我们已经把注解标注的类都实例化到bean容器中了，接下来考虑类与类的依赖关系，因此实现依赖注入。\n\n依赖注入的主要步骤为：\n\n1. 获取类\n2. 判断类中是否依赖其他类\n3. 从bean容器中拿到依赖类注入到当前bean中\n\n```Java\n/**\n * @Title\n * @Description 依赖注入助手类\n * @Author WolfMan\n * @Date 2023/3/4 21:23\n * @Email 2370032534@qq.com\n */\npublic final class IocHelper {\n\n    static {\n        Map<Class<?>, Object> beanMap = BeanHelper.getBeanMap();\n        if (CollectionUtil.isNotEmpty(beanMap)) {\n            for (Map.Entry<Class<?>, Object> beanEntry : beanMap.entrySet()) {\n                Class<?> beanClass = beanEntry.getKey();\n                Object beanInstance = beanEntry.getValue();\n                Field[] beanFields = beanClass.getDeclaredFields();\n                if (ArrayUtil.isNotEmpty(beanFields)) {\n                    for (Field beanField : beanFields) {\n                        if (beanField.isAnnotationPresent(Inject.class)) {\n                            Class<?> beanFieldClass = beanField.getType();\n                            Object beanFieldInstance = beanMap.get(beanFieldClass);\n                            if (beanFieldInstance != null) {\n                                ReflectionUtil.setField(beanInstance, beanField, beanFieldInstance);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n}\n```\n\n以上就是简易版的控制反转，能够使用@Service、@Sontroller等注解管理bean，同时使用@Inject注解进行依赖注入\n\n# 实现aop\n\n## 主要流程图\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93%E7%89%88spring-web%E6%A1%86%E6%9E%B6/2.jpg)\n\n## 获取被代理类\n\n为了实现切面编程，首先需要知道的就是哪些是被代理类，为了方便，我们可以使用自定义注解区分。例如被标注了@Logs的类就是我们的代理类，因此在@Aspect中，我们需要设置代理注解的值：\n\n```Java\n/**\n * @Title\n * @Description 切面注解\n * @Author WolfMan\n * @Date 2023/3/4 21:11\n * @Email 2370032534@qq.com\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Aspect {\n\n    /**\n     * 注解\n     */\n    Class<? extends Annotation> value();\n\n}\n```\n\n根据value()我们即可获取被代理类的注解。\n\n## 生成代理对象\n\n由于代理对象不止一个，因此我们要获取所有的代理对象，组成一个代理类链，并与被代理类形成映射。最终我们将被代理类信息与代理类实例注入到容器中。\n\n```Java\n/**\n * @Title\n * @Description 方法拦截助手类\n * @Author WolfMan\n * @Date 2023/3/4 23:40\n * @Email 2370032534@qq.com\n */\npublic final class AopHelper {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AopHelper.class);\n\n    static {\n        try {\n            Map<Class<?>, Set<Class<?>>> proxyMap = createProxyMap();\n            Map<Class<?>, List<Proxy>> targetMap = createTargetMap(proxyMap);\n            for (Map.Entry<Class<?>, List<Proxy>> targetEntry : targetMap.entrySet()) {\n                Class<?> targetClass = targetEntry.getKey();\n                List<Proxy> proxyList = targetEntry.getValue();\n                Object proxy = ProxyManager.createProxy(targetClass, proxyList);\n                BeanHelper.setBean(targetClass, proxy);\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"aop failure\", e);\n        }\n    }\n\n    private static Map<Class<?>, Set<Class<?>>> createProxyMap() throws Exception {\n        Map<Class<?>, Set<Class<?>>> proxyMap = new HashMap<Class<?>, Set<Class<?>>>();\n        addAspectProxy(proxyMap);\n        addTransactionProxy(proxyMap);\n        return proxyMap;\n    }\n\n    private static void addAspectProxy(Map<Class<?>, Set<Class<?>>> proxyMap) throws Exception {\n        Set<Class<?>> proxyClassSet = ClassHelper.getClassSetBySuper(AspectProxy.class);\n        for (Class<?> proxyClass : proxyClassSet) {\n            if (proxyClass.isAnnotationPresent(Aspect.class)) {\n                Aspect aspect = proxyClass.getAnnotation(Aspect.class);\n                Set<Class<?>> targetClassSet = createTargetClassSet(aspect);\n                proxyMap.put(proxyClass, targetClassSet);\n            }\n        }\n    }\n\n    private static void addTransactionProxy(Map<Class<?>, Set<Class<?>>> proxyMap) {\n        Set<Class<?>> serviceClassSet = ClassHelper.getClassSetByAnnotation(Service.class);\n        proxyMap.put(TransactionProxy.class, serviceClassSet);\n    }\n\n    private static Set<Class<?>> createTargetClassSet(Aspect aspect) throws Exception {\n        Set<Class<?>> targetClassSet = new HashSet<Class<?>>();\n        Class<? extends Annotation> annotation = aspect.value();\n        if (annotation != null && !annotation.equals(Aspect.class)) {\n            targetClassSet.addAll(ClassHelper.getClassSetByAnnotation(annotation));\n        }\n        return targetClassSet;\n    }\n\n    private static Map<Class<?>, List<Proxy>> createTargetMap(Map<Class<?>, Set<Class<?>>> proxyMap) throws Exception {\n        Map<Class<?>, List<Proxy>> targetMap = new HashMap<Class<?>, List<Proxy>>();\n        for (Map.Entry<Class<?>, Set<Class<?>>> proxyEntry : proxyMap.entrySet()) {\n            Class<?> proxyClass = proxyEntry.getKey();\n            Set<Class<?>> targetClassSet = proxyEntry.getValue();\n            for (Class<?> targetClass : targetClassSet) {\n                Proxy proxy = (Proxy) proxyClass.newInstance();\n                if (targetMap.containsKey(targetClass)) {\n                    targetMap.get(targetClass).add(proxy);\n                } else {\n                    List<Proxy> proxyList = new ArrayList<Proxy>();\n                    proxyList.add(proxy);\n                    targetMap.put(targetClass, proxyList);\n                }\n            }\n        }\n        return targetMap;\n    }\n\n}\n```\n\nProxyManager类生成最终代理类：\n\n```Java\n/**\n * @Title\n * @Description 代理管理器\n * @Author WolfMan\n * @Date 2023/3/4 23:44\n * @Email 2370032534@qq.com\n */\npublic class ProxyManager {\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T createProxy(final Class<?> targetClass, final List<Proxy> proxyList) {\n        return (T) Enhancer.create(targetClass, new MethodInterceptor() {\n            @Override\n            public Object intercept(Object targetObject, Method targetMethod, Object[] methodParams, MethodProxy methodProxy) throws Throwable {\n                return new ProxyChain(targetClass, targetObject, targetMethod, methodProxy, methodParams, proxyList).doProxyChain();\n            }\n        });\n    }\n\n}\n```\n\n## 提供代理模板类\n\n我们需要暴露给用户如何使用aop，因此提供了代理模板类，里面提供了各种钩子函数供用户选择。\n\n```Java\n/**\n * @Title\n * @Description 切面代理\n * @Author WolfMan\n * @Date 2023/3/4 23:43\n * @Email 2370032534@qq.com\n */\npublic abstract class AspectProxy implements Proxy {\n\n    private static final Logger logger = LoggerFactory.getLogger(AspectProxy.class);\n\n    @Override\n    public final Object doProxy(ProxyChain proxyChain) throws Throwable {\n        Object result = null;\n\n        Class<?> cls = proxyChain.getTargetClass();\n        Method method = proxyChain.getTargetMethod();\n        Object[] params = proxyChain.getMethodParams();\n\n        begin();\n        try {\n            if (intercept(cls, method, params)) {\n                before(cls, method, params);\n                result = proxyChain.doProxyChain();\n                after(cls, method, params, result);\n            } else {\n                result = proxyChain.doProxyChain();\n            }\n        } catch (Exception e) {\n            logger.error(\"proxy failure\", e);\n            error(cls, method, params, e);\n            throw e;\n        } finally {\n            end();\n        }\n\n        return result;\n    }\n\n    public void begin() {\n    }\n\n    public boolean intercept(Class<?> cls, Method method, Object[] params) throws Throwable {\n        return true;\n    }\n\n    public void before(Class<?> cls, Method method, Object[] params) throws Throwable {\n    }\n\n    public void after(Class<?> cls, Method method, Object[] params, Object result) throws Throwable {\n    }\n\n    public void error(Class<?> cls, Method method, Object[] params, Throwable e) {\n    }\n\n    public void end() {\n    }\n\n}\n```\n\n其中proxy接口如下：\n\n```Java\n/**\n * @Title\n * @Description 代理接口\n * @Author WolfMan\n * @Date 2023/3/4 23:41\n * @Email 2370032534@qq.com\n */\npublic interface Proxy {\n\n    Object doProxy(ProxyChain proxyChain) throws Throwable;\n\n}\n```\n\n值得注意的是AopHelper的初始化顺序，必须在BeanHelper初始化后，IocHelper初始化前初始化：\n\n```Java\n/**\n * @Title\n * @Description 加载相应的 Helper 类\n * @Author WolfMan\n * @Date 2023/3/4 23:49\n * @Email 2370032534@qq.com\n */\npublic final class HelperLoader {\n\n    public static void init() {\n        Class<?>[] classList = {\n                ClassHelper.class,\n                BeanHelper.class,\n                AopHelper.class,\n                IocHelper.class,\n                ControllerHelper.class\n        };\n        for (Class<?> cls : classList) {\n            ClassUtil.loadClass(cls.getName());\n        }\n    }\n\n}\n```\n\n以上就是aop的简单实现，我们可以通过注解@Aspect注解同时继承AspectProxy类来代理目标类，实现不侵入业务的逻辑。\n\n# 实现d**ispatcherServlet**\n\n## 主要流程图\n\n转发器实现接受请求并且将请求转发到对应的处理方法中，主要流程如下：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93%E7%89%88spring-web%E6%A1%86%E6%9E%B6/3.jpg)\n\n## 封装请求与处理器映射\n\n我们要做的是封装请求与处理方法的映射，唯一标识一个请求的方法是**请求路径与请求方法的组合**，前面已经将controller加入bean容器中了，只需要解析controller中的Action注解并封装成映射即可。\n\n```Java\n/**\n * @Title\n * @Description 控制器助手类\n * @Author WolfMan\n * @Date 2023/3/4 21:22\n * @Email 2370032534@qq.com\n */\npublic final class ControllerHelper {\n\n    private static final Map<Request, Handler> ACTION_MAP = new HashMap<Request, Handler>();\n\n    static {\n        Set<Class<?>> controllerClassSet = ClassHelper.getControllerClassSet();\n        if (CollectionUtil.isNotEmpty(controllerClassSet)) {\n            for (Class<?> controllerClass : controllerClassSet) {\n                Method[] methods = controllerClass.getDeclaredMethods();\n                if (ArrayUtil.isNotEmpty(methods)) {\n                    for (Method method : methods) {\n                        if (method.isAnnotationPresent(Action.class)) {\n                            Action action = method.getAnnotation(Action.class);\n                            String mapping = action.value();\n                            if (mapping.matches(\"\\\\w+:/\\\\w*\")) {\n                                String[] array = mapping.split(\":\");\n                                if (ArrayUtil.isNotEmpty(array) && array.length == 2) {\n                                    String requestMethod = array[0];\n                                    String requestPath = array[1];\n                                    Request request = new Request(requestMethod, requestPath);\n                                    Handler handler = new Handler(controllerClass, method);\n                                    ACTION_MAP.put(request, handler);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * 获取 Handler\n     */\n    public static Handler getHandler(String requestMethod, String requestPath) {\n        Request request = new Request(requestMethod, requestPath);\n        return ACTION_MAP.get(request);\n    }\n\n}\n```\n\n## 封装请求参数\n\n我们需要封装请求参数，并且从ACTION_MAP中获取对应的handler，反射调用即可\n\n```Java\n/**\n * @Title\n * @Description 请求转发器\n * @Author WolfMan\n * @Date 2023/3/4 23:50\n * @Email 2370032534@qq.com\n */\n@WebServlet(urlPatterns = \"/*\", loadOnStartup = 0)\npublic class DispatcherServlet extends HttpServlet {\n\n\n    @Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n        HelperLoader.init();\n\n        ServletContext servletContext = servletConfig.getServletContext();\n\n        registerServlet(servletContext);\n\n        UploadHelper.init(servletContext);\n    }\n\n    private void registerServlet(ServletContext servletContext) {\n        ServletRegistration jspServlet = servletContext.getServletRegistration(\"jsp\");\n        jspServlet.addMapping(\"/index.jsp\");\n        jspServlet.addMapping(ConfigHelper.getAppJspPath() + \"*\");\n\n        ServletRegistration defaultServlet = servletContext.getServletRegistration(\"default\");\n        defaultServlet.addMapping(\"/favicon.ico\");\n        defaultServlet.addMapping(ConfigHelper.getAppAssetPath() + \"*\");\n    }\n\n    @Override\n    public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        ServletHelper.init(request, response);\n        try {\n            String requestMethod = request.getMethod().toLowerCase();\n            String requestPath = request.getPathInfo();\n            Handler handler = ControllerHelper.getHandler(requestMethod, requestPath);\n            if (handler != null) {\n                Class<?> controllerClass = handler.getControllerClass();\n                Object controllerBean = BeanHelper.getBean(controllerClass);\n\n                Param param;\n                if (UploadHelper.isMultipart(request)) {\n                    param = UploadHelper.createParam(request);\n                } else {\n                    param = RequestHelper.createParam(request);\n                }\n\n                Object result;\n                Method actionMethod = handler.getActionMethod();\n                if (param.isEmpty()) {\n                    result = ReflectionUtil.invokeMethod(controllerBean, actionMethod);\n                } else {\n                    result = ReflectionUtil.invokeMethod(controllerBean, actionMethod, param);\n                }\n\n                if (result instanceof View) {\n                    handleViewResult((View) result, request, response);\n                } else if (result instanceof Data) {\n                    handleDataResult((Data) result, response);\n                }\n            }\n        } finally {\n            ServletHelper.destroy();\n        }\n    }\n\n}\n```\n\n## 解析处理器返回值\n\n根据handler返回值判读即可：\n\n```Java\n/**\n * @Title\n * @Description 请求转发器\n * @Author WolfMan\n * @Date 2023/3/4 23:50\n * @Email 2370032534@qq.com\n */\n@WebServlet(urlPatterns = \"/*\", loadOnStartup = 0)\npublic class DispatcherServlet extends HttpServlet {\n\n    private void handleViewResult(View view, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String path = view.getPath();\n        if (StringUtil.isNotEmpty(path)) {\n            if (path.startsWith(\"/\")) {\n                response.sendRedirect(request.getContextPath() + path);\n            } else {\n                Map<String, Object> model = view.getModel();\n                for (Map.Entry<String, Object> entry : model.entrySet()) {\n                    request.setAttribute(entry.getKey(), entry.getValue());\n                }\n                request.getRequestDispatcher(ConfigHelper.getAppJspPath() + path).forward(request, response);\n            }\n        }\n    }\n\n    private void handleDataResult(Data data, HttpServletResponse response) throws IOException {\n        Object model = data.getModel();\n        if (model != null) {\n            response.setContentType(\"application/json\");\n            response.setCharacterEncoding(\"UTF-8\");\n            PrintWriter writer = response.getWriter();\n            String json = JsonUtil.toJson(model);\n            writer.write(json);\n            writer.flush();\n            writer.close();\n        }\n    }\n\n}\n```\n\n转发器的主要思想是拦截所有请求，并获取对应的处理器，解析处理器返回值，转发给客户端。\n\n# 相关资料\n\n1. 源码地址：[手写简易版spring框架](https://gitee.com/lei-yongjian/wolf-framework/tree/master/src/main/java/com/wolf/framework)\n2. 参考资料：架构探险从零开始写java web框架\n","tags":["spring"],"categories":["手写系列"]},{"title":"迷宫游戏","url":"/2023/03/23/迷宫游戏.html","content":"\n# 写在前面\n\n算法设计与分析课程大作业为实现一个迷宫游戏，我觉得挺有意思的，于是做一下记录。\n\njava的图形化编程没怎么学，我打算采用js来实现，使用网页编程的好处是比较轻量，并且自由度比较高，也挺适合这类小游戏的，但最主要的原因还是java图形化编程不太会。\n\n# 前期准备\n\n首先引入jq简化开发，生成迷宫的基本思路是外面套一层div作为包裹，中间再包裹上小div，当然外层div拥有边框，内部的小div就需要对边框进行处理：\n\n- 所有div加上右边和下边的边框\n- 最后一行去除下边框\n- 最后一列去除右边框\n\nhtml结构如下：\n\n```HTML\n<body>\n        <div class=\"maze-outer\">\n            <div class=\"first-grid\">\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n            </div>\n            <div class=\"first-grid\">\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n            </div>\n            <div class=\"first-grid\">\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n            </div>\n            <div class=\"first-grid\">\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n            </div>\n            <div class=\"first-grid\">\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n                <div class=\"second-grid\"></div>\n            </div>\n        </div>\n        <div class=\"message\">游戏成功！</div>\n    </body>\n```\n\n样式如下：\n\n```HTML\n<style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        .maze-outer {\n            margin: 10px auto;\n            height: 700px;\n            width: 700px;\n            border: 1px solid black;\n        }\n        .first-grid {\n            width: 100%;\n            height: 140px;\n            display: flex;\n        }\n        .second-grid {\n            width: 140px;\n            height: 100%;\n            background-color: gold;\n            border-right: 1px solid black;\n            border-bottom: 1px solid black;\n            box-sizing: border-box;\n        }\n        .first-grid:last-child .second-grid {\n            border-bottom: none;\n        }\n        .second-grid:last-child {\n            border-right: none;\n        }\n        .none-right {\n            border-right: none;\n        }\n        .none-bottom {\n            border-bottom: none;\n        }\n        .message {\n            position: fixed;\n            top: 25px;\n            left: 50%;\n            transform: translateX(-50%);\n            font-size: 45px;\n            display: none;\n        }\n</style>\n```\n\n最终效果如下：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/1.png)\n\n引入人物样式：\n\n```HTML\n<style>\n        .wolfman {\n            background-color: red;\n        }\n</style>\n```\n\n最终效果如下：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/2.png)\n\n准备全局变量：\n\n```JavaScript\n //迷宫墙壁\n let mazeOuter = $(\".maze-outer\");\n //消息提示\n let message = $(\".message\");\n //迷宫数组\n let maze = [];\n //迷宫格子数\n let n = 10;\n //当前人物位置\n let x = 0;\n let y = 0;\n```\n\n以上基本的准备工作已经完成，下面介绍迷宫生成算法。\n\n# 迷宫生成算法\n\n## 递归回溯算法\n\n### 算法思想\n\n每次把新找到的未访问迷宫单元作为优先，寻找其相邻的未访问过的迷宫单元，直到所有的单元都被访问到。通俗的说，就是从起点开始随机走，走不通了就返回上一步，从下一个能走的地方再开始随机走。\n\n### 算法步骤\n\n```Java\n1.将起点作为当前迷宫单元并标记为已访问\n2.当还存在未标记的迷宫单元，进行循环\n        1.如果当前迷宫单元有未被访问过的的相邻的迷宫单元\n                1.随机选择一个未访问的相邻迷宫单元\n                2.将当前迷宫单元入栈\n                3.移除当前迷宫单元与相邻迷宫单元的墙\n                4.标记相邻迷宫单元并用它作为当前迷宫单元\n        2.如果当前迷宫单元不存在未访问的相邻迷宫单元，并且栈不空\n                1.栈顶的迷宫单元出栈\n                2.令其成为当前迷宫单元\n```\n\n### 具体实现\n\n```JavaScript\n//深度遍历初始化迷宫\nfunction initMazeByDfs() {\n    let stack = [];\n    //初始化数组\n    initMazeArray();\n    maze[0][0].visited = true;\n    let i = 0, j = 0;\n    //初始化迷宫\n    while (isAllVisited(maze)) {\n        let unVisited = [];\n        //判断上一个单元格\n        if (i - 1 >= 0 && maze[i - 1][j].visited === false) {\n            unVisited.push(maze[i - 1][j]);\n        }\n        //判断右一个单元格\n        if (j + 1 < n && maze[i][j + 1].visited === false) {\n            unVisited.push(maze[i][j + 1]);\n        }\n        //判断下一个单元格\n        if (i + 1 < n && maze[i + 1][j].visited === false) {\n            unVisited.push(maze[i + 1][j]);\n        }\n        //判断左一个单元格\n        if (j - 1 >= 0 && maze[i][j - 1].visited === false) {\n            unVisited.push(maze[i][j - 1]);\n        }\n        if (unVisited.length !== 0) {\n            let r = getRandomGrid(unVisited);\n            r.visited = true;\n            stack.push(maze[i][j]);\n            removeWall(maze[i][j], r);\n            i = r.i;\n            j = r.j;\n        } else if (stack.length !== 0) {\n            let r = stack.pop();\n            i = r.i;\n            j = r.j;\n        }\n    }\n}\n```\n\n其中所用函数：\n\n```JavaScript\n//初始化数组\nfunction initMazeArray() {\n    for (let i = 0; i < n; i++) {\n        let m = [];\n        for (let j = 0; j < n; j++) {\n            let item = {class: \"second-grid\", visited: false, i: i, j: j};\n            m.push(item);\n        }\n        maze.push(m);\n    }\n}\n//初始化全局maze数组，构造对象加入数组\n//其中class代表类名，visited表示该单元格是否已访问，i,j代表该单元格位置。\n//判断是否还有剩余单元格未访问\nfunction isAllVisited(maze) {\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            if (!maze[i][j].visited) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n//获取随机元素\nfunction getRandomGrid(unVisited) {\n    let index = Math.floor(Math.random() * unVisited.length);\n    return unVisited[index];\n}\n//在未访问的元素集合中随机返回一个元素\n//移除两个格子间的墙壁\nfunction removeWall(cur, nei) {\n    //nei在cur的上部\n    if (cur.i - 1 >= 0 && cur.i - 1 === nei.i) {\n        nei.class += \" none-bottom\";\n    }\n    //nei在cur的右部\n    if (cur.j + 1 < n && cur.j + 1 === nei.j) {\n        cur.class += \" none-right\";\n    }\n    //nei在cur的下部\n    if (cur.i + 1 < n && cur.i + 1 === nei.i) {\n        cur.class += \" none-bottom\";\n    }\n    //nei在cur的左部\n    if (cur.j - 1 >= 0 && cur.j - 1 === nei.j) {\n        nei.class += \" none-right\";\n    }\n}\n//其中cur参数表示当前格子，nei表示与其邻近的格子，两种格子的位置关系分为以下四种：\n```\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/3.png)\n\n注意判断边界条件。\n\n### 生成效果\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/4.png)\n\n深度优先法生成的迷宫极度扭曲，有着一条明显的主路。\n\n## 随机prim算法\n\n### 算法思想\n\n类似图论中的prim算法，随机prim算法将单元格当作节点，墙作为边，可生成从起点到终点的路径。\n\n### 算法步骤\n\n```Java\n1.让迷宫全是墙.\n2.选一个单元格作为迷宫的通路，然后把它的邻墙放入列表\n3.当列表里还有墙时\n        1.从列表里随机选一个墙，如果这面墙分隔的两个单元格只有一个单元格被访问过\n                1.那就从列表里移除这面墙，即把墙打通，让未访问的单元格成为迷宫的通路\n                2.把这个格子的墙加入列表\n        2.如果墙两面的单元格都已经被访问过，那就从列表里移除这面墙\n```\n\n### 具体实现\n\n```JavaScript\nfunction initMazeByRandomPrim() {\n    //初始化数组\n    initMazeArray();\n    //初始化墙\n    let list = [];\n    maze[0][0].visited = true;\n    addWallToList(list, maze[0][0]);\n    while (list.length !== 0) {\n        let index = Math.floor(Math.random() * list.length);\n        let w = list[index];\n        if (w.type === \"right\" && w.j + 1 < n) {\n            if ((maze[w.i][w.j].visited ^ maze[w.i][w.j + 1].visited)) {\n                maze[w.i][w.j + 1].visited = true;\n                maze[w.i][w.j].class += \" none-right\";\n                addWallToList(list, maze[w.i][w.j + 1]);\n            } else if (maze[w.i][w.j].visited && maze[w.i][w.j + 1].visited)                         {\n                list.splice(index, 1);\n            }\n\n        } else if (w.type === \"bottom\" && w.i + 1 < n) {\n            if ((maze[w.i][w.j].visited ^ maze[w.i + 1][w.j].visited)) {\n                maze[w.i + 1][w.j].visited = true;\n                maze[w.i][w.j].class += \" none-bottom\";\n                addWallToList(list, maze[w.i + 1][w.j]);\n            } else if (maze[w.i][w.j].visited && maze[w.i + 1][w.j].visited)                         {\n                list.splice(index, 1);\n            }\n        }\n    }\n}\n```\n\n### 生成效果\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/5.png)\n\n相对于深度优先的算法，Prim随机算法不是优先选择最近选中的单元格，而是随机的从所有的列表中的单元格进行选择，新加入的单元格和旧加入的单元格同样概率会被选择，新加入的单元格没有有优先权。因此其分支更多，生成的迷宫更复杂，难度更大，也更自然。\n\n## 区域划分算法\n\n### 算法思想\n\n把空间用十字分成四个子空间，然后在三面墙上挖洞（为了确保连通），之后对每个子空间继续做这件事直到空间不足以继续分割为止。\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/6.png)\n\n### 算法步骤\n\n```Java\n1.初始化数组没有墙\n2.判断数组是否满足条件，不满足则返回\n    1.随机选择一行和一列加入墙，并挖洞\n    2.将数组划分为四块\n    3.递归绘制每一块\n```\n\n### 具体实现\n\n```JavaScript\n//基于分治法初始化迷宫\nfunction initMazeByDivideAndConquer() {\n    //初始化数组\n    initMazeArrayInDivideAndConquer();\n    //递归生成迷宫\n    initMazeByRecursion(0, n - 2, 0, n - 2);\n}\n\n//区域划分算法\nfunction initMazeByRecursion(xStart, xEnd, yStart, yEnd) {\n    if (xStart >= xEnd || yStart >= yEnd) {\n        return;\n    }\n    let row = getRandom(xStart, xEnd);\n    let col = getRandom(yStart, yEnd);\n    drawLine(xStart, xEnd, yStart, yEnd, row, col);\n    //左上\n    initMazeByRecursion(xStart, row - 1, yStart, col - 1);\n    //右上\n    initMazeByRecursion(xStart, row - 1, col + 1, yEnd);\n    //右下\n    initMazeByRecursion(row + 1, xEnd, col + 1, yEnd);\n    //左下\n    initMazeByRecursion(row + 1, xEnd, yStart, col - 1);\n}\n```\n\n其中所用函数：\n\n```JavaScript\n//画线\nfunction drawLine(xStart, xEnd, yStart, yEnd, row, col) {\n        //上\n        let r1 = getRandom(xStart, row);\n        //右\n        let r2 = getRandom(col + 1, yEnd);\n        //下\n        let r3 = getRandom(row + 1, xEnd);\n        //左\n        let r4 = getRandom(yStart, col);\n        for (let i = xStart; i < xEnd + 2; i++) {\n            for (let j = yStart; j < yEnd + 2; j++) {\n                if (i === row && j !== r2 && j !== r4) {\n            maze[i][j].class = maze[i][j].class.replace(/none-bottom/, \"\");\n                           }\n            if (j === col && i !== r1 && i !== r3) {\n             maze[i][j].class = maze[i][j].class.replace(/none-right/, \"1\");\n                        }\n                }\n        }\n}\n//获取[n,m]间的随机数\nfunction getRandom(n, m) {\n        return Math.floor(Math.random() * (m - n) + n + 0.5);\n}\n```\n\n> 区域划分算法代码实现有一些小bug😥😥😥，有时生成出来的迷宫没有完全连通，有个别单元格是封闭的...\n\n### 生成效果\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/7.png)\n\n区域划分算法生成的迷宫有很明显的直路，这是因为在生成过程中，墙壁是从大到小生成，并且通路是通过挖洞来实现的。\n\n# 人物移动实现\n\n通过以上算法，我们实现了迷宫的生成，接下来我们简单实现一下游戏交互功能，基本思路为：\n\n- 监听键盘事件\n- 移动当前人物位置\n\n## 键盘监听\n\n注册键盘监听事件：\n\n```JavaScript\n$(window).bind('keydown', listenKeyDown);\n```\n\n其中所用函数：\n\n```JavaScript\n//监听键盘事件\n            function listenKeyDown(event) {\n                let type = event.originalEvent.code;\n                switch (type) {\n                    case \"ArrowUp\":\n                        if (x - 1 >= 0 && getCubePosition(x - 1, y).className.indexOf(\"none-bottom\") > 0) {\n                            removeCubePosition(x, y);\n                            changeCubePosition(--x, y);\n                        }\n                        break;\n                    case \"ArrowRight\":\n                        if (y + 1 < n && getCubePosition(x, y).className.indexOf(\"none-right\") > 0) {\n                            removeCubePosition(x, y);\n                            changeCubePosition(x, ++y);\n                        }\n                        break;\n                    case \"ArrowDown\":\n                        if (x + 1 < n && getCubePosition(x, y).className.indexOf(\"none-bottom\") > 0) {\n                            removeCubePosition(x, y);\n                            changeCubePosition(++x, y);\n                        }\n                        break;\n                    case \"ArrowLeft\":\n                        if (y - 1 >= 0 && getCubePosition(x, y - 1).className.indexOf(\"none-right\") > 0) {\n                            removeCubePosition(x, y);\n                            changeCubePosition(x, --y);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n```\n\n其中listenKeyDown函数需要注意移动时判断边界条件：\n\n- 是否有墙壁\n- 是否移动到迷宫外\n\n```JavaScript\n//根据元素i,j获取元素\nfunction getCubePosition(i, j) {\n    if (i < 0 || j < 0 || i >= n || j >= n) {\n        return;\n    }\n    let firstChildren = mazeOuter.children();\n    let secondChildren = $(firstChildren[i]).children();\n    return secondChildren[j];\n}\n //删除指定位置人物轨迹\n function removeCubePosition(i, j) {\n     if (i < 0 || j < 0 || i >= n || j >= n) {\n         return;\n     }\n     let firstChildren = mazeOuter.children();\n     //将原来的标记删除\n     $($(firstChildren[x]).children()[y]).removeClass(\"wolfman\");\n }\n//改变人物位置\nfunction changeCubePosition(i, j) {\n    if (i < 0 || j < 0 || i >= n || j >= n) {\n        return;\n    }\n    let firstChildren = mazeOuter.children();\n    //添加新的标记\n    $($(firstChildren[i]).children()[j]).addClass(\"wolfman\");\n    if (i === n - 1 && j === n - 1) {\n        message.fadeIn();\n    }\n}\n```\n\n## 人物移动\n\n人物移动我们只需要改变移动位置的颜色即可，并不需要实现真实的位置移动。\n\n> 以上代码即可实现通过上下左右键控制人物的移动了!🤗🤗🤗\n\n# 迷宫路径搜索\n\n接下来我们实现迷宫路径的自动寻路，一般有两种方式，深度优先搜索和广度优先搜索。\n\n## 深度优先搜索\n\n### 算法思想\n\n依次向上右下左进行递归，直到没有路，则回退。\n\n### 算法步骤\n\n```Java\n1.判断是否超出边界，超出则回退\n2.标记当前位置已访问并加入记录路径\n3.按上右下左依次判断是否能访问，能则继续递归\n```\n\n### 具体实现\n\n```JavaScript\n//深度搜索自动寻路\nfunction getShortestPathDFS(start, end) {\n    let path = [];\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            maze[i][j].visited = false;\n        }\n    }\n    dfs(maze[start][end], path);\n    let s = 0;\n    let timer = setInterval(function () {\n            if (s === path.length || (path[s].i === n - 1 && path[s].j === n - 1)) {\n            clearInterval(timer);\n            return;\n        }\n        s++;\n        // removeCubePosition(x, y);\n        x = path[s].i;\n        y = path[s].j;\n        changeCubePosition(x, y);\n        }, 20);\n}\n//深度搜索自动寻路\n            function dfs(start, path) {\n                if (start.i < 0 || start.j < 0 || start.i >= n || start.j >= n) {\n                    return;\n                }\n                start.visited = true;\n                path.push(start);\n                //上\n                if (start.i - 1 >= 0 && !maze[start.i - 1][start.j].visited && getCubePosition(start.i - 1, start.j).className.indexOf(\"none-bottom\") > 0) {\n                    dfs(maze[start.i - 1][start.j], path);\n                }\n                //右\n                if (start.j + 1 < n && !maze[start.i][start.j + 1].visited && getCubePosition(start.i, start.j).className.indexOf(\"none-right\") > 0) {\n                    dfs(maze[start.i][start.j + 1], path);\n                }\n                //下\n                if (start.i + 1 < n && !maze[start.i + 1][start.j].visited && getCubePosition(start.i, start.j).className.indexOf(\"none-bottom\") > 0) {\n                    dfs(maze[start.i + 1][start.j], path);\n                }\n                //左\n                if (start.j - 1 >= 0 && !maze[start.i][start.j - 1].visited && getCubePosition(start.i, start.j - 1).className.indexOf(\"none-right\") > 0) {\n                    dfs(maze[start.i][start.j - 1], path);\n                }\n            }\n```\n\n注意判断边界条件。\n\n### 最终效果\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/8.png)\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/9.png)\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/10.png)\n\n观察可以看到，深度优先搜索和代码的关联度比较大，我们深度遍历的次序是上->右->下->左，那么最终形成的路径就会优先遍历上右部分，我们还可以观察到，深度优先搜索到达终点后是可以提前结束的。\n\n## 回溯记录路径\n\n### 算法思想\n\n以上代码可以实现，深度优先遍历查找终点，我们可以使用**回溯法**找到的路径。具体思想为，如果当前单元格不是终点并且周围单元格都无法访问（包含不能访问和已经访问过），则表明该单元格不是路径中的单元格，将其移出结果数组即可。\n\n因为回溯找到一条路径就直接退出了，那么这条路径不能保证是最短路径，后面的广度优先搜索会讲到如何求得最短路径。\n\n### 算法步骤\n\n```Java\n1.判断递归条件(是否越界或是否已找到终点)是否满足，满足则返回\n2.将该单元格标记为已访问并入栈\n3.判断该单元格是否为终点，是则标记已找到终点\n4.判断上右下左是否能访问，能则继续递归\n5.判断条件（栈不为空且未找到终点），条件满足则出栈\n```\n\n### 具体实现\n\n将深度优先搜索的代码修改一下即可。\n\n```JavaScript\n//深度搜索自动寻路\n            function dfs(start, path) {\n                if (start.i < 0 || start.j < 0 || start.i >= n || start.j >= n || dfsFindPathFlag) {\n                    return;\n                }\n                start.visited = true;\n                path.push(start);\n                if (start.i === n - 1 && start.j === n - 1) {\n                    dfsFindPathFlag = true;\n                    return;\n                }\n                //上\n                if (start.i - 1 >= 0 && !maze[start.i - 1][start.j].visited && getCubePosition(start.i - 1, start.j).className.indexOf(\"none-bottom\") > 0) {\n                    dfs(maze[start.i - 1][start.j], path);\n                }\n                //右\n                if (start.j + 1 < n && !maze[start.i][start.j + 1].visited && getCubePosition(start.i, start.j).className.indexOf(\"none-right\") > 0) {\n                    dfs(maze[start.i][start.j + 1], path);\n                }\n                //下\n                if (start.i + 1 < n && !maze[start.i + 1][start.j].visited && getCubePosition(start.i, start.j).className.indexOf(\"none-bottom\") > 0) {\n                    dfs(maze[start.i + 1][start.j], path);\n                }\n                //左\n                if (start.j - 1 >= 0 && !maze[start.i][start.j - 1].visited && getCubePosition(start.i, start.j - 1).className.indexOf(\"none-right\") > 0) {\n                    dfs(maze[start.i][start.j - 1], path);\n                }\n                if (path.length !== 0 && !dfsFindPathFlag) {\n                    path.pop();\n                }\n            }\n//深度搜索自动寻路\n            function getShortestPathDFS(start, end) {\n                let path = [];\n                for (let i = 0; i < n; i++) {\n                    for (let j = 0; j < n; j++) {\n                        maze[i][j].visited = false;\n                    }\n                }\n                dfs(maze[start][end], path);\n                let s = 0;\n                // removeCubePosition(x, y);\n                x = path[s].i;\n                y = path[s].j;\n                changeCubePosition(x, y);\n                timer = setInterval(function () {\n                    if (s === path.length || (path[s].i === n - 1 && path[s].j === n - 1)) {\n                        clearInterval(timer);\n                        return;\n                    }\n                    s++;\n                    // removeCubePosition(x, y);\n                    x = path[s].i;\n                    y = path[s].j;\n                    changeCubePosition(x, y);\n                }, 50);\n            }\n```\n\n> 其中dfsFindPathFlag为全局标志遍历，记录是否找到终点。\n\n### 最终效果\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/11.png)\n\n## 广度优先搜索\n\n### 算法思想\n\n一层一层向外扩张。\n\n### 算法步骤\n\n```Java\n1.初始队列为空，将第一个单元格加入队列\n2.当队列不为空时\n    1.出队，置该单元格为已访问并加入记录路径\n    2.上右下左判断其相邻单元格是否可访问，若能，则入队\n```\n\n### 具体实现\n\n```JavaScript\n//广度搜索自动寻路\n            function getShortestPathBFS(start, end) {\n                let queue = [];\n                let path = [];\n                for (let i = 0; i < n; i++) {\n                    for (let j = 0; j < n; j++) {\n                        maze[i][j].visited = false;\n                    }\n                }\n                queue.push(maze[start][end]);\n                while (queue.length !== 0) {\n                    let q = queue.shift();\n                    path.push(q);\n                    q.visited = true;\n                    //上\n                    if (q.i - 1 >= 0 && !maze[q.i - 1][q.j].visited && getCubePosition(q.i - 1, q.j).className.indexOf(\"none-bottom\") > 0) {\n                        queue.push(maze[q.i - 1][q.j]);\n                    }\n                    //右\n                    if (q.j + 1 < n && !maze[q.i][q.j + 1].visited && getCubePosition(q.i, q.j).className.indexOf(\"none-right\") > 0) {\n                        queue.push(maze[q.i][q.j + 1]);\n                    }\n                    //下\n                    if (q.i + 1 < n && !maze[q.i + 1][q.j].visited && getCubePosition(q.i, q.j).className.indexOf(\"none-bottom\") > 0) {\n                        queue.push(maze[q.i + 1][q.j]);\n                    }\n                    //左\n                    if (q.j - 1 >= 0 && !maze[q.i][q.j - 1].visited && getCubePosition(q.i, q.j - 1).className.indexOf(\"none-right\") > 0) {\n                        queue.push(maze[q.i][q.j - 1]);\n                    }\n                }\n                let s = 0;\n                let timer = setInterval(function () {\n                    if (s === path.length || (path[s].i === n - 1 && path[s].j === n - 1)) {\n                        clearInterval(timer);\n                        return;\n                    }\n                    s++;\n                    // removeCubePosition(x, y);\n                    x = path[s].i;\n                    y = path[s].j;\n                    changeCubePosition(x, y);\n\n                }, 1);\n\n            }\n```\n\n### 最终效果\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/12.png)\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/13.png)\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/14.png)\n\n观察可以得到，广度优先搜索类似军队，步步为营，一层一层向外扩张的。其优点是可以找到起点到终点的最短路径。\n\n## 广度最短路径\n\n### 算法思想\n\n广度优先是一层一层向外扩张，我们可以画个图来表示一下：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/15.png)\n\n我们可以看到，从起点到终点，我将每一层的数字的标记起来。那么我们可以通过层数从终点来回溯推出最短路径。满足最短路径的条件有：\n\n- 当前单元格与邻近单元格互通（即没有墙）\n- 当前单元格层数大于邻近单元格层数\n\n> 第二点需要说明一下，首先层序遍历的定义决定了起点单元格的层数必定是最小的，我们从终点沿着小于当前单元格层数的路径，肯定能找到起点\n\n### 算法步骤\n\n```Java\n1.使用广度优先搜索求的所有路径及其层数，根据此结果集求最短路径\n2.将终点加入结果数组中（这里数组添加采用头插）\n3.遍历结果集\n    1.结果数组下标为0赋值为当前单元格\n    2.当前结果集遍历为目标单元格\n    3.判断当前单元格与目标单元格是否满足（互通且当前单元格层数大于目标单元格层数），能则加入结果数组\n```\n\n### 具体实现\n\n```JavaScript\n//广度搜索自动寻路\n            function getShortestPathBFS(start, end) {\n                let queue = [];\n                let path = [];\n                for (let i = 0; i < n; i++) {\n                    for (let j = 0; j < n; j++) {\n                        maze[i][j].visited = false;\n                    }\n                }\n                let layer = 1;\n                maze[start][end].layer = layer++;\n                queue.push(maze[start][end]);\n                path.push(maze[start][end]);\n                while (queue.length !== 0) {\n                    for (let i = queue.length; i > 0; i--) {\n                        let q = queue.shift();\n                        path.push(q);\n                        q.visited = true;\n                        //上\n                        if (q.i - 1 >= 0 && !maze[q.i - 1][q.j].visited && getCubePosition(q.i - 1, q.j).className.indexOf(\"none-bottom\") > 0) {\n                            maze[q.i - 1][q.j].layer = layer;\n                            queue.push(maze[q.i - 1][q.j]);\n                        }\n                        //右\n                        if (q.j + 1 < n && !maze[q.i][q.j + 1].visited && getCubePosition(q.i, q.j).className.indexOf(\"none-right\") > 0) {\n                            maze[q.i][q.j + 1].layer = layer;\n                            queue.push(maze[q.i][q.j + 1]);\n                        }\n                        //下\n                        if (q.i + 1 < n && !maze[q.i + 1][q.j].visited && getCubePosition(q.i, q.j).className.indexOf(\"none-bottom\") > 0) {\n                            maze[q.i + 1][q.j].layer = layer;\n                            queue.push(maze[q.i + 1][q.j]);\n                        }\n                        //左\n                        if (q.j - 1 >= 0 && !maze[q.i][q.j - 1].visited && getCubePosition(q.i, q.j - 1).className.indexOf(\"none-right\") > 0) {\n                            maze[q.i][q.j - 1].layer = layer;\n                            queue.push(maze[q.i][q.j - 1]);\n                        }\n                    }\n                    layer++;\n                }\n                let s = 0;\n                // path = getShortestPath(path);\n                // removeCubePosition(x, y);\n                x = path[s].i;\n                y = path[s].j;\n                changeCubePosition(x, y);\n                timer = setInterval(function () {\n                    if (s >= path.length || (path[s].i === n - 1 && path[s].j === n - 1)) {\n                        clearInterval(timer);\n                        return;\n                    }\n                    s++;\n                    // removeCubePosition(x, y);\n                    if (s >= path.length) {\n                        clearInterval(timer);\n                        return;\n                    }\n                    x = path[s].i;\n                    y = path[s].j;\n                    changeCubePosition(x, y);\n                }, 50);\n\n            }\n //根据广度搜索结果集获取最短路径\n function getShortestPath(path) {\n     let result = [];\n     result.push(maze[n - 1][n - 1]);\n     for (let i = path.length - 2; i >= 0; i--) {\n         let cur = result[0];\n         let nei = path[i];\n         if (reachable(cur, nei) && cur.layer > nei.layer) {\n             result.unshift(nei);\n         }\n     }\n     return result;\n }\n//判断cur和nei是否互通\n            function reachable(cur, nei) {\n                //nei在cur的上部\n                if (cur.i - 1 >= 0 && cur.i - 1 === nei.i && cur.j === nei.j) {\n                    return nei.class.indexOf(\"none-bottom\") >= 0;\n                }\n                //nei在cur的右部\n                if (cur.j + 1 < n && cur.j + 1 === nei.j && cur.i === nei.i) {\n                    return cur.class.indexOf(\"none-right\") >= 0;\n\n                }\n                //nei在cur的下部\n                if (cur.i + 1 < n && cur.i + 1 === nei.i && cur.j === nei.j) {\n                    return cur.class.indexOf(\"none-bottom\") >= 0;\n                }\n                //nei在cur的左部\n                if (cur.j - 1 >= 0 && cur.j - 1 === nei.j && cur.i === nei.i) {\n                    return nei.class.indexOf(\"none-right\") >= 0;\n                }\n                return false;\n            }\n```\n\n### 最终效果\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/16.png)\n\n观察上图我们发现，路径中的数字是连起来的，说明已是最短路径。\n\n## 两种路径对比\n\n拿同一个迷宫距离，回溯法求得的路径为：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/17.png)\n\n而通过广度优先求解出的最短路径为：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/18.png)\n\n对比可以发现回溯法求解出来的路径层数是可能有重复，例如上图中的15，16，而广度优先求解出来的是没有重复的，即使最短。因为层数是不可能的跳跃的，这是由广度优先算法的定义所决定的。\n\n# 游戏整体交互\n\n为了使游戏整体的交互性更强，我们增加一些操作面板供玩家选择。其中包括：\n\n- 迷宫生成算法的选择\n- 自动寻路算法的选择\n- 开始游戏选择\n- 游戏成功提示\n- 游戏操作\n\n最终效果如下：\n\n![img](https://geekwolfman-blog.oss-cn-chengdu.aliyuncs.com/articles/%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/19.png)\n\n**完整的代码已经放在码云上，有需要的可以参考：**[迷宫游戏](https://gitee.com/lei-yongjian/maze-game.git)\n\n参考文章：\n\n- [三大迷宫生成算法 (Maze generation algorithm) -- 深度优先，随机Prim，递归分割](https://blog.csdn.net/juzihongle1/article/details/73135920)\n- [基于递归分割的迷宫生成算法与自动寻路](https://blog.csdn.net/yutianzuijin/article/details/52078340)\n- [三种迷宫生成算法概述](https://blog.csdn.net/L__ear/article/details/86758056)\n- [用广度优先算法求解迷宫的最短路径](https://www.cnblogs.com/hirampeng/p/11229411.html)\n","tags":["寻路算法"]},{"title":"hexo博客搭建——从付费到白嫖的极致体验","url":"/2023/03/23/hexo博客搭建——从付费到白嫖的极致体验.html","content":"\n由于自建的博客网站域名和服务器即将到期，本人无力续费，因此选择[hexo](https://hexo.io/zh-cn/)框架重建网站，主题选用轻量美观的[hexo-theme-butterfly](https://github.com/jerryc127/hexo-theme-butterfly)。这里记录一下搭建过程，主要感受一下从付费到白嫖的极致体验。\n\n> 更新一下，由于托管图片加载速度较慢影响体验，后续更改为阿里云oss存储，有少量成本\n# 博客搭建\n\n**hexo框架**\n\n[官方文档](https://hexo.io/zh-cn/docs/)介绍得非常详细，从安装、部署到基本指令以及自定义配置等，请仔细阅读。\n\n**butterfly主题**\n\n这里我们贴出butterfly主题的官方使用文档，非常详细，建议每个文档仔细阅读：\n\n- [Butterfly 安装文档(一) 快速开始](https://butterfly.js.org/posts/21cfbf15/)\n- [Butterfly 安装文档(二) 主题页面](https://butterfly.js.org/posts/dc584b87/)\n- [Butterfly 安装文档(三) 主题配置-1](https://butterfly.js.org/posts/4aa8abbe/)\n- [Butterfly 安装文档(四) 主题配置-2](https://butterfly.js.org/posts/ceeb73f/)\n- [Butterfly 进阶教程](https://butterfly.js.org/posts/4073eda/#iconfont)\n\n# 常用命令\n\n这里整理一下常用命令，完整命令移步到 [hexo框架文档](https://hexo.io/zh-cn/docs/commands) 查看\n\n1. **new**\n\n```Shell\nhexo new [layout] <title>\n```\n\n新建一篇文章。如果没有设置 `layout` 的话，默认使用 [_config.yml](https://hexo.io/zh-cn/docs/configuration) 中的 `default_layout` 参数代替。如果标题包含空格的话，请使用引号括起来。\n\n```Shell\nhexo new \"post title with whitespace\"\n```\n\n| **参数**      | **描述**                                      |\n| ------------- | --------------------------------------------- |\n| -p, --path    | 自定义新文章的路径                            |\n| -r, --replace | 如果存在同名文章，将其替换                    |\n| -s, --slug    | 文章的 Slug，作为新文章的文件名和发布后的 URL |\n\n> 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径\n\n2. **generate**\n\n用于生成静态文件\n\n```Shell\nhexo generate\n```\n\n可简写为：\n\n```Shell\nhexo g\n```\n\n| **选项**          | **描述**                                                     |\n| ----------------- | ------------------------------------------------------------ |\n| -d, --deploy      | 文件生成后立即部署网站                                       |\n| -w, --watch       | 监视文件变动                                                 |\n| -b, --bail        | 生成过程中如果发生任何未处理的异常则抛出异常                 |\n| -f, --force       | 强制重新生成文件，Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean && hexo generate |\n| -c, --concurrency | 最大同时生成文件的数量，默认无限制                           |\n\n3. **server**\n\n启动服务器\n\n```Shell\n hexo server\n```\n\n| **选项**     | **描述**                       |\n| ------------ | ------------------------------ |\n| -p, --port   | 重设端口                       |\n| -s, --static | 只使用静态文件                 |\n| -l, --log    | 启动日记记录，使用覆盖记录格式 |\n\n4. **deploy**\n\n部署网站，将打包的静态文件推送到远端\n\n```Shell\nhexo deploy\n```\n\n可简写为：\n\n```Shell\nhexo d\n```\n\n5. **clean**\n\n```Shell\nhexo clean\n```\n\n> 清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。\n>\n> 在某些情况（尤其是更换主题后），如果发现无论如何也不生效，可能需要运行该命令\n\n# 插件使用\n\n## 文章置顶\n\n使用[hexo-generator-index-pin-top](https://github.com/Qyh-Q/hexo-generator-index-pin-top)插件实现文章置顶功能：\n\n```Shell\nnpm install hexo-generator-index-pin-top --save\n```\n\n在Post Front-matter中添加top属性即可，top值越大，排位越靠前。\n\n## 文章隐藏\n\n使用[hexo-hide-posts](https://github.com/prinsss/hexo-hide-posts)插件实现文章隐藏功能：\n\n```Shell\nnpm install hexo-hide-posts --save\n```\n\n使用文档参考[hexo-hide-posts使用文档](https://github.com/prinsss/hexo-hide-posts/blob/master/README_ZH.md)\n","tags":["hexo","hexo-theme-butterfly"],"categories":["网站搭建"]}]